<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hzxin.top","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文介绍了浏览器渲染引擎的4种绘制图形系统的基础知识。">
<meta property="og:type" content="article">
<meta property="og:title" content="可视化 - 图形基础">
<meta property="og:url" content="https://hzxin.top/2022/02/12/12b509e6174f/index.html">
<meta property="og:site_name" content="种星星">
<meta property="og:description" content="本文介绍了浏览器渲染引擎的4种绘制图形系统的基础知识。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hzxin.top/2022/02/12/12b509e6174f/bargraph_css.png">
<meta property="og:image" content="https://hzxin.top/2022/02/12/12b509e6174f/piegraph_css.png">
<meta property="og:image" content="https://hzxin.top/2022/02/12/12b509e6174f/render_process.png">
<meta property="og:image" content="https://hzxin.top/2022/02/12/12b509e6174f/webgl_result.png">
<meta property="og:image" content="https://hzxin.top/2022/02/12/12b509e6174f/webgl_varying_result.png">
<meta property="article:published_time" content="2022-02-12T07:46:03.000Z">
<meta property="article:modified_time" content="2022-02-13T13:02:41.650Z">
<meta property="article:author" content="种星星">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="可视化">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hzxin.top/2022/02/12/12b509e6174f/bargraph_css.png">

<link rel="canonical" href="https://hzxin.top/2022/02/12/12b509e6174f/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>可视化 - 图形基础 | 种星星</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">种星星</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/huangzhongxin" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hzxin.top/2022/02/12/12b509e6174f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="种星星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="种星星">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          可视化 - 图形基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-12 15:46:03" itemprop="dateCreated datePublished" datetime="2022-02-12T15:46:03+08:00">2022-02-12</time>
            </span>

          
            <span id="/2022/02/12/12b509e6174f/" class="post-meta-item leancloud_visitors" data-flag-title="可视化 - 图形基础" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/12/12b509e6174f/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/12/12b509e6174f/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文介绍了浏览器渲染引擎的4种绘制图形系统的基础知识。</p>
<span id="more"></span>
<h1 id="概述-v15"><a class="header-anchor" href="#概述-v15"></a>概述</h1>
<p>简单来说，可视化就是将数据信息组织起来，以图形的方式呈现出来。现代浏览器中负责绘制图形的部分是渲染引擎。其绘制方式大体可分为4种：</p>
<ol>
<li>传统的<strong>HTML + CSS</strong>。</li>
<li>使用<strong>SVG</strong>。SVG与HTML+CSS的方式差别不大，但是SVG可以弥补HTML在矢量图形绘制方面的能力不足。</li>
<li>使用<strong>Canvas2D</strong>。Canvas2D是浏览器Canvas API的一种上下文，可以使用其绘制出基础的几何图形。</li>
<li>使用<strong>WebGL</strong>。WebGL也是浏览器Canvas API提供的一种上下文，是 OpenGL ES 在Web的实现，通过它，我们可以使用 GPU 进行各种2D、3D图形的渲染。</li>
</ol>
<h1 id="传统的HTML-CSS"><a class="header-anchor" href="#传统的HTML-CSS"></a>传统的HTML + CSS</h1>
<p>在可视化的项目中，直接使用HTML与CSS的相对较少，但是可视化并不是不能使用HTML+CSS，相反，因为现代浏览器的HTML、CSS表现能力强大，一些常见的图表完全可以使用其实现，如柱状图、饼图等。</p>
<p>一些简单的可视化图表，用 CSS 来实现很有好处，既能简化开发，又不需要引入额外的库，可以节省资源，提高网页打开的速度。</p>
<h2 id="实现柱状图"><a class="header-anchor" href="#实现柱状图"></a>实现柱状图</h2>
<p>用 CSS 实现柱状图的方式有很多种，总结起来就是使用 线性渐变（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient()">linear-gradient</a>）配合布局，实现出不同柱子的颜色。这边简单展示下对应代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bargraph&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bargraph</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">5</span>, <span class="number">20%</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bargraph</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 通过transparent实现柱子空白部分的展示，并通过调整不同色块的比例，进行高度调整 */</span></span><br><span class="line"><span class="selector-class">.bargraph</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123;</span><br><span class="line"> <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom, transparent <span class="number">75%</span>, <span class="number">#37c</span> <span class="number">0</span>, <span class="number">#37c</span> <span class="number">85%</span>, <span class="number">#3c7</span> <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bargraph</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line"> <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom, transparent <span class="number">74%</span>, <span class="number">#37c</span> <span class="number">0</span>, <span class="number">#37c</span> <span class="number">89%</span>, <span class="number">#3c7</span> <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bargraph</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span><br><span class="line"> <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom, transparent <span class="number">60%</span>, <span class="number">#37c</span> <span class="number">0</span>, <span class="number">#37c</span> <span class="number">83%</span>, <span class="number">#3c7</span> <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bargraph</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>) &#123;</span><br><span class="line"> <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom, transparent <span class="number">55%</span>, <span class="number">#37c</span> <span class="number">0</span>, <span class="number">#37c</span> <span class="number">75%</span>, <span class="number">#3c7</span> <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bargraph</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">5</span>) &#123;</span><br><span class="line"> <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom, transparent <span class="number">32%</span>, <span class="number">#37c</span> <span class="number">0</span>, <span class="number">#37c</span> <span class="number">63%</span>, <span class="number">#3c7</span> <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>展示效果如下：<br>
<img src="bargraph_css.png" alt=""></p>
<h2 id="实现饼图"><a class="header-anchor" href="#实现饼图"></a>实现饼图</h2>
<p>CSS实现饼图的方法也很简单，使用圆锥渐变（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/conic-gradient()">conic-gradient</a>）即可，代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;piegraph&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.piegraph</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">250px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">250px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="comment">/* 通过定义不同颜色的起始、结束角度，实现饼图效果 */</span></span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">conic-gradient</span>(<span class="number">#37c</span> <span class="number">30deg</span>, <span class="number">#3c7</span> <span class="number">30deg</span>, <span class="number">#3c7</span> <span class="number">65deg</span>, orange <span class="number">65deg</span>, orange <span class="number">110deg</span>, <span class="number">#f73</span> <span class="number">110deg</span>, <span class="number">#f73</span> <span class="number">200deg</span>, <span class="number">#ccc</span> <span class="number">200deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>展示效果如下：<br>
<img src="piegraph_css.png" alt=""></p>
<h2 id="用-HTML-CSS-实现可视化的缺点"><a class="header-anchor" href="#用-HTML-CSS-实现可视化的缺点"></a>用 HTML+CSS 实现可视化的缺点</h2>
<ol>
<li>因为HTML元素一般是矩形，虽然可以通过CSS进行绘制其他形状或不规则的图像，但是总体上还是非常麻烦的。</li>
<li>我们可以看出，通过CSS实现的图表中，大量的数据混杂在了CSS代码中，这导致我们很难看出某个数值与图形的关系，一旦图表或者数据发生改动时，需要开发人员进行重新计算或者对应，加大了维护成本。</li>
<li>另外，因为浏览器在渲染HTML+CSS时，需要进行HTML/CSS解析，生成DOM树等结构，然后进行绘制，当图形发生改变时，可能需要从头开始解析、渲染，这些性能开销是非常大的。</li>
</ol>
<h1 id="SVG"><a class="header-anchor" href="#SVG"></a>SVG</h1>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/SVG">SVG</a>(Scalable Vector Graphics，可缩放矢量图)，是一种基于XML语法的图像格式。在浏览器中，可以像操作普通HTML元素一样，利用DOM API操作SVG元素，并且CSS也可以在SVG上生效。</p>
<p>对比HTML+CSS，在绘制图表时，SVG与其差别不大，只不过是将HTML标签换成SVG标签，使用了一些SVG支持的特殊属性。比如上述的柱状图，使用SVG实现如下：</p>
<figure class="highlight svg"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">width</span>=<span class="string">&quot;120px&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">height</span>=<span class="string">&quot;240px&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">viewBox</span>=<span class="string">&quot;0 0 60 100&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">g</span> <span class="attr">transform</span>=<span class="string">&quot;translate(0, 100) scale(1, -1)&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">g</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;1&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;10&quot;</span> <span class="attr">height</span>=<span class="string">&quot;25&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#37c&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;13&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;10&quot;</span> <span class="attr">height</span>=<span class="string">&quot;26&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#37c&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;25&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;10&quot;</span> <span class="attr">height</span>=<span class="string">&quot;40&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#37c&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;37&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;10&quot;</span> <span class="attr">height</span>=<span class="string">&quot;45&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#37c&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;49&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;10&quot;</span> <span class="attr">height</span>=<span class="string">&quot;68&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#37c&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">g</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;1&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;10&quot;</span> <span class="attr">height</span>=<span class="string">&quot;15&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#3c7&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;13&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;10&quot;</span> <span class="attr">height</span>=<span class="string">&quot;11&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#3c7&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;25&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;10&quot;</span> <span class="attr">height</span>=<span class="string">&quot;17&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#3c7&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;37&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;10&quot;</span> <span class="attr">height</span>=<span class="string">&quot;25&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#3c7&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;49&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;10&quot;</span> <span class="attr">height</span>=<span class="string">&quot;37&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#3c7&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>详细的SVG教程，可以查看<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial">MDN的官方文档</a>。</p>
<h2 id="SVG与HTML-CSS的对比"><a class="header-anchor" href="#SVG与HTML-CSS的对比"></a>SVG与HTML/CSS的对比</h2>
<p>对比HTML+CSS，SVG在在绘制复杂图像，如不规则图像等具有比较明显的优点，除了上述代码中的<code>rect</code>外，SVG还支持诸如圆弧、椭圆、多边形、贝塞尔曲线等。但是，同HTML一样。在浏览器中，SVG一样需要经过解析、渲染树生成等步骤。而且，一个SVG元素一般只表示在展示复杂图形时，生成的SVG元素就会很多，这样一来，对渲染的性能就会有很大影响，因此，SVG只适用于元素较少的场景。</p>
<h1 id="Canvas2D"><a class="header-anchor" href="#Canvas2D"></a>Canvas2D</h1>
<p>在使用 Canvas 进行绘制时，大致需要以下操作：</p>
<ol>
<li>在HTML内使用 <code>Canvas</code> 元素创建一个空白的画布。</li>
<li>在JS代码中获取该画布，并获取其渲染上下文。</li>
<li>使用上下文，设置各种属性，并调用绘图指令进行输出即可。</li>
</ol>
<p>这里，通过绘制一个正方形进行简单介绍。</p>
<h2 id="绘制"><a class="header-anchor" href="#绘制"></a>绘制</h2>
<h3 id="Canvas元素"><a class="header-anchor" href="#Canvas元素"></a>Canvas元素</h3>
<p>对于浏览器而言，Canvas也是一个HTML元素，直接使用 <code>canvas</code> 标签插入到HTML内即可</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">width</span>=<span class="string">&quot;512&quot;</span> <span class="attr">height</span>=<span class="string">&quot;512&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里有一点需要注意的是，Canvas元素上的<code>width</code>与<code>height</code>属性与CSS样式里的属性不完全相同。CSS中的宽高影响的是Canvas在页面上的显示大小（下文称为<strong>样式宽高</strong>），Canvas元素上的<code>width</code>与<code>height</code>属性影响的是Canvas中的坐标系（下文称为<strong>画布宽高</strong>）。如果画布宽高，则默认为<code>300*150</code>。如果未设置样式宽高，则样式宽高默认等于画布宽高。</p>
<p>在上述这段代码中，这个Canvas的样式宽高就是 <code>512px * 512px</code>。</p>
<p>如果我们通过CSS设置了其宽高，比如我们设置为<code>256px</code>，那么画布宽高就是样式宽高的两倍了：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">canvas</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">256px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">256px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为画布宽高决定了可视区域的坐标范围，所以 Canvas 将画布宽高和样式宽高分开的做法，能更方便地适配不同的显示设备。</p>
<p>比如，我们要在画布宽高为 <code>500*500</code> 的 Canvas 画布上，绘制一个居中显示的 <code>100*100</code> 宽高的正方形。我们只要将它的坐标设置在  x = 200, y = 200 处即可。这样，不论这个 Canvas 以多大的尺寸显示在各种设备上，我们的代码都不需要修改。否则，如果 Canvas 的坐标范围（画布宽高）跟着样式宽高变化，那么当屏幕尺寸改变的时候，我们就要重新计算需要绘制的图形的所有坐标。</p>
<p>这里顺便说下，Canvas2D的坐标系是<code>左手系</code>，即x轴为水平向右，y轴垂直向下，与我们一般的xy坐标系的y坐标是相反的。另外，其坐标范围是 <code>(0, 0)</code> 到 <code>(canvas.width, canvas.height)</code> 这样的一个平面区域。</p>
<h3 id="获取上下文"><a class="header-anchor" href="#获取上下文"></a>获取上下文</h3>
<p>JS中获取Canvas2D上下文，需要先获取到这个Canvas元素，然后通过其 <code>getContext</code> 方法获取2d上下文：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;canvas&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> context = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="绘制-v2"><a class="header-anchor" href="#绘制-v2"></a>绘制</h3>
<p>在拿到的 <code>context</code> 对象上会有许多API，大致可以分成两类：一类是设置状态的 API，可以设置或改变当前的绘图状态，比如，改变要绘制图形的颜色、线宽、坐标变换等等；另一类是绘制指令 API，用来绘制不同形状的几何图形。</p>
<p>我们将通过上面所获取到的<code>context</code>在画布中心绘制一个红色正方形。</p>
<p>因为将正方形填充成红色，这一步通过调用 <code>context.fillStyle</code> 指令就可以完成。<br>
然后，我们要调用一个 <code>beginPath</code> 的指令，告诉 Canvas 我们现在绘制的路径。<br>
接着，才是调用 <code>rect</code> 指令完成绘图。因为 <code>rect</code> 指令前两个参数<code>x</code> <code>y</code>表示的是矩形的左上角坐标，所以为了在画布中心绘制，还需要将坐标进行调整。我们可以通过改变<code>x</code> <code>y</code>的值进行调整，也可以通过<code>translate</code>指令对画布进行整体平移，在平移后记得进行恢复。</p>
<p>Canvas 上下文还提供了 <code>save</code> 和 <code>restore</code> 方法，可以暂存和恢复画布某个时刻的状态。其中，<code>save</code> 指令不仅可以保存当前的 <code>translate</code> 状态，还可以保存其他的信息，比如，<code>fillStyle</code> 等颜色信息。 而 <code>restore</code> 指令则可以将状态指令恢复成 <code>save</code> 指令前的设置。</p>
<p>最后，我们还要调用 <code>fill</code> 指令，将绘制的内容真正输出到画布中。这样我们就完整了绘制，绘制的效果和代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rectWidth = <span class="number">100</span></span><br><span class="line"><span class="keyword">const</span> rectHeight = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">context.<span class="title function_">save</span>() <span class="comment">// 暂存状态</span></span><br><span class="line">context.<span class="property">fillStyle</span> = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">context.<span class="title function_">beginPath</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平移</span></span><br><span class="line">context.<span class="title function_">translate</span>(-<span class="number">0.5</span> * rectWidth, -<span class="number">0.5</span> * rectHeight)</span><br><span class="line"></span><br><span class="line">context.<span class="title function_">rect</span>(<span class="number">0.5</span> * canvas.<span class="property">width</span>, <span class="number">0.5</span> * canvas.<span class="property">height</span>, rectWidth, rectHeight)</span><br><span class="line">context.<span class="title function_">fill</span>()</span><br><span class="line"></span><br><span class="line">context.<span class="title function_">restore</span>() <span class="comment">// 恢复状态</span></span><br></pre></td></tr></table></figure>
<p>详细的Canvas教程，可以查看<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial">MDN的官方文档</a>。</p>
<h2 id="Canvas2D与SVG的对比"><a class="header-anchor" href="#Canvas2D与SVG的对比"></a>Canvas2D与SVG的对比</h2>
<p>在实现效果上，SVG与Canvas差别不大，在使用上的不同点可以分成两方面，一是<strong>写法上的不同</strong>，二是<strong>用户交互实现上的不同</strong>。</p>
<h3 id="写法上的不同"><a class="header-anchor" href="#写法上的不同"></a>写法上的不同</h3>
<p>前文有说到，SVG是一种<strong>声明式</strong>绘图系统，而Canvas是一种<strong>指令式</strong>绘图系统。具体而言，SVG 首先通过创建标签来表示图形元素，<code>circle</code> 表示圆，<code>g</code> 表示分组，<code>text</code> 表示文字等等。接着，SVG 通过元素的 <code>setAttribute</code> 给图形元素赋属性值，这个和操作 HTML 元素是一样的。而 Canvas 先是通过上下文执行绘图指令来绘制图形，画圆是调用 <code>context.arc</code> 指令，然后再调用 <code>context.fill</code> 绘制，画文字是调用 <code>context.fillText</code> 指令。另外，Canvas 还通过上下文设置状态属性，<code>context.fillStyle</code> 设置填充颜色，<code>conext.font</code> 设置元素的字体。我们设置的这些状态，在绘图指令执行时才会生效。</p>
<h3 id="用户交互实现上的不同"><a class="header-anchor" href="#用户交互实现上的不同"></a>用户交互实现上的不同</h3>
<p>因为SVG中，一个图形对应一个svg元素，同时SVG也支持CSS样式，所以当我们需要在SVG上增加一些鼠标事件的时候是很方便的。比如，我们需要在鼠标hover某个元素的时候，将这个元素的背景色进行高亮，并且获取这个元素的一些信息，那么我们就可以用如下代码实现：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">&quot;circle&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;100&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;40&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;black&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;2&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;orange&quot;</span> <span class="attr">data-title</span>=<span class="string">&quot;circle&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> circle = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;circle&#x27;</span>)</span><br><span class="line">circle.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseover&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; target &#125; = e</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="title function_">getAttribute</span>(<span class="string">&#x27;data-title&#x27;</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#circle</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  fill: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们实现的方式跟普通的HTML/CSS的方式完全一样的。</p>
<p>反观Canvas，因为Canvas在HTML是一个独立的canvas元素，所有绘制内容都是在内部使用指令完成的，对于浏览器而言，这些绘制内容都是一个个的像素点，当我们要实现类似于hover或者点击事件的时候，我们就得自己去判断这个鼠标位置跟绘制图形的位置关系。对于如圆形这种简单图形而言，这个判断还算简单，我们只要判断鼠标与每个圆的圆心距离关系即可。但是对于一些不规则图形，这个判断就会变得比较复杂，在后续的文章中，我们将单独介绍。</p>
<h1 id="WebGL"><a class="header-anchor" href="#WebGL"></a>WebGL</h1>
<p>在了解<code>WebGL</code>之前，需要先了解下一些图形系统绘制的原理。</p>
<h2 id="图形系统绘制原理"><a class="header-anchor" href="#图形系统绘制原理"></a>图形系统绘制原理</h2>
<p>一个通用计算机图形系统主要包括 6 个部分，分别是输入设备、中央处理单元、图形处理单元、存储器、帧缓存和输出设备。绘制过程示意如下图：<br>
<img src="render_process.png" alt=""><br>
另外还有几个概念需要先清楚下：</p>
<ul>
<li><strong>光栅（Raster）</strong>：几乎所有的现代图形系统都是基于光栅来绘制图形的，光栅就是指构成图像的像素阵列。</li>
<li><strong>像素（Pixel）</strong>：一个像素对应图像上的一个点，它通常保存图像上的某个具体位置的颜色等信息。</li>
<li><strong>帧缓存（Frame Buffer）</strong>：在绘图过程中，像素信息被存放于帧缓存中，帧缓存是一块内存地址。</li>
<li><strong>CPU（Central Processing Unit）</strong>：中央处理单元，负责逻辑计算。</li>
<li><strong>GPU（Graphics Processing Unit）</strong>：图形处理单元，负责图形计算。</li>
</ul>
<p>清楚了这几个概念后，可以用文字描述下绘制过程：</p>
<p>首先，输入的数据经过 <code>CPU</code> 处理，成为具有特定结构的几何信息。然后，这些信息会被送到 <code>GPU</code> 中进行处理。在 <code>GPU</code> 中要经过两个步骤生成<code>光栅</code>信息。这些<code>光栅</code>信息会输出到<code>帧缓存</code>中，最后渲染到屏幕上。</p>
<p>这个绘制过程是现代计算机中任意一种图形系统处理图形的通用过程。它主要做了两件事，一是对给定的数据结合绘图的场景要素（例如相机、光源、遮挡物体等等）进行计算，最终将图形变为屏幕空间的 2D 坐标。二是为屏幕空间的每个像素点进行着色，把最终完成的图形输出到显示设备上。这整个过程是一步一步进行的，前一步的输出就是后一步的输入，所以我们也把这个过程叫做<code>渲染管线（RenderPipelines）</code>。</p>
<p>同时，我们需要知道GPU与CPU的区别。CPU与GPU都是处理单元，但是其结构不同。对于CPU而言，数据是有序进入CPU进行处理，并被依次输出；而GPU则可以同时处理大批量的数据。</p>
<p>好了，了解完这些原理，接下来我们回到WebGL上。</p>
<h2 id="WebGL如何绘制一个三角形"><a class="header-anchor" href="#WebGL如何绘制一个三角形"></a>WebGL如何绘制一个三角形</h2>
<p>在使用 WebGL 进行绘制时，大致需要以下步骤：</p>
<ol>
<li>创建 WebGL 上下文</li>
<li>创建 WebGL 程序（WebGL Program）</li>
<li>将数据存入缓冲区</li>
<li>将缓冲区数据读取到 GPU</li>
<li>GPU 执行 WebGL 程序，输出结果</li>
</ol>
<p>这里，通过绘制一个三角形进行简单介绍。</p>
<h3 id="创建-WebGL-上下文"><a class="header-anchor" href="#创建-WebGL-上下文"></a>创建 WebGL 上下文</h3>
<p>建 WebGL 上下文这一步和 Canvas2D 的使用几乎一样，我们只要调用 canvas 元素的 getContext 即可，区别是将参数从<code>2d</code>换成<code>webgl</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;canvas&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> gl = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;webgl&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>不过，有了 <code>WebGL</code> 上下文对象之后，我们并不能像使用 <code>Canvas2D</code> 的上下文那样，调用几个绘图指令就把图形画出来，还需要做很多工作。</p>
<h3 id="创建-WebGL-程序"><a class="header-anchor" href="#创建-WebGL-程序"></a>创建 WebGL 程序</h3>
<p>接下来，我们要创建一个 WebGL 程序。这里的 WebGL 程序是一个 <code>WebGLProgram</code> 对象，它是给 GPU 最终运行着色器的程序，而不是我们正在写的三角形的 JavaScript 程序。</p>
<p>首先，要创建这个 WebGL 程序，我们需要编写两个<strong>着色器</strong>（Shader）。着色器是用 <code>GLSL</code> 这种编程语言（类似于C语言）编写的代码片段，在这里，我们暂时只需要理解绘制三角形的这两个着色器的作用就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vertex = <span class="string">`</span></span><br><span class="line"><span class="string">  attribute vec2 position;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  void main() &#123;</span></span><br><span class="line"><span class="string">    gl_Position = vec4(position, 1.0, 1.0);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fragment = <span class="string">`</span></span><br><span class="line"><span class="string">  precision mediump float;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  void main()</span></span><br><span class="line"><span class="string">  &#123;</span></span><br><span class="line"><span class="string">    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);</span></span><br><span class="line"><span class="string">  &#125;    </span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>
<p>为什么是两个着色器？这就要求我们先理解另外两个概念：<code>顶点</code>和<code>图元</code>。在绘制的时候，WebGL是以顶点和图元来描述图形的几何信息的。<code>顶点</code>就是几何图形的顶点，比如，三角形有三个顶点，矩形有四个顶点。<code>图元</code>是WebGL能够处理的最小图形单元，由WebGL的绘图模式决定，有<strong>点、线、三角形三种</strong>。</p>
<p>因此，在绘图过程中，顶点和图元是必不可少的，也因此，在WebGL的绘制过程中，一般需要定义两个着色器，一个叫<code>顶点着色器</code>（Vertex Shader）负责处理图形的顶点信息，另一个叫<code>片元着色器</code>（Fragment Shader）负责处理图形的像素信息。</p>
<p>具体点来说，我们可以把<strong>顶点着色器理解为处理顶点的 GPU 程序代码。它可以改变顶点的信息</strong>（如顶点的坐标、法线方向、材质等等），从而改变我们绘制出来的图形的形状或者大小等等。</p>
<p>顶点处理完成之后，WebGL 就会根据顶点和绘图模式指定的图元，计算出需要着色的像素点，然后对它们执行片元着色器程序。简单来说，就是对指定图元中的像素点着色。</p>
<p>WebGL 从顶点着色器和图元提取像素点给片元着色器执行代码的过程，就是我们前面说的生成光栅信息的过程，我们也叫它光栅化过程。所以，<strong>片元着色器的作用，就是处理光栅化后的像素信息</strong>。</p>
<p>举个例子,我们可以将图元设为线段，那么片元着色器就会处理顶点之间的线段上的像素点信息，这样画出来的图形就是空心的。而如果我们把图元设为三角形，那么片元着色器就会处理三角形内部的所有像素点，这样画出来的图形就是实心的。</p>
<p>这边有两点需要注意的。一是图元是 WebGL 可以直接处理的图形单元，所以<strong>其他非图元的图形最终必须要转换为图元</strong>才可以被 WebGL 处理。举个例子，如果我们要绘制实心的四边形，我们就需要将四边形拆分成两个三角形，再交给 WebGL 分别绘制出来。二是<strong>无论有多少个像素点，片元着色器都可以同时处理</strong>，这也是片元着色器一大特点。</p>
<p>介绍完两种着色器，我们继续回到代码。</p>
<p>我们上面定义了顶点着色器和片元着色器两个代码段，接着，我们需要将这两个代码段创建成<code>shader</code>对象，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vertexShader = gl.<span class="title function_">createShader</span>(gl.<span class="property">VERTEX_SHADER</span>)</span><br><span class="line">gl.<span class="title function_">shaderSource</span>(vertexShader, vertex)</span><br><span class="line">gl.<span class="title function_">compileShader</span>(vertexShader)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fragmentShader = gl.<span class="title function_">createShader</span>(gl.<span class="property">FRAGMENT_SHADER</span>)</span><br><span class="line">gl.<span class="title function_">shaderSource</span>(fragmentShader, fragment)</span><br><span class="line">gl.<span class="title function_">compileShader</span>(fragmentShader)</span><br></pre></td></tr></table></figure>
<p>接着，我们创建一个 <code>WebGLProgram</code> 对象，并将这两个 <code>shader</code> 关联到这个 WebGL 程序上。WebGLProgram 对象的创建过程主要是添加 vertexShader 和 fragmentShader，然后将这个 WebGLProgram 对象链接到 WebGL 上下文对象上。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> program = gl.<span class="title function_">createProgram</span>()</span><br><span class="line">gl.<span class="title function_">attachShader</span>(program, vertexShader)</span><br><span class="line">gl.<span class="title function_">attachShader</span>(program, fragmentShader)</span><br><span class="line">gl.<span class="title function_">linkProgram</span>(program)</span><br></pre></td></tr></table></figure>
<p>最后，我们要通过 <code>useProgram</code> 选择启用这个 WebGLProgram 对象。这样，当我们绘制图形时，GPU 就会执行我们通过 WebGLProgram 设定的 两个 <code>shader</code> 程序了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.<span class="title function_">useProgram</span>(program)</span><br></pre></td></tr></table></figure>
<p>到此为止，我们已经完成了 WebGL 程序的创建。</p>
<h3 id="将数据存入缓冲区"><a class="header-anchor" href="#将数据存入缓冲区"></a>将数据存入缓冲区</h3>
<p>与<code>Canvas</code>的坐标系不同，<code>WebGL</code>的坐标系是<code>右手系</code>，并且其坐标范围恒为<code>x∈[-1, 1], y∈[-1,1]</code>这样一个区域。</p>
<p>这里我们绘制一个三个顶点分别为(-1, -1)、(0, 1)、(1, -1)的三角形。</p>
<p><strong>首先，我们要定义这个三角形的三个顶点</strong>。WebGL 使用的数据需要用类型数组定义，默认格式是 <code>Float32Array</code> 这种类型化数组，其使用起来跟普通的<code>Array</code>差不多，具体可以看<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">MDN的官方文档</a>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> points = <span class="keyword">new</span> <span class="title class_">Float32Array</span>([</span><br><span class="line">  -<span class="number">1</span>, -<span class="number">1</span>,</span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>, -<span class="number">1</span>,</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p><strong>接着，我们要将定义好的数据写入 WebGL 的缓冲区</strong>。这个过程我们可以简单总结为三步，分别是:</p>
<ol>
<li>创建一个缓存对象</li>
<li>将它绑定为当前操作对象</li>
<li>再把当前的数据写入缓存对象。</li>
</ol>
<p>这三个步骤主要是利用 <code>createBuffer</code>、<code>bindBuffer</code>、<code>bufferData</code> 方法来实现的，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bufferId = gl.<span class="title function_">createBuffer</span>()</span><br><span class="line">gl.<span class="title function_">bindBuffer</span>(gl.<span class="property">ARRAY_BUFFER</span>, bufferId)</span><br><span class="line">gl.<span class="title function_">bufferData</span>(gl.<span class="property">ARRAY_BUFFER</span>, points, gl.<span class="property">STATIC_DRAW</span>)</span><br></pre></td></tr></table></figure>
<h3 id="将缓冲区数据读取到-GPU"><a class="header-anchor" href="#将缓冲区数据读取到-GPU"></a>将缓冲区数据读取到 GPU</h3>
<p>经过以上步骤，我们已经把数据写到缓冲区了，接下来我们要将数据绑定到上面定义的顶点着色器的<code>position</code>变量，使得<code>shader</code>能够读取到我们定义的数据。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vPosition = gl.<span class="title function_">getAttribLocation</span>(program, <span class="string">&#x27;position&#x27;</span>) <span class="comment">// 获取顶点着色器中的position变量的地址</span></span><br><span class="line">gl.<span class="title function_">vertexAttribPointer</span>(vPosition, <span class="number">2</span>, gl.<span class="property">FLOAT</span>, <span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span>) <span class="comment">// 给变量设置长度和类型</span></span><br><span class="line">gl.<span class="title function_">enableVertexAttribArray</span>(vPosition) <span class="comment">// 激活这个变量</span></span><br></pre></td></tr></table></figure>
<h3 id="执行着色器程序完成绘制"><a class="header-anchor" href="#执行着色器程序完成绘制"></a>执行着色器程序完成绘制</h3>
<p>现在，我们已经有了 WebGL 程序，也将数据写到缓冲区，并且着色器也能拿到缓冲区里的数据了。那么，现在我们就可以进行绘制了这里我们选择 <code>gl.TRIANGLES</code> 表示以三角形为图元绘制，再传入绘制的顶点偏移量和顶点数量，WebGL 就会将对应的 <code>buffer</code> 数组传给顶点着色器，并且开始绘制。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.<span class="title function_">drawArrays</span>(gl.<span class="property">TRIANGLES</span>, <span class="number">0</span>, points.<span class="property">length</span> / <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>最终绘制结果如下：<br>
<img src="webgl_result.png" alt=""></p>
<h2 id="片元着色器"><a class="header-anchor" href="#片元着色器"></a>片元着色器</h2>
<p>回顾下上面的片元着色器代码：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>第1行中，我们全局声明了片元着色器中浮点数类型的精度。<br>
第4行中，<code>gl_FragColor</code> 是 WebGL 片元着色器的一个内置变量，表示当前像素点颜色，它是一个用 <code>RGBA</code> 色值表示的四维向量数据。上面的代码中，我们赋值为<code>vec4(1.0, 0.0, 0.0, 1.0)</code>，所以最后绘制出来的三角形是红色的，如果我们赋值为<code>vec4(0.0, 0.0, 1.0, 1.0)</code>，那么最终绘制出来的就是一个蓝色三角形。</p>
<p>可以看到，我们只改变了一个颜色，最终所有像素点的颜色都跟着变成了蓝色，这也说明了GPU是<strong>同时</strong>对<strong>所有像素点</strong>都执行了这段着色器代码的。</p>
<h2 id="顶点着色器"><a class="header-anchor" href="#顶点着色器"></a>顶点着色器</h2>
<p>看完片元着色器，我们在接着看下顶点着色器：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">attribute</span> <span class="type">vec2</span> position;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(position, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第1行中，我们使用<code>attribute</code>声明了一个<code>vec2</code>类型的二维向量<code>position</code>。<br>
<code>attribute</code>是一种<code>存储限定符</code>(类似于js中的<code>var/let/const</code>)，此外，还存在 <code>uniform</code>, <code>varying</code> 这两种存储限定符，这边简要介绍下：</p>
<ul>
<li><code>attribute</code>: 只能出现在顶点着色器中，被用来从外部（如JS程序）向 WebGL 内部中传递顶点信息（比如坐标、颜色）</li>
<li><code>uniform</code>: 可以出现在顶点着色器和片元着色器中，可以理解为只读的全局变量，也是用于外部程序向 WebGL 内部传递信息</li>
<li><code>varying</code>: 可以出现在顶点着色器和片元着色器中，可以理解为可变的全局变量，是顶点着色器向片元着色器传递信息的渠道</li>
</ul>
<p>第4行中，<code>gl_Position</code> 是 WebGL 顶点着色器的一个内置变量，表示当前顶点坐标的位置，是一个<strong>四维向量</strong>数据，注意，WebGL 中的坐标虽然是三维坐标，但是在表示坐标时，WebGL 使用的是<strong>齐次坐标</strong>进行表示，针对(x, y, z, w)这样一个齐次坐标，等同于(x/w, y/w, z/w)这样一个三维坐标。</p>
<p>这边介绍下<code>varying</code>的用法。</p>
<p>我们修改上面的顶点着色器代码为下面这样：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">attribute</span> <span class="type">vec2</span> position;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec3</span> color;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">gl_PointSize</span> = <span class="number">1.0</span>;</span><br><span class="line">  color = <span class="type">vec3</span>(<span class="number">0.5</span> + position * <span class="number">0.5</span>, <span class="number">0.0</span>);</span><br><span class="line">  <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(position * <span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边我们声明了一个<code>color</code>的变量，并且通过顶点坐标映射了一个颜色<br>
（<code>vec3(0.5 + position * 0.5, 0.0)</code>），这样子，顶点(-1, -1)对应的颜色就是(0, 0, 0)，也就是黑色，顶点(0, 1)对应的颜色就是(0.5, 1, 0)、顶点(1, -1)对应的颜色就是(1, 0, 0)。</p>
<p>然后，我们也对片元着色器进行修改：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec3</span> color;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(color, <span class="number">1.0</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>同样的，我们也在片元着色器内声明了<code>color</code>变量，并且将<code>gl_FragColor</code>使用<code>color</code>进行赋值。这样，我们就得到了一个渐变色的三角形：<br>
<img src="webgl_varying_result.png" alt=""></p>
<p>可以发现，三个顶点中间像素点的颜色是均匀过渡的。这是因为 WebGL 在执行片元着色器程序的时候，顶点着色器传给片元着色器的变量，会根据片元着色器的像素坐标对变量进行<strong>线性插值</strong>。</p>
<p>详细的WebGL教程，可以查看<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API">MDN的官方文档</a>。</p>
<h1 id="参考-v5"><a class="header-anchor" href="#参考-v5"></a>参考</h1>
<p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100053801?tab=catalog">极客时间 - 跟月影学可视化</a><br>
<a target="_blank" rel="noopener" href="https://github.com/lesnitsky/webgl-month">Github - lesnitsky/webgl-month</a><br>
<a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/511aa64f69530ed3061829351">入门 WebGL，看这一篇就够了</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
              <a href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/" rel="tag"># 可视化</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/14/db838f9ad264/" rel="prev" title="webpack构建体积优化">
      <i class="fa fa-chevron-left"></i> webpack构建体积优化
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-v15"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84HTML-CSS"><span class="nav-number">2.</span> <span class="nav-text">传统的HTML + CSS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%9F%B1%E7%8A%B6%E5%9B%BE"><span class="nav-number">2.1.</span> <span class="nav-text">实现柱状图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E9%A5%BC%E5%9B%BE"><span class="nav-number">2.2.</span> <span class="nav-text">实现饼图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8-HTML-CSS-%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">2.3.</span> <span class="nav-text">用 HTML+CSS 实现可视化的缺点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SVG"><span class="nav-number">3.</span> <span class="nav-text">SVG</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SVG%E4%B8%8EHTML-CSS%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">3.1.</span> <span class="nav-text">SVG与HTML&#x2F;CSS的对比</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Canvas2D"><span class="nav-number">4.</span> <span class="nav-text">Canvas2D</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%98%E5%88%B6"><span class="nav-number">4.1.</span> <span class="nav-text">绘制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Canvas%E5%85%83%E7%B4%A0"><span class="nav-number">4.1.1.</span> <span class="nav-text">Canvas元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-number">4.1.2.</span> <span class="nav-text">获取上下文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%98%E5%88%B6-v2"><span class="nav-number">4.1.3.</span> <span class="nav-text">绘制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Canvas2D%E4%B8%8ESVG%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">4.2.</span> <span class="nav-text">Canvas2D与SVG的对比</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E6%B3%95%E4%B8%8A%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="nav-number">4.2.1.</span> <span class="nav-text">写法上的不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92%E5%AE%9E%E7%8E%B0%E4%B8%8A%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="nav-number">4.2.2.</span> <span class="nav-text">用户交互实现上的不同</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#WebGL"><span class="nav-number">5.</span> <span class="nav-text">WebGL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86"><span class="nav-number">5.1.</span> <span class="nav-text">图形系统绘制原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WebGL%E5%A6%82%E4%BD%95%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="nav-number">5.2.</span> <span class="nav-text">WebGL如何绘制一个三角形</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-WebGL-%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-number">5.2.1.</span> <span class="nav-text">创建 WebGL 上下文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-WebGL-%E7%A8%8B%E5%BA%8F"><span class="nav-number">5.2.2.</span> <span class="nav-text">创建 WebGL 程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">5.2.3.</span> <span class="nav-text">将数据存入缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E7%BC%93%E5%86%B2%E5%8C%BA%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E5%88%B0-GPU"><span class="nav-number">5.2.4.</span> <span class="nav-text">将缓冲区数据读取到 GPU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E5%AE%8C%E6%88%90%E7%BB%98%E5%88%B6"><span class="nav-number">5.2.5.</span> <span class="nav-text">执行着色器程序完成绘制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">5.3.</span> <span class="nav-text">片元着色器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">5.4.</span> <span class="nav-text">顶点着色器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83-v5"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">种星星</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/huangzhongxin" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huangzhongxin" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-star"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">种星星</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'vkPGlLY8mLj583EhctSAEi9y-gzGzoHsz',
      appKey     : 'HTNCUx3XvihCygqrsbQx43Yt',
      placeholder: "",
      avatar     : 'monsterid',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
