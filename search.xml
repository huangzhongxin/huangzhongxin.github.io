<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[webpack中的一些常用配置]]></title>
    <url>%2F2019%2F11%2F29%2Fwebpack%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本文介绍了webpack中4个插件的使用。 自动清理构建目录 每次webpack构建完之后，都会在输出目录生成构建好的文件。如果没有清理掉之前的构建文件的话，在多次构建之后，这个输出目录无用文件就会很多。而手动清理又比较麻烦。webpack中clean-webpack-plugin可以实现每次构建前，自动删除output指定的目录： 使用前先安装： 1npm i clean-webpack-plugin -D 123456789101112131415161718// webpack.config.jsconst path = require('path')const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin')module.exporte = &#123; entry: &#123; index: './src/index.js', search: './src/search.js' &#125;, output: &#123; path: path.join(__dirname, 'dist'), filename: '[name].[chunkhash:8].js' &#125;, plugins: [ // ... new CleanWebpackPlugin() ], // ...&#125; 注意，在clean-webpack-plugin v3的版本中，只能够使用解构的方式引入 自动补齐CSS3前缀 由于浏览器标准没有统一，我们需要去兼容许多问题，比如样式不一样。不同浏览器CSS样式可能需要不同的前缀，如 -webkit、-moz 等等，可以使用 autoprefixer 来自动补全前缀。 autoprefixer 是一个后置处理器，根据的是 Can I Use 这个网站上给出的兼容情况进行补齐前缀。 autoprefixer 一般是与 postcss-loader 一起使用，所以使用前需要先安装两者： 1npm i postcss-loader autoprefixer -D 安装完毕之后，就可以配置下 webpack.config.js： 1234567891011121314151617181920212223242526272829303132333435// webpack.config.jsconst path = require('path')module.exporte = &#123; entry: &#123; index: './src/index.js', search: './src/search.js' &#125;, output: &#123; path: path.join(__dirname, 'dist'), filename: '[name].[chunkhash:8].js' &#125;, module: &#123; rules: [ &#123; test: /\.jsx?$/, use: 'babel-loader' &#125;, &#123; test: /\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader'] &#125;, &#123; test: /\.less$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader', 'postcss-loader'] &#125;, ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: '[name].[contenthash:8].css' &#125;) ] // ...&#125; 然后增加postcss-loader的配置文件postcss.config.js： 1234// postcss.config.jsmodule.exports = &#123; plugins: [require('autoprefixer')]&#125; 此外还需要在package.json或.broswerlistrc中增加autoprefixer要兼容的浏览器版本： 1browserslist: ["last 2 version", "&gt;1%"] 静态资源内联 静态资源内联，可以减少HTTP请求数；CSS内联也可以避免页面闪动；JS代码内联可以用于上报相关打点，以及完成页面框架的初始化工作。 使用raw-loader达到静态资源内联的目的。 ¶JS/HTML的内联 在 html 页面中需要内联静态资源的地方，使用raw-loader的语法，将静态资源引入就可以： 1234// html$&#123;require('raw-loader!/path/to/assert.html').default&#125;// js$&#123;require('raw-loader!babel-loader!/path/to/assert.js').default&#125; 注意：在 raw-loader v0.5.1 中，require 后不需要加 .default ¶CSS的内联 在 webpack.config.js 的 module 使用 style-loader 插件即可。 px 自动转换为 rem rem: font-size of root element -&gt; Rem布局的原理解析 px转换为rem，可以使用 px2rem-loader 插件完成。使用时，需要指定两个参数：remUnit - rem的单位，即 1rem = remUnit px，remPrecesion - 转换成 rem 后保留的小数位数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// webpack.config.jsconst path = require('path')module.exporte = &#123; entry: &#123; index: './src/index.js', search: './src/search.js' &#125;, output: &#123; path: path.join(__dirname, 'dist'), filename: '[name].[chunkhash:8].js' &#125;, module: &#123; rules: [ &#123; test: /\.jsx?$/, use: 'babel-loader' &#125;, &#123; test: /\.css$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'less-loader', 'postcss-loader', &#123; loader: 'px2rem-loader', options: &#123; remUnit: 75, remPrecesion: 8 &#125; &#125; ] &#125;, &#123; test: /\.less$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'less-loader', 'postcss-loader', &#123; loader: 'px2rem-loader', options: &#123; remUnit: 75, remPrecesion: 8 &#125; &#125; ] &#125;, ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: '[name].[contenthash:8].css' &#125;) ] // ...&#125; 此外，为了动态计算根节点的 font-size，可以在CSS中加入： 123html: &#123; font-size:calc(100vw/固定分辨率)&#125;]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack中的代码压缩]]></title>
    <url>%2F2019%2F11%2F26%2Fwebpack%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[本文介绍了webpack中JS、HTML、CSS进行代码压缩的方式。 JS 设置 mode为 production 配置后，webpack v4+ 默认会压缩你的代码。生产环境下默认使用 UglifyJSPlugin。 所以无需手动配置压缩选项。 HTML 压缩HTML可以使用插件html-webpack-plugin，并配置相关参数进行使用，这里给出一个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// webpack.config.jsconst path = require('path')const MiniCssExtractPlugin = require('mini-css-extract-plugin')const HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; mode: 'production', entry: &#123; index: './src/index.js', search: './src/index2.jsx' &#125;, output: &#123; path: path.join(__dirname, 'dist'), filename: '[name].[chunkhash:8].js' &#125;, module: &#123; rules: [ &#123; test: /\.jsx?$/, use: 'babel-loader' &#125;, &#123; test: /\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader'] &#125;, &#123; test: /\.less$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader'] &#125;, &#123; test: /\.(png|svg|jpg|gif)$/, use: [ &#123; loader: 'file-loader', options: &#123; name: 'img/[name].[hash:8].[ext]' &#125; &#125; ] &#125; ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: '[name].[contenthash:8].css' &#125;), new HtmlWebpackPlugin(&#123; template: path.join(__dirname, './src/index.html'), // 使用的模板 filename: 'idnex.html', // 生成的文件名 chunks: ['index'], // 生成的html使用的chunk inject: true, // 设置为true时，使用到的chunk，css会自动注入到html中 minify: &#123; html5: true, minifyCSS: true, // 压缩内联CSS minifyJS: true, // 压缩内联JS removeComments: true, // 移除注释 collapseWhitespace: true, // 删除空格、换行等空白符 preserveLineBreaks: false, // 保留换行 &#125; &#125;), new HtmlWebpackPlugin(&#123; template: path.join(__dirname, './src/search.html'), // 使用的模板 filename: 'search.html', // 生成的文件名 chunks: ['search'], // 生成的html使用的chunk inject: true, // 设置为true时，使用到的chunk，css会自动注入到html中 minify: &#123; html5: true, minifyCSS: true, // 压缩内联CSS minifyJS: true, // 压缩内联JS removeComments: true, // 移除注释 collapseWhitespace: true, // 删除空格、换行等空白符 preserveLineBreaks: false, // 保留换行 &#125; &#125;) ]&#125; 压缩前： 压缩后： CSS 压缩CSS代码，可通过optimize-css-assets-webpack-plugin插件完成。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// webpack.config.jsconst path = require('path')const MiniCssExtractPlugin = require('mini-css-extract-plugin')const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')const HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; mode: 'production', entry: &#123; index: './src/index.js', search: './src/index2.jsx' &#125;, output: &#123; path: path.join(__dirname, 'dist'), filename: '[name].[chunkhash:8].js' &#125;, module: &#123; rules: [ &#123; test: /\.jsx?$/, use: 'babel-loader' &#125;, &#123; test: /\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader'] &#125;, &#123; test: /\.less$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader'] &#125;, &#123; test: /\.(png|svg|jpg|gif)$/, use: [ &#123; loader: 'file-loader', options: &#123; name: 'img/[name].[hash:8].[ext]' &#125; &#125; ] &#125; ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: '[name].[contenthash:8].css' &#125;), new HtmlWebpackPlugin(&#123; template: path.join(__dirname, './src/index.html'), // 使用的模板 filename: 'index.html', // 生成的文件名 chunks: ['index'], // 生成的html使用的chunk inject: true, // 设置为true时，使用到的chunk，css会自动注入到html中 minify: &#123; html5: true, minifyCSS: true, // 压缩内联CSS minifyJS: true, // 压缩内联JS removeComments: true, // 移除注释 collapseWhitespace: true, // 删除空格、换行等空白符 preserveLineBreaks: false, // 保留换行 &#125; &#125;), new HtmlWebpackPlugin(&#123; template: path.join(__dirname, './src/search.html'), // 使用的模板 filename: 'search.html', // 生成的文件名 chunks: ['search'], // 生成的html使用的chunk inject: true, // 设置为true时，使用到的chunk，css会自动注入到html中 minify: &#123; html5: true, minifyCSS: true, // 压缩内联CSS minifyJS: true, // 压缩内联JS removeComments: true, // 移除注释 collapseWhitespace: true, // 删除空格、换行等空白符 preserveLineBreaks: false, // 保留换行 &#125; &#125;), new OptimizeCssAssetsWebpackPlugin(&#123; assetNameRegExp: /\.css$/g, // 需要压缩的文件名的正则表达式 cssProcessor: require('cssnano') // 使用的压缩处理器 &#125;) ]&#125; 压缩前： 压缩后： 总结 webpack中对于代码压缩还是比较简单的，只要配置一些插件就能够实现了，因此上手难度并不大。]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack中的文件指纹:hash/chunkhash/contenthash]]></title>
    <url>%2F2019%2F11%2F23%2Fwebpack%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%8C%87%E7%BA%B9-hash-chunkhash-contenthash%2F</url>
    <content type="text"><![CDATA[本文介绍了webpack中的三种文件指纹的用法及其区别。 什么是文件指纹 所谓的文件指纹就是一个hash值（或hash值的一部分），我们可以通过文件指纹来实现前端资源的增量更新。具体而言，就是在资源名上添加一段hash值，通过浏览器的缓存策略，实现未改动的资源不重复下载。比如Element UI官网中，就有使用到文件指纹： 使用 在webpack中，我们可以通过配置output的filename字段，来控制输出的文件名。因此，我们可以在这边加上[hash]等占位符，来实现文件指纹。 例如，我们配置webpack.config.js内容如下： 12345678910111213// webpack.config.jsconst path = require('path');module.exports = &#123; entry: &#123; vendor: './src/vendor.js', index: './src/index.js' &#125;, output: &#123; path: path.join(__dirname, 'dist'), filename: '[name].[hash].js' &#125;&#125;; 运行npm run build后就能得到如下输出： 可以看到，输出的文件名上已经多出了一串hash值。但是，我们也可以看到，这两个文件名上的hash是一样的，也就是说，每次构建出来，每个文件都是一个新构建的，不管其是否真正改动过。这样并不符合我们的预期：只更新我们有改动的文件，而未改动的不需要用户去下载。 为此，我们根据不同文件，使用webpack给我们提供的不同占位符：[hash]、[chunkhash]、[contenthash] ¶[hash] hash是根据整个项目的构建求出来的，如果使用了hash，那么每个模块都会有同样的hash值，不管这个模块是不是又改动过。因此不能达到增量更新的效果。 ¶[chunkhash] chunkhash是由chunk计算的得出的hash值，chunk指的是模块，这个hash值就是模块内容计算出来的hash值。 ¶用法 12345678910111213// webpack.config.jsconst path = require('path');module.exports = &#123; entry: &#123; vendor: './src/vendor.js', index: './src/index.js' &#125;, output: &#123; path: path.join(__dirname, 'dist'), filename: '[name].[chunkhash].js' &#125;&#125;; 运行npm run build后就能得到如下输出： 改变前： 改变vendor.js后： 可以看到vendor的hash已经改变了，而index得没有发生改变。 注意：为了让hash值保持稳定，还应添加NamedModulesPlugin(开发环境)或HashedModuleIdsPlugin(生产环境)，这两个plugin能够让webpack使用相对路径而非模块id来命名模块。 如果我们将js中的css抽取成单独的文件后，并且也是用chunkhash，会出现这样一个问题：仅仅改动了js文件，css也跟着一起改了，这就导致了不必要的更新。 为此，我们在css等文件中，需要使用下面的contenthash这个占位符。 ¶[contenthash] contenthash用于求文件内容的hash值。这个hash值只与文件内容有关，而与chunk无关。 首先，我们使用MiniCssExtractPlugin将js中的css抽取出来： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// webpack.config.jsconst path = require('path')const MiniCssExtractPlugin = require('mini-css-extract-plugin')module.exports = &#123; mode: 'production', entry: &#123; index: './src/index.js', vendor: './src/vendor.js' &#125;, output: &#123; path: path.join(__dirname, 'dist'), filename: '[name].[chunkhash].js' &#125;, module: &#123; rules: [ &#123; test: /\.jsx?$/, use: 'babel-loader' &#125;, &#123; test: /\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader'] &#125;, &#123; test: /\.less$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader'] &#125;, &#123; test: /\.s[ac]ss$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader'] &#125;, &#123; test: /\.(png|svg|jpg|gif)$/, use: ['file-loader'] &#125; ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: '[name].[contenthash].css' &#125;) ]&#125; 这里需要注意的是，loader上，我们使用了MiniCssExtractPlugin.loader而不是style-loader，因为style-loader的用处是将css放到&lt;style&gt;标签中，与MiniCssExtractPlugin.loader冲突了。 运行npm run build就能看到css的hash值已经与js无关了： 最后 我们可以看到上面生成的hash都是比较长的，我们可以在占位符上指定我们要的长度，来生成我们想要的位数，如：[hash:8]、[chunkhash:8]、[contenthash:8] 参考 webpack稳定moduleid和chunkid以实现持久化缓存的梳理]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack中的文件监听及热更新]]></title>
    <url>%2F2019%2F11%2F18%2Fwebpack%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E7%9B%91%E5%90%AC%E5%8F%8A%E7%83%AD%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[本文介绍了webpack中开启文件监听的两种方法以及热更新的原理 文件监听 webpack中，为了避免每次更新代码后都需要手动构建，可以开启文件监听选项。开启文件监听后，webpack会调用Node.js里面的文件读取API fs这个模块来判断文件内容是否变化，并且在文件变化的时候自动构建。 开启文件监听的方法有两种： 命令行 webpack.config.js中进行配置 ¶命令行 在启动webpack命令的时候，带上--watch参数即可，即： 1webpack --watch ¶配置文件 123456789101112131415// webpack.config.jsmodule.exports = &#123; // ... // 是否开启文件监听，默认false，即不开启 watch: true, // 只有设置了 watch === true，watchOptions才有用 watchOptions: &#123; // 不监听的文件或文件夹，支持正则，默认为空 ignored: /node_modules/, // 监听到改变后的延时，默认300ms aggregateTimeout: 300, // 轮询间隔，默认1000ms poll: 1000 &#125;&#125; 热更新 ¶使用 热更新需要使用到插件webpack-dev-server(WDS)，WDS使用时需要配合插件HotModuleReplacementPlugin一起使用（这个插件会在配置hot: true自动添加，可以不手动添加） 首先，先安装WDS： 1npm i webpack-dev-server -D 使用时，在webpack.config.js中配置下devServer： 12345678// webpack.config.jsmodule.exports = &#123; // ... devServer: &#123; contentBase: './dist', // WDS的基础目录 hot: true &#125;&#125; 最后使用命令webpack-dev-server --open启动即可 –open：在构建结束后自动打开浏览器 ¶原理 webpack compiler: 将JS构建为Bundle HMR Server: 将热更新的文件输出给HMR Runtime Bundle Server: 提供文件在浏览器访问 HMR Runtime: 被注入到bundle.js中，更新文件变化 bundle.js: 构建输出的文件 热更新中最核心的是HMR Server和HMR Runtime： HMR Server是服务端，用来将变化的 js 模块通过 websocket 的消息通知给浏览器端。 HMR Runtime是浏览器端，用于接受 HMR Server 传递的模块数据，浏览器端可以看到 .hot-update.json 的文件。 热更新分为两个阶段： 启动阶段： 启动阶段就是在文件系统中，将初始代码通过Webpack Compiler打包，并将打包好的代码，传输给Bundle Server。Bundle Server其实就是一个服务器，通过Bundle Server，浏览器就能访问到打包好的文件。这个过程即图上的 1 -&gt; 2 -&gt; A -&gt; B 更新阶段： 如果文件系统中的代码发生了改变，代码还是会经过Webpack Compiler打包，打包好了会把代码发送给HMR Server，HMR Server中能够对比得到具体是哪些文件发生了改变。接着HMR Server就会通知HMR Runtime，HMR Runtime就会更新代码，最终就可以不需要刷新浏览器就看到最新的代码。即图上的 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用webpack解析一些常见资源]]></title>
    <url>%2F2019%2F11%2F17%2F%E4%BD%BF%E7%94%A8webpack%E8%A7%A3%E6%9E%90%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[本文介绍了如何使用webpack解析ES6、JSX、CSS等资源 解析ES6 解析es6需要使用到babel，同时需要使用babel-loader 首先，先配置babel配置文件.babelrc： 1234567// .babelrc&#123; "presets": [ "@babel/preset-env" // 增加ES6的babel preset配置 ], "plugins": []&#125; .babelrc文件中的plugins字段，可以理解为一个plugin对应一个功能， 而presets则是多个plugin的集合 接着需要在webpack.config.js中增加相关loader的配置： 12345678910111213// webpack.config.jsmodule.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\.js$/, use: 'babel-loader' &#125; ] &#125;, // ...&#125; 然后安装相关依赖： 1npm i @babel/core @babel/preset-env babel-loader -D 安装完毕重新编译下即可。 解析React JSX 首先，先配置babel配置文件.babelrc： 12345678// .babelrc&#123; "presets": [ "@babel/preset-env", "@babel/preset-react" // 增加react jsx的babel preset配置 ], "plugins": []&#125; 接着在webpack.config.js中修改babel-loader的校验规则： 12345678910111213// webpack.config.jsmodule.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\.jsx?$/, // js、jsx文件 use: 'babel-loader' &#125; ] &#125;, // ...&#125; 然后安装相关依赖： 1npm i @babel/preset-react -D 安装完毕即可使用react的jsx相关语法。 解析CSS 解析CSS需要用到两个loader： css-loader加载css文件，并转换为commonJS对象 style-loader将样式通过&lt;style&gt;标签插入到head中 在webpack.config.js中修改loader配置： 12345678910111213// webpack.config.jsmodule.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125; ] &#125;, // ...&#125; 需要注意的是，loaders链式调用，从右到左，所以先写style-loader，再写css-loader 然后安装相关依赖： 1npm i style-loader css-loader -D 解析Less、Sass Less和Sass的解析步骤与CSS类似，只需要多一步将Less/Sass转换为CSS即可。 配置如下： 1234567891011121314151617// webpack.config.jsmodule.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125;, &#123; test: /\.s[ac]ss$/, // sass和scss文件 use: ['style-loader', 'css-loader', 'sass-loader'] &#125; ] &#125;, // ...&#125; 注意，less-loader需要一同安装less；sass-loader需要一同安装node-sass 解析图片、字体等 解析图片、字体等文件，可使用file-loader或url-loader。 url-loader底层也是调用的file-loader。 在使用上，url-loader可以将小资源以Base64的方式编码到文件中，减少文件数，使用方法如下： 123456789101112131415161718// webpack.config.jsmodule.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\.(png|jpg|ttf)$/, use: [&#123; loader: 'url-loader', options: &#123; limit: 10240 // = 10KB &#125; &#125;] &#125; ] &#125;, // ...&#125;]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack的几个核心概念]]></title>
    <url>%2F2019%2F11%2F17%2Fwebpack%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[什么是webpack webpack本质上是一个打包工具，它会根据代码的内容解析模块依赖，帮助我们把多个模块的代码打包。下面是webpack官网给的一个说明图。 如上图，webpack 会把项目中使用到的多个代码模块（可以是不同文件类型），打包构建成项目运行仅需要的几个静态文件（如.js、.css等）。 webpack 安装 webpack支持使用npm或者yarn方式进行安装，当然也可以作为一个全局的命令来使用。 123npm install webpack webpack-cli -g # 或者yarn global add webpack webpack-cli webpack的几个核心概念 webpack的配置文件通常为webpack.config.js，放置于项目的根目录中。此外，也能够使用webpack --config来指定使用的配置文件。 一个简单的配置文件如下： 123456789101112131415// webpack.config.jsconst path = requore('path')module.exports = &#123; entry: './src/index.js', // 指定入口文件 output: &#123; // 指定输出文件 path: path.resolve(__dirname, '/dist'), filename: 'bundle.js' &#125;, mode: 'development', // 指定构建环境 module: &#123; rules: [] // 配置loaders &#125;, plugins: [] // 配置plugins&#125; ¶entry entry 用于指定打包入口。目前入口文件只支持js，其它的如html和css都不支持。 webpack会把js、css、图片等等当成一个个模块，各模块间会存在一系列的依赖关系，在webpack里面，会根据entry指定的文件，找到依赖，entry文件的依赖也可能会以来其他模块，这样就会生成一棵依赖树。webpack会遍历这课依赖树，遍历完了才会生成打包资源。 entry可以指定单入口与多入口。 ¶单入口 单入口适用于单页应用，其使用一个字符串来给定入口文件的地址，如下： 1entry: &apos;./src/index.js&apos; ¶多入口 多入口适用于多页应用，其使用一个对象来给定入口文件的地址，该对象为键值对的形式，键为入口模块的名字，值为文件地址如下： 12345entry: &#123; app: &apos;./src/app.js&apos;, search: &apos;./src/search.js&apos; // ...&#125; ¶output output 指定编译后的文件如何输出到磁盘，注意，即使可以存在多个entry起点，但只能指定一个output配置。 output的值必须为一个对象，并且包含以下两个属性： filename 用于输出文件的文件名。 path 用于指定目标输出文件的绝对路径。 示例如下： 12345output: &#123; filename: &apos;bundle.js&apos;, path: path.resolve(__dirname, &apos;dist&apos;)&#125;// 此配置将生成一个单独的 bundle.js 文件输出到项目的 /dist 目录中。 以上示例是针对单入口的配置。如果是多入口，可以使用占位符[name]来确保每个文件具有唯一的名称。 123456789entry: &#123; app: &apos;./src/app.js&apos;, search: &apos;./src/search.js&apos;&#125;,output: &#123; filename: &apos;[name].js&apos;, path: path.resolve(__dirname, &apos;dist&apos;)&#125;// 此配置将生成两个文件 ./dist/app.js, ./dist/search.js。 ¶loaders webpack原生只支持js和json，通过loaders去支持其他文件类型，如css，并把他们转化为有效模块，并可以添加到依赖图中。 loader本身是一个函数，接受源文件为参数，返回转换后的结果。 ¶常见的loader 名称 用处 babel-loader 转换ES6/ES7等JS新特性语法 css-loader 支持.css的解析和加载 less-loader 将less转换为css ts-loader 将TS转换为JS ¶用法 123456module: &#123; rules: [ // 将需要的loader放在module对象的rules数组中 &apos;bable-loader&apos;, // 可以直接使用loader名称 &#123; test: /\.txt$/, use: &apos;raw-loader&apos; &#125;, // test - 指定匹配规则，use - 指定使用的loader名称 ]&#125; ¶plugins plugin用于bundle文件的优化，资源管理和环境变量的引入，作用于整个构建过程 ¶常见的plugin 名称 用处 cleanWebpackPlugin 清理构建目录 miniCssExtractPlugin 将CSS从bundle里提取成一个独立的css文件 htmlWebpackPlugin 创建html文件 uglifyjsWebpackPlugin 压缩js ¶用法 123plugins: [ // 将使用的plugin放到plugins数组中 new HtmlWebpackPlugin(&#123; template: &apos;./src/index.html&apos; &#125;)] ¶mode mode用于指定当前构建环境，可取值为：development / production / none 设置mode可以使用webpack的一些内置函数。 选项 描述 development 设置process.env.NODE_ENV的值为development，开启NamedChunksPlugin和NamedModulesPlugin production 设置process.env.NODE_ENV的值为production，开启FlagDependencyUsagePlugin，FlagIncludedChunksPlugin，ModuleConcatenationPlugin，NoEmitOnErrorPlugin，OccurrenceOrderPlugin，SideEffectsFlagPlugin，TerserPlugin none 不开启任何优化选项 关于path.resolve([…paths]) 将路径或路径片段处理成绝对路径。 path 从右到左依次处理，直到构造出绝对路径。 例如，指定的路径片段是：/foo、/bar、baz，则调用 path.resolve('/foo', '/bar', 'baz') 会返回 /bar/baz。 如果处理完全部 path 片段后还未产生绝对路径，则加上当前工作目录。 生成的路径会进行规范化，并且删除末尾的斜杠，除非路径是根目录。 空字符串的 path 片段会被忽略。 如果没有指定 path，则返回当前工作目录的绝对路径。 Node.js 中，__dirname总是指向被执行 js 文件的绝对路径，所以当在 /d1/d2/myscript.js 文件中写了 __dirname， 它的值就是 /d1/d2 。]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题解|28. 实现strStr()]]></title>
    <url>%2F2019%2F09%2F08%2FLeetCode%E9%A2%98%E8%A7%A3-28-%E5%AE%9E%E7%8E%B0strStr%2F</url>
    <content type="text"><![CDATA[题目链接：28. 实现strStr() 概述 给定一个haystack字符串和一个needle字符串，在haystack字符串中找出needle字符串出现的第一个位置 (从0开始)。如果不存在，则返回-1。 思路 字符串匹配，有这么几种方法：BF算法、RK算法、BM算法、KMP算法 本文使用了最简单的BF算法，击败了90.34%的JavaScript提交记录。 实现 123456789101112131415161718/** * @param &#123;string&#125; haystack * @param &#123;string&#125; needle * @return &#123;number&#125; */var strStr = function(haystack, needle) &#123; if (needle === '' || needle === haystack) &#123; return 0 &#125; const needleLen = needle.length const hayLen = haystack.length for (let i = 0; i &lt;= hayLen - needleLen; i++) &#123; if (haystack.slice(i, needleLen + i) === needle) &#123; return i &#125; &#125; return -1&#125;; 题解合集]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题解|27. 移除元素]]></title>
    <url>%2F2019%2F09%2F08%2FLeetCode%E9%A2%98%E8%A7%A3-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[题目链接：27. 移除元素 概述 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 思路 解法与LeetCode题解|26. 删除排序数组中的重复项类似。 使用双指针p1、p2，其中p1是慢指针、p2是快指针。 如果val === nums[p2]，我们就增加p2跳过这个目标值 如果val !== nums[p2]，说明已经跳过了所有目标值，所以我们需要把nums[p2]的值复制到nums[p1]中，并把p1往后移动。 直到p2 === nums.length时，算法结束。 实现 123456789101112131415/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; val * @return &#123;number&#125; */var removeElement = function(nums, val) &#123; let p1 = 0 for (let p2 = 0; p2 &lt; nums.length; p2++) &#123; if (val !== nums[p2]) &#123; nums[p1] = nums[p2] p1++ &#125; &#125; return p1&#125;; 题解合集]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题解|26. 删除排序数组中的重复项]]></title>
    <url>%2F2019%2F09%2F08%2FLeetCode%E9%A2%98%E8%A7%A3-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[题目链接：26. 删除排序数组中的重复项 概述 题目给定一个排序数组，需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 思路 使用双指针p1、p2，其中p1是慢指针、p2是快指针。 如果nums[p1] === nums[p2]，我们就增加p2跳过重复项 如果nums[p1] !== nums[p2]，说明已经跳过了所有重复项，所以我们需要把nums[p2]的值复制到nums[p1 + 1]中，并把p1往后移动。 直到p2 === nums.length时，算法结束。 因为p1指向的是不重复项的最后一个，因此，最终的数组长度就是p1 + 1。 实现 1234567891011121314151617/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var removeDuplicates = function(nums) &#123; if (nums.length &lt; 2) &#123; return nums.length &#125; let p1 = 0 for (let p2 = 0; p2 &lt; nums.length; p2++) &#123; if (nums[p1] !== nums[p2]) &#123; p1++ nums[p1] = nums[p2] &#125; &#125; return p1 + 1&#125;; 题解合集]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中的几种for循环]]></title>
    <url>%2F2019%2F09%2F03%2Fjs%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8Dfor%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[在JS刚出来的时候，想要遍历一个数组，可以像下面这样： 123for (var i = 0; i &lt; array.length; i++) &#123; conosole.log(array[i])&#125; forEach 在ES5之后，新加了一个forEach方法： 123array.forEach(function (item) &#123; console.log(item)&#125;) forEach的写法比原来的for循环简洁，但是在其内部，却不能使用break和return结束循环以及continue跳过循环，比如： 1234567[1, 2, 3].forEach(function(item)&#123; if(item === 2)&#123; return // 使用 break 及 continue 均会报错 &#125; console.log(item) // 1 3&#125;) for…in ES5中，还有一个for...in循环，其用法如下： 123for (var index in array) &#123; console.log(array[index])&#125; 但是，for...in有以下几个特点： 枚举的索引index是字符型，不能直接进行数字运算，如： 12345var sum = 0for (var index in [1, 2, 3]) &#123; sum += index&#125;console.log(sum) // '0012', 而不是 3 会将原型对象也一起枚举出来，如： 12345678910111213141516Object.prototype.objCustom = function() &#123;&#125;; Array.prototype.arrCustom = function() &#123;&#125;;var arr = [3, 5, 7];arr.foo = 'bar';for (var i in arr) &#123; console.log(i);&#125;// 输出：// 0// 1// 2// foo// arrCustom// objCustom 如果不想枚举出原型对象，可以配合使用hasOwnProperty： 12345678910111213141516Object.prototype.objCustom = function() &#123;&#125;; Array.prototype.arrCustom = function() &#123;&#125;;var arr = [3, 5, 7];arr.foo = 'bar';for (var i in arr) &#123; if (arr.hasOwnProperty(i)) &#123; console.log(i) &#125;&#125;// 输出：// 0// 1// 2// foo 循环出来的属性顺序如下：先遍历出整数属性（integer properties，按照升序），然后其他属性按照创建时候的顺序遍历出来。 整数属性满足 String(Math.trunc(Number(prop)) === prop 如 &quot;49&quot; 是整数属性，因为 String(Math.trunc(Number('49')) 的结果还是 “49”。 &quot;+49&quot; 不是整数属性，因为 String(Math.trunc(Number('+49')) 的结果是 “49”，不是 “+49”。 “1.2” 不是整数属性，因为 String(Math.trunc(Number('1.2')) 的结果是 “1”，不是 “1.2”。 比如： 12345678910var codes = &#123; "49": "Germany", "41": "Switzerland", "44": "Great Britain", "1": "USA"&#125;for(var code in codes) &#123; console.log(code) // 1, 41, 44, 49&#125; for…of 在ES6中，新加了一个for...of循环，其用法如下： 123for (var value of array) &#123; console.log(value)&#125; 与前面几种方式比较，for...of是循环数组元素最简洁的方法，避免了for...in的几个不足，同时也能够使用return、break、continue for...of能够使用的范围包括了数组、Set、Map、字符串、类数组对象（如arguments、DOM NodeList对象）、 Generator对象。 ¶数组 for...of能够直接使用在数组上，其遍历得到的是键值，而不像for...in一样得到的是键名： 123456789var arr = ['a', 'b', 'c', 'd']for (var index in arr) &#123; console.log(index) // 0 1 2 3&#125;for (var value of arr) &#123; console.log(value) // a b c d&#125; 同时，for...of只会遍历数组的数字索引的属性，而for...in会遍历所有属性： 12345678910var arr = [3, 5, 7]arr.foo = 'bar'for (var index in arr) &#123; console.log(index) // "0", "1", "2", "foo"&#125;for (var value of arr) &#123; console.log(value) // "3", "5", "7"&#125; ¶Set、Map Set、Map在使用for...of进行遍历的时候，顺序是按照各个成员添加到数据结构中的顺序。另外，Set 遍历时，返回的是一个值，而 Map 遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。 12345678910111213141516171819202122232425var engines = new Set(["Gecko", "Trident", "Webkit", "Webkit"])for (var e of engines) &#123; console.log(e)&#125;// Gecko// Trident// Webkitvar es6 = new Map()es6.set("edition", 6)es6.set("committee", "TC39")es6.set("standard", "ECMA-262")for (var [name, value] of es6) &#123; console.log(name + ": " + value)&#125;// edition: 6// committee: TC39// standard: ECMA-262for (var pair of es6) &#123; console.log(pair)&#125;// ['edition', 6]// ['committee', TC39]// ['standard', ECMA-262] ¶字符串 在使用for...of遍历字符串时，还能够正确的识别Unicode编码： 123456for (var chr of "😺😲") &#123; console.log(chr) // 😺, 😲&#125;for (var chr in "😺😲") &#123; console.log(chr) // '0', '1', '2', '3' &lt;--- 将2个Unicode字符识别成了4个字符&#125; ¶类数组对象 类数组对象的遍历方法也和数组一样： 12345678910111213141516// DOM NodeList对象let paras = document.querySelectorAll("p");for (let p of paras) &#123; p.classList.add("test");&#125;// arguments对象function printArgs() &#123; for (let x of arguments) &#123; console.log(x); &#125;&#125;printArgs('a', 'b');// 'a'// 'b' ¶普通对象 for...of并不能像for...in一样直接遍历普通对象： 1234567891011121314151617var es6 = &#123; edition: 6, committee: "TC39", standard: "ECMA-262"&#125;for (var e in es6) &#123; console.log(e)&#125;// edition// committee// standardfor (var e of es6) &#123; console.log(e)&#125;// TypeError: es6 is not iterable 解决方法有两种，一是使用Object.entries/Object.keys/Object.values方法由普通对象生成键值对/键名/键值数组，然后遍历这个数组： 12345678910111213141516171819202122232425var es6 = &#123; edition: 6, committee: "TC39", standard: "ECMA-262"&#125;for (var e of Object.entries(es6)) &#123; console.log(e)&#125;// ["edition", 6]// ["committee", "TC39"]// ["standard", "ECMA-262"]for (var e of Object.keys(es6)) &#123; console.log(e + ': ' + es6[e])&#125;// edition: 6// committee: TC39// standard: ECMA-262for (var e of Object.values(es6)) &#123; console.log(e)&#125;// 6// TC39// ECMA-262 另一种是使用Generator函数将对象包装一下： 123456789101112function* entries(obj) &#123; for (let key of Object.keys(obj)) &#123; yield [key, obj[key]]; &#125;&#125;for (let [key, value] of entries(obj)) &#123; console.log(key, '-&gt;', value);&#125;// a -&gt; 1// b -&gt; 2// c -&gt; 3 参考 ES6 In Depth: Iterators and the for-of loop Iterator 和 for…of 循环 http://javascript.info/object#the-for-in-loop]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[arts-week-1]]></title>
    <url>%2F2019%2F09%2F02%2Farts-week-1%2F</url>
    <content type="text"><![CDATA[Algorithm 本周完成了LeetCode的三题简单题： # Title Solution Difficulty Tag 26 删除排序数组中的重复项 js Easy Array 27 移除元素 js Easy Array 28 实现strStr() js Easy String Review 本周看了ES6 In Depth的第一篇：Iterators and the for-of loop 本文主要对比了js中几种for循环各自的特点，着重介绍了迭代器Iterators和for...of。 只要实现了[Symbol.iterator]及next()方法的对象，都可以使用for...of进行迭代。 [Symbol.iterator]方法返回一个可迭代对象，而next()方法返回一个形如{ done: false, value: 1 }的对象。 在使用for...of循环时，首先会调用[Symbol.iterator]方法，得到一个可迭代对象，然后不断执行next()方法，直到next().done === true就会停止循环。 Tip javascript中的for、for...in、for...of、while、do...while均不能使用return语句，会报错SyntaxError: Illegal return statement。 git中，可以使用git stash将代码存到暂存区中，然后就可以放心的切换到其他分支了。使用git stash pop可以将暂存区中的代码恢复。参见：这篇文章 Share 本周看了js中的几种for循环，了解了几种循环的区别。]]></content>
      <tags>
        <tag>arts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题解|775. Global and Local Inversions]]></title>
    <url>%2F2019%2F04%2F16%2FLeetCode%E9%A2%98%E8%A7%A3-775-Global-and-Local-Inversions%2F</url>
    <content type="text"><![CDATA[题目链接：775. Global and Local Inversions 概述 题目给定一个长度为N的数组A，为[0, 1, ..., N - 1]的一种排列。全局倒置指的是 i,j 满足 0 &lt;= i &lt; j &lt; N 并且 A[i] &gt; A[j] ，局部倒置指的是i满足 0 &lt;= i &lt; N 并且 A[i] &gt; A[i+1] 。问该数组的全局倒置是否等于局部倒置。 思路 这个问题暴力求解也很好办，按照题目要求扫描下数组即可。 12345678910111213141516171819202122/** * @param &#123;number[]&#125; A * @return &#123;boolean&#125; */var isIdealPermutation = function(A) &#123; var local = 0, global = 0; for(let i = 0; i &lt; A.length - 1; i++)&#123; if(A[i] &gt; A[i + 1])&#123; local++; &#125; &#125; for(let i = 0; i &lt; A.length; i++)&#123; for(let j = i + 1; j &lt; A.length; j++)&#123; if(A[i] &gt; A[j])&#123; global++; &#125; &#125; &#125; return global === local;&#125;; 这段代码的时间复杂度为 O(n2)，只能beat 30%，有点慢。考虑下优化。 题目的两个条件可以总结为： 当0 &lt;= i &lt; i + k &lt; N 并且 A[i] &gt; A[i + k]时，则存在倒置。若k = 1，则为local，若k ≥ 1，则为global。 也就是说，如果存在k &gt; 1，使得A[i] &gt; A[i + k]成立，则 global !== local。 最原始的数组，为[0, 1, 2, ..., i-1, i, i+1, ..., N-1]，即A[i] = i。 假设存在k &gt; 1，使得A[i] &gt; A[i + k]成立， 则 A[i] != i 且 A[i] &gt; i + 1 或 A[i] &lt; i - 1，即|A[i]-i| &gt; 1。 因此，只要遍历一遍数组即可得到答案。 实现 123456789101112/** * @param &#123;number[]&#125; A * @return &#123;boolean&#125; */var isIdealPermutation = function(A) &#123; for(let i = 0; i &lt; A.length; i++)&#123; if(Math.abs(A[i] - i) &gt; 1)&#123; return false; &#125; &#125; return true;&#125;; 题解合集]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题解|988. Smallest String Starting From Leaf]]></title>
    <url>%2F2019%2F04%2F16%2FLeetCode%E9%A2%98%E8%A7%A3-988-Smallest-String-Starting-From-Leaf%2F</url>
    <content type="text"><![CDATA[题目链接：988. Smallest String Starting From Leaf 概述 题目给定一棵二叉树，每个节点值为0到25的值，分别对应a到z，求树中字典序最小的字符串。 思路 一开始想到的方法，就是去深度遍历，每个节点对应的字符串为min(左子树的字符串 + 当前节点值, 右子树的字符串 + 当前节点值)， 实现代码大致如下： 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;string&#125; */var smallestFromLeaf = function(root) &#123; var res = ""; let dfs = (node) =&gt; &#123; if(node === null)&#123; return ''; &#125; let leftStr = dfs(node.left); let rightStr = dfs(node.right); let ch = String.fromCharCode(97 + node.val); var ret = ""; if(leftStr == '' &amp;&amp; rightStr == '')&#123; ret = ch; &#125; else if(leftStr == '' || rightStr == '')&#123; ret = (leftStr != '' ? leftStr : rightStr) + ch; &#125; else&#123; ret = leftStr + ch &lt; rightStr + ch ? leftStr + ch : rightStr + ch; &#125; return ret; &#125;; return dfs(root);&#125;; 但是！这段代码只能通过66/67的测试样例， 1[25,1,null,0,0,1,null,null,null,0] 这个无法通过。 在看了评论区大神的说明后，明白了。 考虑 ab 和 abab以及节点值z，显然，ab &lt; abab，abz &gt; ababz。 本测试样例的树如下： 上述代码执行过程如下： 错误发生在第二层的节点b处。 如果只以子树的字符串为依据，由于不知道加上父亲节点之后，构成的字典序是否仍是较小的那个，所以在这边发生了错误。 想到这，也好修正了，只需要传入父亲节点的值，即可。 实现 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;string&#125; */var smallestFromLeaf = function(root) &#123; var res = ""; let dfs = (node, s) =&gt; &#123; if(node === null)&#123; return '&#123;'; // &#123; 的 ascii 码大于 z &#125; s = String.fromCharCode(97 + node.val) + s; let leftStr = dfs(node.left, s); let rightStr = dfs(node.right, s); var ret = ""; if(leftStr == '&#123;' &amp;&amp; rightStr == '&#123;')&#123; ret = s; &#125; else &#123; ret = leftStr &lt; rightStr ? leftStr : rightStr; &#125; return ret; &#125;; return dfs(root, '');&#125;; 题解合集]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题解|279. Perfect Squares]]></title>
    <url>%2F2019%2F04%2F14%2FLeetCode%E9%A2%98%E8%A7%A3-279-Perfect-Squares%2F</url>
    <content type="text"><![CDATA[题目链接：279. Perfect Squares 概述 本题目要求将一个给定的数n拆分为若干个平方数的和，求最小拆分数。 思路 这个题目可以用动态规划来做。 dp[i]代表组成i的最少平方数的个数，这个值最大就是它本身（看作都由1组成）。 而组成这个数的最小值要么就是本身，要么就是前面某一个数+一个平方数（所以看作值加上1） 所以状态转移方程为：dp[i] = min(dp[i - j * j] + 1, dp[i])（其中 j &lt; sqrt(i）) 有转移方程后代码就很好写了。 这个题目还有另外一个解法，是四平方和定理（好吧，我没听过，读者有兴趣可以自己研究下） 实现 1234567891011121314151617181920212223/** * @param &#123;number&#125; n * @return &#123;number&#125; */var numSquares = function(n) &#123; let dp = new Array(n + 1); for(let i = 0; i &lt;= n; i++)&#123; dp[i] = n; &#125; for(let i = 1; i &lt;= n; i++)&#123; let sqrt = Math.floor(Math.sqrt(i)); if(sqrt * sqrt == i)&#123; dp[i] = 1; continue; &#125; dp[i] = n; for(let j = 1; j &lt;= sqrt; j++)&#123; dp[i] = Math.min(dp[i], dp[i - j * j] + 1); &#125; &#125; return dp[n];&#125;; 题解合集]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题解|652. Find Duplicate Subtrees]]></title>
    <url>%2F2019%2F04%2F14%2FLeetCode%E9%A2%98%E8%A7%A3-652-Find-Duplicate-Subtrees%2F</url>
    <content type="text"><![CDATA[题目链接：652. Find Duplicate Subtrees 概述 本题给定一棵二叉树，要求找出所有的重复子树。 思路 对这棵树进行前序遍历，如果某一子树的前序遍历序列已经出现过，说明这棵子树是重复出现的，将其加入结果集即可。 实现 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;TreeNode[]&#125; */var findDuplicateSubtrees = function(root) &#123; let map = &#123;&#125;; let result = []; let preorder = (node) =&gt; &#123; if(node == null)&#123; return "#"; &#125; let vs = preorder(node.left) + preorder(node.right) + node.val; if(map[vs])&#123; if(map[vs] == 1)&#123; result.push(node); &#125; map[vs] += 1; &#125; else&#123; map[vs] = 1; &#125; return vs; &#125; preorder(root); return result;&#125;; 题解合集]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题解|86. Partition List]]></title>
    <url>%2F2019%2F04%2F14%2FLeetCode%E9%A2%98%E8%A7%A3-86-Partition-List%2F</url>
    <content type="text"><![CDATA[题目链接：86. Partition List 概述 这个题目给定一个单链表L以及一个整数x，使得所有小于x的节点在大于等于x的节点之前，同时要保证顺序和原链表一致。 思路 这个题目只要创建两个链表，遍历一遍原链表L，将所有节点按照要求，分别插入到两个新链表中，就完成了分隔，紧接着在将两段链表连接起来，即可得到答案。 实现 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number&#125; x * @return &#123;ListNode&#125; */var partition = function(head, x) &#123; if(head == null)&#123; return null; &#125; var smaller = p1 = new ListNode(null), larger = p2 = new ListNode(null); while(head != null)&#123; if(head.val &lt; x)&#123; smaller.next = head; smaller = smaller.next &#125; else&#123; larger.next = head; larger = larger.next; &#125; head = head.next; &#125; larger.next = null; smaller.next = p2.next; return p1.next;&#125;; 题解合集]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题解|687. Longest Univalue Path]]></title>
    <url>%2F2019%2F04%2F13%2FLeetCode%E9%A2%98%E8%A7%A3-687-Longest-Univalue-Path%2F</url>
    <content type="text"><![CDATA[题目链接：687. Longest Univalue Path 概述 给定一棵二叉树，找出树中有相同值的最长路径长度。 思路 使用DFS，找出每个节点的左右子树左右两边的最长路径值lr，如果当前节点与左(右)子树的节点值相等，则将当前节点的左(右)值定为左(右)子树lr中的最大值+1。 实现 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var longestUnivaluePath = function(root) &#123; if(root == null)&#123; return 0; &#125; var maxLength = 0; var dfs = function(node)&#123; if(node == null || (node.left == null &amp;&amp; node.right == null))&#123; return &#123; left: 0, right: 0 &#125;; &#125; const &#123; left: ll, right: lr &#125; = dfs(node.left); const &#123; left: rl, right: rr &#125; = dfs(node.right); var left = 0, right = 0; if(node.left != null &amp;&amp; node.val == node.left.val)&#123; left = Math.max(ll, lr) + 1; &#125; if(node.right != null &amp;&amp; node.val == node.right.val)&#123; right = Math.max(rl, rr) + 1; &#125; maxLength = Math.max(maxLength, left + right); return &#123; left: left, right: right &#125;; &#125; dfs(root); return maxLength;&#125;; 题解合集]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题解|143. Reorder List]]></title>
    <url>%2F2019%2F04%2F13%2FLeetCode%E9%A2%98%E8%A7%A3-143-Reorder-List%2F</url>
    <content type="text"><![CDATA[题目链接：143. Reorder List 概述 给定一个单链表L: L0→L1→…→Ln-1→Ln，将其重排为：L0→Ln→L1→Ln-1→L2→Ln-2→…，即将L头尾交替重排序。 思路 整体四里路为：先将L一分为二，然后将后半段链表逆序，再依次插入前半段节点中。 在找链表的中间节点时，使用快慢指针就可以快速找到。 逆序时，将当前节点的后继节点进行位置交换，举例来说，给定链表l:head→b→c→d。首先，将b的后继，改为原后继c的后继d，即：head→b→d，然后将c指向b，head指向c，即：head→c→b→d 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;void&#125; Do not return anything, modify head in-place instead. */var reorderList = function(head) &#123; if(head == null || head.next == null)&#123; return; &#125; var fast = head, slow = head; // 找到中间节点 while(fast.next != null &amp;&amp; fast.next.next != null)&#123; slow = slow.next; fast = fast.next.next; &#125; var middle = slow, cur = slow.next; // 反转后半段链表 while(cur.next != null)&#123; var tmp = cur.next; cur.next = tmp.next; tmp.next = middle.next; middle.next = tmp; &#125; // 拼接 var p1 = head, p2 = slow.next; while(p1 != slow)&#123; slow.next = p2.next; p2.next = p1.next; p1.next = p2; p1 = p2.next; p2 = slow.next; &#125;&#125;; 题解合集]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题解|3. Longest Substring Without Repeating Characters]]></title>
    <url>%2F2019%2F04%2F13%2FLeetCode%E9%A2%98%E8%A7%A3-3-Longest-Substring-Without-Repeating-Characters%2F</url>
    <content type="text"><![CDATA[题目链接：3. Longest Substring Without Repeating Characters 概述 这个题目给定一个字符串s，找出其中不含有重复字符的最长子串的长度。 思路 该题目可使用 滑动窗口 来做。 具体来说，使用两个指针left、right来确定出一个子串的范围，如果s[right]已经在s[left...right-1]中出现过，则将left向右挪，反之则将right向右挪，直到right到达s结尾。 通过这样对s进行一次扫描，即可得到最长子串。 实现 123456789101112131415161718192021/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123; var maxLength = 0; var left = 0, right = 1; while(right &lt;= s.length)&#123; if(maxLength &lt; right - left)&#123; maxLength = right - left; &#125; if(s.substring(left, right).indexOf(s[right]) != -1)&#123; left++; &#125; else&#123; right++; &#125; &#125; return maxLength;&#125;; 题解合集]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题解|971. Flip Binary Tree To Match Preorder Traversal]]></title>
    <url>%2F2019%2F04%2F13%2FLeetCode%E9%A2%98%E8%A7%A3-971-Flip-Binary-Tree-To-Match-Preorder-Traversal%2F</url>
    <content type="text"><![CDATA[题目链接：971. Flip Binary Tree To Match Preorder Traversal 概述 这个题目给定了一棵有N个节点的二叉树以及一个序列v，问如何翻转最少的节点（交换左右子树），使得前序遍历结果和给定的序列一致。 思路 使用DFS前序遍历这棵树，并且使用一个指针i，记录当前节点node应该和v中的哪个值相等，DFS时，可分为以下三种情况： node === null，说明我们已经遍历完了，返回true node.val !== v[i]，说明该节点值不是预期的，返回false node.left.!== null &amp;&amp; node.left.val !== v[i]，说明左儿子存在但是其值并不是预期的，此时，我们应该翻转node节点，但是我们并不需要真的去修改指针，只要先去遍历右子树，再去遍历左子树，即可达到翻转并且前序遍历的目的。 实现 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;number[]&#125; voyage * @return &#123;number[]&#125; */var flipMatchVoyage = function(root, voyage) &#123; var result = []; var i = 0; var dfs = function(node)&#123; if(node == null)&#123; return true; &#125; if(node.val != voyage[i++])&#123; return false; &#125; if(node.left != null &amp;&amp; node.left.val != voyage[i])&#123; result.push(node.val); return dfs(node.right) &amp;&amp; dfs(node.left); &#125; return dfs(node.left) &amp;&amp; dfs(node.right); &#125; return dfs(root) ? result : [-1];&#125;; 题解合集]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题解|1017. Convert to Base -2]]></title>
    <url>%2F2019%2F04%2F13%2FLeetCode%E9%A2%98%E8%A7%A3-1017-Convert-to-Base-2%2F</url>
    <content type="text"><![CDATA[题目链接：1017. Convert to Base -2 概述 这个题目要求很简单，就是实现一个十进制到负二进制的转换。 思路 在实现前，先回顾下进制转换的方法：除k取余法 以十进制下的N = 5转为二进制为例： 第一步：5整除2，商为2，余1； 第二步：2整除2，商为1，余0； 第三步：1整除2，商为0，余1； 由于到第三步时商已经等于0，故算法结束。所以，510=1012 进一步，我们可以使用位运算来取余数或做除法。 设X对Y求余，Y等于2N，公式为：X &amp; (2N - 1) 或 X&amp;(~Y)。 因此，在求余数的时候，我们只要使用N &amp; 1即可。完整的二进制转换代码如下： 12345678910111213141516/** * @param &#123;number&#125; N * @return &#123;string&#125; */var base2 = function(N) &#123; if(N == 0)&#123; return "0"; &#125; let remainders = []; while(N != 0)&#123; var x = N &amp; 1; remainders.push(x); N = N &gt;&gt; 1; &#125; return remainders.reverse().join("");&#125;; 前面举的例子都是二进制的，那负二进制呢？类似的，我们在转换为负二进制时，只需要将除数改为-2即可。 实现 12345678910111213141516/** * @param &#123;number&#125; N * @return &#123;string&#125; */var baseNeg2 = function(N) &#123; if(N == 0)&#123; return "0"; &#125; let remainders = []; while(N != 0)&#123; var x = N &amp; 1; remainders.push(x); N = -(N &gt;&gt; 1); // 注意这里多了个负号 &#125; return remainders.reverse().join("");&#125;; 题解合集]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题解|380. Insert Delete GetRandom O(1)]]></title>
    <url>%2F2019%2F04%2F13%2FLeetCode%E9%A2%98%E8%A7%A3-380-Insert-Delete-GetRandom-O-1%2F</url>
    <content type="text"><![CDATA[题目链接：380. Insert Delete GetRandom O(1) 概述 这个题目要求设计一个数据结构，使得能够在O(1)时间内完成插入、删除、随机获取。 思路 看到这个要求，很自然就想到了数组。但是单纯数组并不能满足题目中要求的如果存在值才可删除/不可插入，为此，可以引入一个Map，用于保存数组中值的位置情况。 插入时，先在map中查找下是否存在val，若存在，则按题目要求，返回false，否则在数组尾部插入该值，并且在map中记录其位置。 删除时，同样是去map中查找下是否存在val，若不存在，也是按题目要求，返回false，否则的话，将数组最后一个元素last放到val的位置上，同时更新last在map中的索引，最后将数组最后一个元素删除掉。 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Initialize your data structure here. */var RandomizedSet = function() &#123; this.set = []; this.map = &#123;&#125;;&#125;;/** * Inserts a value to the set. Returns true if the set did not already contain the specified element. * @param &#123;number&#125; val * @return &#123;boolean&#125; */RandomizedSet.prototype.insert = function(val) &#123; if(val in this.map)&#123; return false; &#125; this.set.push(val); this.map[val] = this.set.length - 1; return true;&#125;;/** * Removes a value from the set. Returns true if the set contained the specified element. * @param &#123;number&#125; val * @return &#123;boolean&#125; */RandomizedSet.prototype.remove = function(val) &#123; if(!(val in this.map))&#123; return false; &#125; let last = this.set.pop(); let index = this.map[val]; delete this.map[val]; if(val !== last)&#123; this.set[index] = last; this.map[last] = index; &#125; return true;&#125;;/** * Get a random element from the set. * @return &#123;number&#125; */RandomizedSet.prototype.getRandom = function() &#123; let rand = Math.floor(Math.random() * this.set.length); return this.set[rand]&#125;;/** * Your RandomizedSet object will be instantiated and called as such: * var obj = new RandomizedSet() * var param_1 = obj.insert(val) * var param_2 = obj.remove(val) * var param_3 = obj.getRandom() */ 题解合集]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题解集合]]></title>
    <url>%2F2019%2F04%2F13%2FLeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[每日来点LeetCode # Title Solution Difficulty Tag 380 Insert Delete GetRandom O(1) js Medium Array 1017 Convert to Base -2 js Medium Math 971 Flip Binary Tree To Match Preorder Traversal js Medium Tree 3 Longest Substring Without Repeating Characters js Medium String 143 Reorder List js Medium Linked List 687 Longest Univalue Path js Easy Tree 86 Partition List js Medium Linked List 652 Find Duplicate Subtrees js Medium Tree 279 Perfect Squares js Medium Math 988 Smallest String Starting From Leaf js Medium Tree 775 Global and Local Inversions js Medium Tree 26 删除排序数组中的重复项 js Easy Array 27 移除元素 js Easy Array 28 实现strStr() js Easy String]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CORS]]></title>
    <url>%2F2019%2F04%2F03%2Fcors%2F</url>
    <content type="text"><![CDATA[CORS是一个W3C标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）。它允许浏览器向跨域服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 本文介绍了CORS的内部机制。 简介 CORS需要浏览器和服务器同时支持。目前，主流浏览器都已基本提供对跨域资源共享的支持，移动端浏览器也几乎全部支持。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 什么情况下需要CORS？ 由XMLHttpRequest或Fetch发起的跨域 HTTP 请求。 Web 字体 (CSS 中通过@font-face使用跨域字体资源) 使用drawImage将Images/video画面绘制到canvas 例如，当你引用了某个第三方CDN上的字体文件时： 12345/* CSS */@font-face &#123; font-family: 'FontAwesome'; src: url('http://cdn.com/fonts/fontawesome.ttf') format('truetype');&#125; 如果该CDN服务商未正确设置Access-Control-Allow-Origin，那么浏览器无法加载字体资源。 两种请求 浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 若请求满足以下条件，则该请求属于简单请求： 请求方法是下列三种之一： GET POST HEAD HTTP的头信息不得包含以下几种字段之外的字段： Accept Accept-Language Content-Language Content-Type： 仅限于text/plain、multipart/form-data、application/x-www-form-urlencoded三个值 凡是不同时满足上面两个条件，就属于非简单请求。 浏览器对这两种请求的处理，是不一样的。 ¶简单请求 对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。 我们首先发起一个跨域请求： 可以看到，浏览器自动在请求头部加了一个Origin字段，同时服务器返回的状态码也为200，但是在控制台我们可以看到这样一个CORS的报错： 在服务器我们也能看到这样的记录： 这个也说明了，跨域请求可以正常发起，但是返回结果被浏览器拦截了。 我们对服务器稍加修改，给其响应头部加上如下字段： 1Access-Control-Allow-Origin: http://sender.com 此时我们再发起请求，就可以看到结果如下： 同时在控制台也没有了CORS的报错了。 总结一下，在发起一个简单请求时，浏览器如果发现这次请求是一个跨域AJAX请求时，就自动在头信息之中，添加一个Origin字段。Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段或者这个字段的值中不包含这个Origin指定的源，就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200也有可能是其他，这个取决于服务器是否有做这方面的处理。比如，服务器对请求头中的Origin进行了判断后，可能给出诸如403等返回码如下： 服务器对Origin字段判断后，返回了403，同样的请求得到了不同的响应结果（对比上图）： ¶非简单请求 对于非简单请求，浏览器并不会立即执行对应的请求代码，而是会先发送一个被称为“预检”(Preflight)的OPTION请求，用于询问要被跨域访问的服务器，是否允许当前域名下的页面发送跨域的请求。 比如，使用下面的代码发起一个请求： 12345var url = 'http://receiver.com/testNotSimpleReq.php';var xhr = new XMLHttpRequest();xhr.open('PUT', url, true);xhr.setRequestHeader('X-Custom-Header', 'value');xhr.send(); 这段代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。 浏览器发现这是一个非简单请求，就会先自动发起一个“预检”请求，要求服务器确认可以这样请求： 在请求头部中，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，&quot;预检&quot;请求的头信息包括两个特殊字段。 Access-Control-Request-Method 该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。 Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。 在“预检”请求的响应头部中，出现了三个字段： Access-Control-Allow-Origin 和前面一样，表示接受的域名 Access-Control-Allow-Methods 逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次&quot;预检&quot;请求。 Access-Control-Allow-Headers 如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在&quot;预检&quot;中请求的字段。 如果请求方法或者请求中含有的自定义头部不在响应头部的Access-Control-Allow-Methods和Access-Control-Allow-Headers中，浏览器就不会真正发起该请求，同时在控制台报错如下： 如果顺利通过“预检”的话，浏览器则会真正发起请求： Cookies与CORS 默认情况下，Cookie不包括在CORS请求之中。 如果服务器允许请求中包含Cookies，则需要在响应头部中加入字段 1Access-Control-Allow-Credentials: true 如果服务器不要浏览器发送Cookie，删除该字段或者设置为false即可。 另一方面，开发者必须在AJAX请求中打开withCredentials属性。 12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。 但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。 1xhr.withCredentials = false; 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。 同时，Cookie依然遵循同源策略，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且跨域的原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 与JSONP的比较 CORS与JSONP的使用目的相同，但是比JSONP更强大。 JSONP只支持GET请求，CORS支持所有类型的HTTP请求。 JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 参考 跨域资源共享 CORS 详解 - 阮一峰 HTTP访问控制（CORS） - MDN CORS——跨域请求那些事儿]]></content>
      <tags>
        <tag>CORS</tag>
        <tag>跨域</tag>
        <tag>同源策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器的同源策略]]></title>
    <url>%2F2019%2F03%2F24%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[浏览器的同源策略是一个用于隔离潜在恶意文件的重要安全机制，其限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。 本文介绍了同源策略的几个方面，以及如何避免。 概述 ¶什么是同源 所谓的“同源”， 指的是“三个相同”，即： 协议相同 域名相同 端口相同 举例来说，https://www.a.com/bbb/ccc.html这个网址，协议为https://，域名为www.a.com，端口为80（默认的80端口可省略）。以下几个网址与之的同源情况为： https://www.a.com/xxx/yyy.html -&gt; 同源 http://www.a.com/bbb/ccc.html -&gt; 不同源，协议不同 https://m.a.com/bbb/ccc.com -&gt; 不同源，域名不同 https://www.a.com:8080/bbb/ccc.html -&gt; 不同源，端口不同 ¶同源的目的 同源策略的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。 ¶同源的限制范围 目前，如果非同源，共有三种行为受到限制。 Cookie、LocalStorage 和 IndexDB 无法读取。 DOM 无法获得。 AJAX 请求不能发送。 以下将分别介绍如何避免这三个限制 Cookies 服务器写入浏览器的一小段信息，只有同源的网页才能共享。 但是，如果两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享 Cookie。 举例来说，A网页是https://www.a.com/bbb/ccc.html，B网页是https://m.a.com/xxx/yyy.html，那么，只要设置相同的document.domain，这两个网页就可以共享Cookies了。 12//为两个页面设置相同的 document.domaindocument.domain = 'a.com'; 现在，A网页内通过脚本设置一个Cookies 12document.cookies = "test1=hello";document.cookies = "test2=world"; B网页就可以读取到这个Cookies了 1var allCookies = document.cookies; // test1=hello;test2=world 注意：document.domain不能随意设置，只能把document.domain设置成自身或更高一级的父域。 1234// https://www.a.com/bbb/ccc.html页面下document.domain = "b.com";// Uncaught DOMException: Failed to set the 'domain' property on 'Document': 'b.com' is not a suffix of 'www.a.com'. 此外，这种方法只适用于Cookie和iframe窗口，LocalStorage和IndexDB无法通过这种方法来规避同源策略，而要使用下文介绍的PostMessage API。 另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如.a.com。 1Set-Cookie: key=value; domain=.a.com; path=/ 这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。 PS：如果两个网址，协议不同或端口不同，其Cookies可共享，即：Cookie共享跟协议、端口无关 跨域文档通信 如果两个网页不同源，就无法拿到对方的DOM，也无法进行通信。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。 比如，父窗口运行下面的命令，如果iframe窗口不是同源，就会报错。 12document.getElementById("myIFrame").contentWindow.document// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame. 上面命令中，父窗口想获取子窗口的DOM，因为跨源导致报错。 反之亦然，子窗口获取主窗口的DOM也会报错。 12window.parent.document.body// 报错 如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的document.domain属性，就可以规避同源策略，拿到DOM。 对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。 片段识别符（fragment identifier） window.name window.postMessage ¶片段识别符（fragment identifier） 片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如https://www.a.com/bbb/ccc.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。 父窗口可以把信息，写入子窗口的片段标识符。 12var src = originURL + '#' + data;document.getElementById('myIFrame').src = src; 子窗口通过监听hashchange事件得到通知。 123456window.onhashchange = checkMessage;function checkMessage() &#123; var message = window.location.hash; // ...&#125; 同样的，子窗口也可以改变父窗口的片段标识符。 1parent.location.href= target + "#" + hash; ¶window.name 浏览器窗口有window.name属性。这个属性的最大特点是，只要当前的这个浏览器tab没有关闭，无论tab内的网页如何变动，这个name值都可以保持，并且tab内的每个网页都是可以接收和设置window.name这个值的。 F5刷新多少次都可以，这是无所谓的。 中间跳转过多少个页面，这也是无所谓的。 承载过的这些页面是不是同一个域名，这都是无所谓的。 上述的tab，改成iframe同样可行。 父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入window.name属性。 12345// 在子窗口中设置其window.namewindow.name = data;// 接着，子窗口跳回一个与主窗口同域的网址。location = 'http://parent.url.com/xxx.html'; 然后，主窗口就可以读取子窗口的window.name了。 12// 主窗口中var data = document.getElementById('myFrame').contentWindow.name; 这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能。 ¶window.postMessage 在HTML5中，为了实现跨源通信，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。 这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。 其语法为： otherWindow.postMessage(message, targetOrigin, [transfer]); otherWindow 其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。 message 将要发送到其他window的数据。该参数可传入一个Object. targetOrigin 通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串*（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用postMessage传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的origin属性完全一致，来防止密码被恶意的第三方截获。如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是*。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。 transfer 可选 是一串和message同时传递的Transferable对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 举例来说，父窗口http://a.com向子窗口http://b.com发消息，调用postMessage方法就可以了。 123// 父窗口中var popup = window.open('http://b.com', 'title');popup.postMessage('Hello World!', 'http://b.com'); 子窗口向父窗口发送消息的写法类似。 12// 子窗口中window.opener.postMessage('I get!', 'http://a.com'); 父窗口和子窗口都可以通过message事件，监听对方的消息。 123window.addEventListener('message', function(event) &#123; console.log(event.data);&#125;, false); message事件的事件对象event，提供以下三个属性。 event.source：对发送消息的窗口对象的引用；可以使用此来在具有不同origin的两个窗口之间建立双向通信。 event.origin：调用postMessage时消息发送方窗口的origin。这个字符串由协议、://、域名、:端口号拼接而成。这个origin不能保证是该窗口的当前或未来origin，因为postMessage被调用后可能被导航到不同的位置。 event.data：从其他window中传递过来的消息内容对象。 子窗口可以通过event.source属性引用父窗口，然后发送消息。 12345// 子窗口中window.addEventListener('message', receiveMessage);function receiveMessage(event) &#123; event.source.postMessage('Nice to see you!', '*');&#125; event.origin属性可以过滤不是发给本窗口的消息。 123456789window.addEventListener('message', receiveMessage);function receiveMessage(event) &#123; if (event.origin !== 'http://aaa.com') return; if (event.data === 'Hello World') &#123; event.source.postMessage('Hello', event.origin); &#125; else &#123; console.log(event.data); &#125;&#125; 注意：任何窗口可以在任何其他窗口访问此方法，在任何时间，无论文档在窗口中的位置，向其发送消息。 因此，用于接收消息的任何事件监听器必须首先使用origin和source属性来检查消息的发送者的身份。无法检查origin和source属性会导致跨站点脚本攻击。 因为有了window.postMessage，读写其他窗口的LocalStorage也成为了可能。 下面是一个例子，主窗口写入iframe子窗口的localStorage。 12345678// 子窗口中window.onmessage = function(e) &#123; if (e.origin !== 'http://aaa.com') &#123; return; &#125; var payload = JSON.parse(e.data); localStorage.setItem(payload.key, JSON.stringify(payload.data));&#125;; 上面代码中，子窗口将父窗口发来的消息，写入自己的localStorage。 父窗口发送消息的代码如下 123var win = document.getElementsByTagName('iframe')[0].contentWindow;var obj = &#123; name: 'Jack' &#125;;win.postMessage(JSON.stringify(&#123;key: 'storage', data: obj&#125;), 'http://bbb.com'); 加强版的子窗口接收消息的代码如下 1234567891011121314151617window.onmessage = function(e) &#123; if (e.origin !== 'http://aaa.com') return; var payload = JSON.parse(e.data); switch (payload.method) &#123; case 'set': localStorage.setItem(payload.key, JSON.stringify(payload.data)); break; case 'get': var parent = window.parent; var data = localStorage.getItem(payload.key); parent.postMessage(data, 'http://aaa.com'); break; case 'remove': localStorage.removeItem(payload.key); break; &#125;&#125;; 加强版的父窗口发送消息代码如下 1234567891011var win = document.getElementsByTagName('iframe')[0].contentWindow;var obj = &#123; name: 'Jack' &#125;;// 存入对象win.postMessage(JSON.stringify(&#123;key: 'storage', method: 'set', data: obj&#125;), 'http://bbb.com');// 读取对象win.postMessage(JSON.stringify(&#123;key: 'storage', method: 'get'&#125;), 'http://bbb.com');window.onmessage = function(e) &#123; if (e.origin != 'http://bbb.com') return; // "Jack" console.log(JSON.parse(e.data).name);&#125;; AJAX 同源策略规定，AJAX请求只能发给同源的网址，否则就报错。 规避这个限制有以下几种方法： 使用Flash插件发送HTTP请求 架设服务器代理 JSONP WebSocket CORS ¶使用Flash插件发送HTTP请求 这种方式可以绕过浏览器的安全限制，但必须安装Flash，并且跟Flash交互。不过Flash用起来麻烦，而且现在用得也越来越少了。 ¶架设服务器代理 在同源域名下架设一个代理服务器来转发，JavaScript负责把请求发送到代理服务器： 1'/proxy?url=http://www.sina.com.cn' 代理服务器再把结果返回，这样就遵守了浏览器的同源策略。这种方式麻烦之处在于需要服务器端额外做开发。 ¶JSONP JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。 它的基本思想是，网页通过添加一个&lt;script&gt;标签，向服务器请求JSON数据，这种做法不受同源策略限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。它有个限制，只能用GET请求，并且要求返回JavaScript。（因为&lt;script&gt;标签只能使用GET加载资源） JSONP通常以函数调用的形式返回。例如，调用某一接口，返回JavaScript内容如下： 1foo(&#123;test: "hello"&#125;); 因此我们需要首先在页面中准备好回调函数： 1234function foo(data)&#123; alert(data.test); // ...&#125; 然后调用另一函数getData()触发： 12345function getPrice() &#123; var script = document.createElement('script'); script.src = 'http://api.a.com/?callback=foo'; // 注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。一般参数名由API接口确定，常用为callback。 document.body.appendChild(script);&#125; 由于&lt;script&gt;标签请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。 ¶WebSocket WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源策略，只要服务器支持，就可以通过它进行跨源通信。 下面是一个例子，浏览器发出的WebSocket请求的头信息（摘自维基百科）。 12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com 上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。 正是因为有了Origin这个字段，所以WebSocket才没有实行同源策略。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。 12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat ¶CORS CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。 Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。 详细的介绍，可以参考此文 参考 浏览器同源政策及其规避方法 - 阮一峰 浏览器的同源策略 - MDN window.postMessage - MDN window.name 跨域隐式传递消息原理解析 - 苏南大叔 AJAX - 廖雪峰]]></content>
      <tags>
        <tag>同源策略</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
