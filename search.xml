<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CORS]]></title>
    <url>%2F2019%2F04%2F03%2Fcors%2F</url>
    <content type="text"><![CDATA[CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨域服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。本文介绍了CORS的内部机制。 简介CORS需要浏览器和服务器同时支持。目前，主流浏览器都已基本提供对跨域资源共享的支持，移动端浏览器也几乎全部支持。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 什么情况下需要CORS？ 由XMLHttpRequest或Fetch发起的跨域 HTTP 请求。 Web 字体 (CSS 中通过@font-face使用跨域字体资源) 使用drawImage将Images/video画面绘制到canvas 例如，当你引用了某个第三方CDN上的字体文件时：12345/* CSS */@font-face &#123; font-family: 'FontAwesome'; src: url('http://cdn.com/fonts/fontawesome.ttf') format('truetype');&#125; 如果该CDN服务商未正确设置Access-Control-Allow-Origin，那么浏览器无法加载字体资源。 两种请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 若请求满足以下条件，则该请求属于简单请求： 请求方法是下列三种之一： GET POST HEAD HTTP的头信息不得包含以下几种字段之外的字段： Accept Accept-Language Content-Language Content-Type： 仅限于text/plain、multipart/form-data、application/x-www-form-urlencoded三个值 凡是不同时满足上面两个条件，就属于非简单请求。浏览器对这两种请求的处理，是不一样的。 简单请求对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。我们首先发起一个跨域请求： 可以看到，浏览器自动在请求头部加了一个Origin字段，同时服务器返回的状态码也为200，但是在控制台我们可以看到这样一个CORS的报错：在服务器我们也能看到这样的记录：这个也说明了，跨域请求可以正常发起，但是返回结果被浏览器拦截了。 我们对服务器稍加修改，给其响应头部加上如下字段：1Access-Control-Allow-Origin: http://sender.com 此时我们再发起请求，就可以看到结果如下：同时在控制台也没有了CORS的报错了。 总结一下，在发起一个简单请求时，浏览器如果发现这次请求是一个跨域AJAX请求时，就自动在头信息之中，添加一个Origin字段。Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段或者这个字段的值中不包含这个Origin指定的源，就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200也有可能是其他，这个取决于服务器是否有做这方面的处理。比如，服务器对请求头中的Origin进行了判断后，可能给出诸如403等返回码如下：服务器对Origin字段判断后，返回了403，同样的请求得到了不同的响应结果（对比上图）： 非简单请求对于非简单请求，浏览器并不会立即执行对应的请求代码，而是会先发送一个被称为“预检”(Preflight)的OPTION请求，用于询问要被跨域访问的服务器，是否允许当前域名下的页面发送跨域的请求。 比如，使用下面的代码发起一个请求：12345var url = 'http://receiver.com/testNotSimpleReq.php';var xhr = new XMLHttpRequest();xhr.open('PUT', url, true);xhr.setRequestHeader('X-Custom-Header', 'value');xhr.send(); 这段代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。浏览器发现这是一个非简单请求，就会先自动发起一个“预检”请求，要求服务器确认可以这样请求：在请求头部中，关键字段是Origin，表示请求来自哪个源。除了Origin字段，”预检”请求的头信息包括两个特殊字段。 Access-Control-Request-Method该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。 Access-Control-Request-Headers该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。 在“预检”请求的响应头部中，出现了三个字段： Access-Control-Allow-Origin和前面一样，表示接受的域名 Access-Control-Allow-Methods逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 Access-Control-Allow-Headers如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 如果请求方法或者请求中含有的自定义头部不在响应头部的Access-Control-Allow-Methods和Access-Control-Allow-Headers中，浏览器就不会真正发起该请求，同时在控制台报错如下： 如果顺利通过“预检”的话，浏览器则会真正发起请求： Cookies与CORS默认情况下，Cookie不包括在CORS请求之中。如果服务器允许请求中包含Cookies，则需要在响应头部中加入字段1Access-Control-Allow-Credentials: true 如果服务器不要浏览器发送Cookie，删除该字段或者设置为false即可。另一方面，开发者必须在AJAX请求中打开withCredentials属性。12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。 但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。1xhr.withCredentials = false; 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源策略，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且跨域的原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 与JSONP的比较CORS与JSONP的使用目的相同，但是比JSONP更强大。 JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 参考跨域资源共享 CORS 详解 - 阮一峰HTTP访问控制（CORS） - MDNCORS——跨域请求那些事儿]]></content>
      <tags>
        <tag>CORS</tag>
        <tag>跨域</tag>
        <tag>同源策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器的同源策略]]></title>
    <url>%2F2019%2F03%2F24%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[浏览器的同源策略是一个用于隔离潜在恶意文件的重要安全机制，其限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。本文介绍了同源策略的几个方面，以及如何避免。 概述什么是同源所谓的“同源”， 指的是“三个相同”，即： 协议相同 域名相同 端口相同 举例来说，https://www.a.com/bbb/ccc.html这个网址，协议为https://，域名为www.a.com，端口为80（默认的80端口可省略）。以下几个网址与之的同源情况为： https://www.a.com/xxx/yyy.html -&gt; 同源 http://www.a.com/bbb/ccc.html -&gt; 不同源，协议不同 https://m.a.com/bbb/ccc.com -&gt; 不同源，域名不同 https://www.a.com:8080/bbb/ccc.html -&gt; 不同源，端口不同 同源的目的同源策略的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。 同源的限制范围目前，如果非同源，共有三种行为受到限制。 Cookie、LocalStorage 和 IndexDB 无法读取。 DOM 无法获得。 AJAX 请求不能发送。 以下将分别介绍如何避免这三个限制 Cookies 服务器写入浏览器的一小段信息，只有同源的网页才能共享。 但是，如果两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享 Cookie。 举例来说，A网页是https://www.a.com/bbb/ccc.html，B网页是https://m.a.com/xxx/yyy.html，那么，只要设置相同的document.domain，这两个网页就可以共享Cookies了。12//为两个页面设置相同的 document.domaindocument.domain = 'a.com'; 现在，A网页内通过脚本设置一个Cookies12document.cookies = "test1=hello";document.cookies = "test2=world"; B网页就可以读取到这个Cookies了1var allCookies = document.cookies; // test1=hello;test2=world 注意：document.domain不能随意设置，只能把document.domain设置成自身或更高一级的父域。1234// https://www.a.com/bbb/ccc.html页面下document.domain = "b.com";// Uncaught DOMException: Failed to set the 'domain' property on 'Document': 'b.com' is not a suffix of 'www.a.com'. 此外，这种方法只适用于Cookie和iframe窗口，LocalStorage和IndexDB无法通过这种方法来规避同源策略，而要使用下文介绍的PostMessage API。 另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如.a.com。1Set-Cookie: key=value; domain=.a.com; path=/ 这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。 PS：如果两个网址，协议不同或端口不同，其Cookies可共享，即：Cookie共享跟协议、端口无关 跨域文档通信 如果两个网页不同源，就无法拿到对方的DOM，也无法进行通信。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。 比如，父窗口运行下面的命令，如果iframe窗口不是同源，就会报错。12document.getElementById("myIFrame").contentWindow.document// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame. 上面命令中，父窗口想获取子窗口的DOM，因为跨源导致报错。 反之亦然，子窗口获取主窗口的DOM也会报错。12window.parent.document.body// 报错 如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的document.domain属性，就可以规避同源策略，拿到DOM。 对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。 片段识别符（fragment identifier） window.name window.postMessage 片段识别符（fragment identifier） 片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如https://www.a.com/bbb/ccc.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。 父窗口可以把信息，写入子窗口的片段标识符。12var src = originURL + '#' + data;document.getElementById('myIFrame').src = src; 子窗口通过监听hashchange事件得到通知。123456window.onhashchange = checkMessage;function checkMessage() &#123; var message = window.location.hash; // ...&#125; 同样的，子窗口也可以改变父窗口的片段标识符。1parent.location.href= target + "#" + hash; window.name浏览器窗口有window.name属性。这个属性的最大特点是，只要当前的这个浏览器tab没有关闭，无论tab内的网页如何变动，这个name值都可以保持，并且tab内的每个网页都是可以接收和设置window.name这个值的。 F5刷新多少次都可以，这是无所谓的。 中间跳转过多少个页面，这也是无所谓的。 承载过的这些页面是不是同一个域名，这都是无所谓的。 上述的tab，改成iframe同样可行。父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入window.name属性。12345// 在子窗口中设置其window.namewindow.name = data;// 接着，子窗口跳回一个与主窗口同域的网址。location = 'http://parent.url.com/xxx.html'; 然后，主窗口就可以读取子窗口的window.name了。 12// 主窗口中var data = document.getElementById('myFrame').contentWindow.name; 这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能。 window.postMessage 在HTML5中，为了实现跨源通信，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。 其语法为： otherWindow.postMessage(message, targetOrigin, [transfer]); otherWindow其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。 message将要发送到其他window的数据。该参数可传入一个Object. targetOrigin通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串*（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用postMessage传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的origin属性完全一致，来防止密码被恶意的第三方截获。如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是*。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。 transfer 可选是一串和message同时传递的Transferable对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 举例来说，父窗口http://a.com向子窗口http://b.com发消息，调用postMessage方法就可以了。123// 父窗口中var popup = window.open('http://b.com', 'title');popup.postMessage('Hello World!', 'http://b.com'); 子窗口向父窗口发送消息的写法类似。12// 子窗口中window.opener.postMessage('I get!', 'http://a.com'); 父窗口和子窗口都可以通过message事件，监听对方的消息。123window.addEventListener('message', function(event) &#123; console.log(event.data);&#125;, false); message事件的事件对象event，提供以下三个属性。 event.source：对发送消息的窗口对象的引用；可以使用此来在具有不同origin的两个窗口之间建立双向通信。 event.origin：调用postMessage时消息发送方窗口的origin。这个字符串由协议、://、域名、:端口号拼接而成。这个origin不能保证是该窗口的当前或未来origin，因为postMessage被调用后可能被导航到不同的位置。 event.data：从其他window中传递过来的消息内容对象。 子窗口可以通过event.source属性引用父窗口，然后发送消息。12345// 子窗口中window.addEventListener('message', receiveMessage);function receiveMessage(event) &#123; event.source.postMessage('Nice to see you!', '*');&#125; event.origin属性可以过滤不是发给本窗口的消息。123456789window.addEventListener('message', receiveMessage);function receiveMessage(event) &#123; if (event.origin !== 'http://aaa.com') return; if (event.data === 'Hello World') &#123; event.source.postMessage('Hello', event.origin); &#125; else &#123; console.log(event.data); &#125;&#125; 注意：任何窗口可以在任何其他窗口访问此方法，在任何时间，无论文档在窗口中的位置，向其发送消息。 因此，用于接收消息的任何事件监听器必须首先使用origin和source属性来检查消息的发送者的身份。无法检查origin和source属性会导致跨站点脚本攻击。 因为有了window.postMessage，读写其他窗口的LocalStorage也成为了可能。 下面是一个例子，主窗口写入iframe子窗口的localStorage。12345678// 子窗口中window.onmessage = function(e) &#123; if (e.origin !== 'http://aaa.com') &#123; return; &#125; var payload = JSON.parse(e.data); localStorage.setItem(payload.key, JSON.stringify(payload.data));&#125;; 上面代码中，子窗口将父窗口发来的消息，写入自己的localStorage。 父窗口发送消息的代码如下123var win = document.getElementsByTagName('iframe')[0].contentWindow;var obj = &#123; name: 'Jack' &#125;;win.postMessage(JSON.stringify(&#123;key: 'storage', data: obj&#125;), 'http://bbb.com'); 加强版的子窗口接收消息的代码如下1234567891011121314151617window.onmessage = function(e) &#123; if (e.origin !== 'http://aaa.com') return; var payload = JSON.parse(e.data); switch (payload.method) &#123; case 'set': localStorage.setItem(payload.key, JSON.stringify(payload.data)); break; case 'get': var parent = window.parent; var data = localStorage.getItem(payload.key); parent.postMessage(data, 'http://aaa.com'); break; case 'remove': localStorage.removeItem(payload.key); break; &#125;&#125;; 加强版的父窗口发送消息代码如下1234567891011var win = document.getElementsByTagName('iframe')[0].contentWindow;var obj = &#123; name: 'Jack' &#125;;// 存入对象win.postMessage(JSON.stringify(&#123;key: 'storage', method: 'set', data: obj&#125;), 'http://bbb.com');// 读取对象win.postMessage(JSON.stringify(&#123;key: 'storage', method: 'get'&#125;), 'http://bbb.com');window.onmessage = function(e) &#123; if (e.origin != 'http://bbb.com') return; // "Jack" console.log(JSON.parse(e.data).name);&#125;; AJAX同源策略规定，AJAX请求只能发给同源的网址，否则就报错。规避这个限制有以下几种方法： 使用Flash插件发送HTTP请求 架设服务器代理 JSONP WebSocket CORS 使用Flash插件发送HTTP请求这种方式可以绕过浏览器的安全限制，但必须安装Flash，并且跟Flash交互。不过Flash用起来麻烦，而且现在用得也越来越少了。 架设服务器代理在同源域名下架设一个代理服务器来转发，JavaScript负责把请求发送到代理服务器：1'/proxy?url=http://www.sina.com.cn' 代理服务器再把结果返回，这样就遵守了浏览器的同源策略。这种方式麻烦之处在于需要服务器端额外做开发。 JSONPJSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。 它的基本思想是，网页通过添加一个&lt;script&gt;标签，向服务器请求JSON数据，这种做法不受同源策略限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。它有个限制，只能用GET请求，并且要求返回JavaScript。（因为&lt;script&gt;标签只能使用GET加载资源） JSONP通常以函数调用的形式返回。例如，调用某一接口，返回JavaScript内容如下：1foo(&#123;test: "hello"&#125;); 因此我们需要首先在页面中准备好回调函数：1234function foo(data)&#123; alert(data.test); // ...&#125; 然后调用另一函数getData()触发：12345function getPrice() &#123; var script = document.createElement('script'); script.src = 'http://api.a.com/?callback=foo'; // 注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。一般参数名由API接口确定，常用为callback。 document.body.appendChild(script);&#125; 由于&lt;script&gt;标签请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。 WebSocketWebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源策略，只要服务器支持，就可以通过它进行跨源通信。 下面是一个例子，浏览器发出的WebSocket请求的头信息（摘自维基百科）。12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com 上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。 正是因为有了Origin这个字段，所以WebSocket才没有实行同源策略。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。 12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat CORSCORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。 Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。 详细的介绍，可以参考此文 参考浏览器同源政策及其规避方法 - 阮一峰浏览器的同源策略 - MDNwindow.postMessage - MDNwindow.name 跨域隐式传递消息原理解析 - 苏南大叔AJAX - 廖雪峰]]></content>
      <tags>
        <tag>同源策略</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
