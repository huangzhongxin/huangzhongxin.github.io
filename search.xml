<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>webpack构建体积优化</title>
    <url>/2020/01/14/webpack%E6%9E%84%E5%BB%BA%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>本文介绍了几种 webpack 构建体积优化的方式。</p>
<a id="more"></a>
<h1 id="tu-pian-ya-suo">图片压缩</h1>
<blockquote>
<p><a href="https://github.com/tcoopman/image-webpack-loader" target="_blank" rel="noopener">Github - tcoopman/image-webpack-loader</a></p>
</blockquote>
<p>在 webpack 中，图片压缩使用的是 image-webpack-loader 。这个 loader 是基于 node 库 <code>imagemin</code> 实现的。</p>
<p><code>imagemin</code> 能够处理多种图片格式，能够使用第三方优化插件，如 <code>pngquant</code>、<code>tinypng</code>、<code>pngcrush</code>、<code>optiopng</code> 等。</p>
<h2 id="ya-suo-yuan-li"><a class="header-anchor" href="#压缩原理">¶</a>压缩原理</h2>
<p><code>pngquant</code>：通过将 png 图像转换为具有 alpha 通道的8位 png 格式，显著减小文件大小。<br>
<code>tinypng</code>：也是将 png 文件转化为8位 png 图片，同时剥离所有非必要的 metadata 信息。<br>
<code>pngcrush</code>：通过尝试不同的压缩级别和 png 过滤方法来降低 png idat 数据流的大小。<br>
<code>optiopng</code>：类似于 <code>pngcrush</code>，也是将 png 压缩为更小的尺寸。</p>
<h2 id="shi-yong"><a class="header-anchor" href="#使用">¶</a>使用</h2>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i image-webpack-plugin -D</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">rules: [&#123;</span><br><span class="line">  test: <span class="regexp">/\.(gif|png|jpe?g|svg)$/i</span>,</span><br><span class="line">  use: [</span><br><span class="line">    <span class="string">'file-loader'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'image-webpack-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        mozjpeg: &#123;</span><br><span class="line">          progressive: <span class="literal">true</span>,</span><br><span class="line">          quality: <span class="number">65</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// optipng.enabled: false will disable optipng</span></span><br><span class="line">        optipng: &#123;</span><br><span class="line">          enabled: <span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        pngquant: &#123;</span><br><span class="line">          quality: [<span class="number">0.65</span>, <span class="number">0.90</span>],</span><br><span class="line">          speed: <span class="number">4</span></span><br><span class="line">        &#125;,</span><br><span class="line">        gifsicle: &#123;</span><br><span class="line">          interlaced: <span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// the webp option will enable WEBP</span></span><br><span class="line">        webp: &#123;</span><br><span class="line">          quality: <span class="number">75</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>具体参数说明参见 ：<a href="https://github.com/tcoopman/image-webpack-loader#options" target="_blank" rel="noopener">Options 说明</a></p>
<h1 id="tree-shking">Tree Shking</h1>
<p>Tree Shaking 可以去除代码中无用的 js 代码，具体用法可参考<a href="/2019/12/16/webpack%E4%B8%AD%E7%9A%84TreeShaking/">之前的文章</a></p>
<h1 id="qu-chu-wu-yong-css">去除无用 CSS</h1>
<p>Tree Shaking 可删除的是无用的 js 代码，但是对于 CSS 代码却无能为力。<br>
无用的 CSS 代码，可使用 <code>PurifyCSS</code> 或 <code>uncss</code> 删除。<br>
<code>PurifyCSS</code> 通过遍历代码，识别已经用到的 CSS class，进而删除无用 CSS 代码。<br>
<code>uncss</code> 使用 jsdom 加载 HTML，并使用 PostCSS 加载样式表，然后通过 <code>document.querySelector</code> 识别出在 HTML 中没出现的选择器。</p>
<p>由于 PurifyCSS 不再维护，所以在 webpack 中可以使用插件 <a href="https://github.com/FullHuman/purgecss-webpack-plugin" target="_blank" rel="noopener"><code>purgecss-webpack-plugin</code></a> 实现删除无用 CSS 代码的目的。<br>
注意： purgecss-webpack-plugin 需要和 mini-css-extract-plugin 一同使用。</p>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i purgecss-webpack-plugin -D</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>)</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> PurgecssPlugin = <span class="built_in">require</span>(<span class="string">'purgecss-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PATHS = &#123;</span><br><span class="line">  src: path.join(__dirname, <span class="string">'src'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">"css-loader"</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">"[name].css"</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> PurgecssPlugin(&#123;</span><br><span class="line">      paths: glob.sync(<span class="string">`<span class="subst">$&#123;PATHS.src&#125;</span>/**/*`</span>,  &#123; <span class="attr">nodir</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="dong-tai-polyfill">动态 Polyfill</h1>
<blockquote>
<p>我们希望浏览器提供一些特性，但是没有，然后我们自己写一段代码来实现他，那这段代码就是 Polyfill。</p>
</blockquote>
<p>在 React 中，官方推荐使用 babel-polyfill，但是这个库存在一个问题，就是会把所有的 polyfill 都打包进去，存在体积较大的问题。</p>
<p><a href="https://polyfill.io" target="_blank" rel="noopener">Polyfill.io</a> 提供了动态 polyfill 的功能，它会根据浏览器的UA不同，返回不一样的 polyfill，达到一个按需加载的作用。</p>
<p>使用方法也很简单，在 html 文件中引入即可：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://polyfill.io/v3/polyfill.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="http://polyfill.io" target="_blank" rel="noopener">polyfill.io</a> 可以附加查询参数来定制 polyfill，具体可参照<a href="https://polyfill.io/v3/api/" target="_blank" rel="noopener">官方文档</a>。</p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack构建速度优化</title>
    <url>/2020/01/11/webpack%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>本文介绍了几种优化 webpack 构建速度的方式。</p>
<a id="more"></a>
<h1 id="duo-jin-cheng">多进程</h1>
<p>优化构建速度，可以通过多进程/多线程同时构建的方式来进行优化，目前主要有 <code>Happypack</code> / <code>thread-loader</code> / <code>parallel-webpack</code> 这几个解决方案。本文主要介绍了前两种方案。</p>
<p>优化前的构建速度：<br>
<img src="/2020/01/11/webpack构建速度优化/before.png" alt></p>
<h2 id="shi-yong-happypack"><a class="header-anchor" href="#使用-happypack">¶</a>使用 Happypack</h2>
<blockquote>
<p><a href="https://github.com/amireh/happypack" target="_blank" rel="noopener">Github - amireh/happypack</a></p>
</blockquote>
<h3 id="yuan-li"><a class="header-anchor" href="#原理">¶</a>原理</h3>
<p>happypack 会创建一个线程池，线程池会将构建任务里面的模块分配到不同线程上，各线程会去处理这个模块及其依赖。处理完成后，会将处理完成的资源传输给 happypack 的主进程，然后完成整个构建任务。参见下图：<br>
<img src="/2020/01/11/webpack构建速度优化/HappyPack_Workflow.png" alt></p>
<h3 id="an-zhuang-ji-shi-yong"><a class="header-anchor" href="#安装及使用">¶</a>安装及使用</h3>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i happypack -D</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">        use: <span class="string">'happypack/loader'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">      loaders: [<span class="string">'babel-loader'</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用后构建速度：<br>
<img src="/2020/01/11/webpack构建速度优化/happypack.png" alt><br>
可以看到，happypack 开启了三个线程进行构建，大幅度地缩减了构建时间。</p>
<h2 id="thread-loader"><a class="header-anchor" href="#thread-loader">¶</a>thread-loader</h2>
<blockquote>
<p><a href="https://github.com/webpack-contrib/thread-loader" target="_blank" rel="noopener">Github - webpack-contrib/thread-loader</a></p>
</blockquote>
<h3 id="yuan-li-1"><a class="header-anchor" href="#原理-v2">¶</a>原理</h3>
<p>thread-loader 的原理与 happypack 类似，也是创建一个线程池，线程池会将构建任务里面的模块分配到不同线程上，各线程会去处理这个模块及其依赖。处理完成后，会将处理完成的资源传输给主进程，然后完成整个构建任务。</p>
<h3 id="an-zhuang-ji-shi-yong-1"><a class="header-anchor" href="#安装及使用-v2">¶</a>安装及使用</h3>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i thread-loader -D</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'thread-loader'</span>, <span class="comment">// 默认开启 (cpu个数 - 1) 个线程</span></span><br><span class="line">          <span class="string">'babel-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用后构建速度：<br>
<img src="/2020/01/11/webpack构建速度优化/thread-loader.png" alt><br>
可以看到，thread-loader 使用后也大幅度地缩减了构建时间。</p>
<h2 id="duo-jin-cheng-bing-xing-ya-suo"><a class="header-anchor" href="#多进程并行压缩">¶</a>多进程并行压缩</h2>
<p>并行压缩代码，有两种方式：</p>
<ol>
<li>使用 parallel-uglify-plugin 插件</li>
<li>使用 terser-webpack-plugin 开启 parallel 参数</li>
</ol>
<h3 id="shi-yong-parallel-uglify-plugin-cha-jian"><a class="header-anchor" href="#使用-parallel-uglify-plugin-插件">¶</a>使用 parallel-uglify-plugin 插件</h3>
<blockquote>
<p><a href="https://github.com/gdborton/webpack-parallel-uglify-plugin" target="_blank" rel="noopener">Github - gdborton/webpack-parallel-uglify-plugin</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> ParallelUglifyPlugin = <span class="built_in">require</span>(<span class="string">'webpack-parallel-uglify-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> ParallelUglifyPlugin()</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shi-yong-terser-webpack-plugin-kai-qi-parallel-can-shu"><a class="header-anchor" href="#使用-terser-webpack-plugin-开启-parallel-参数">¶</a>使用 terser-webpack-plugin 开启 parallel 参数</h3>
<blockquote>
<p><a href="https://github.com/webpack-contrib/terser-webpack-plugin" target="_blank" rel="noopener">Github - webpack-contrib/terser-webpack-plugin</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: <span class="literal">true</span>,</span><br><span class="line">    minimizer: [</span><br><span class="line">      <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">        parallel: <span class="literal">true</span>, <span class="comment">// 布尔值或开启的线程数，默认值为 (cpu个数 - 1)</span></span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="huan-cun">缓存</h1>
<p>缓存对于首次构建并没有什么帮助，但是，可以充分利用缓存，提升二次构建的速度。<br>
开启缓存有三种方式：</p>
<ol>
<li>babel-loader 开启缓存 – bebal 转换 js 的时候的缓存</li>
<li>terser-webpack-plugin 开启缓存 – 代码压缩阶段的缓存</li>
<li>使用 hard-source-webpack-plugin – 模块转换阶段的缓存</li>
</ol>
<p>缓存的存储位置位于 <code>./node-modules/.cache</code> 。</p>
<h2 id="babel-loader-huan-cun"><a class="header-anchor" href="#babel-loader-缓存">¶</a>babel-loader 缓存</h2>
<p>设置 <code>babel-loader</code> 的 <code>cacheDirectory</code> 选项为 <code>true</code>，即可开启缓存：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        cacheDirectory: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次构建：<br>
<img src="/2020/01/11/webpack构建速度优化/babel-loader-first.png" alt><br>
第二次构建：<br>
<img src="/2020/01/11/webpack构建速度优化/babel-loader-second.png" alt></p>
<p>可以看到，开启缓存后，有小幅度优化。</p>
<h2 id="terser-webpack-plugin-huan-cun"><a class="header-anchor" href="#terser-webpack-plugin-缓存">¶</a>terser-webpack-plugin 缓存</h2>
<p>设置 <code>TerserPlugin</code> 的 <code>cache</code> 选项为 <code>true</code>，即可开启缓存：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  minimize: <span class="literal">true</span>,</span><br><span class="line">  minimizer: [</span><br><span class="line">    <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">      cache: <span class="literal">true</span>, <span class="comment">// 开启缓存</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>第一次构建：<br>
<img src="/2020/01/11/webpack构建速度优化/terser-first.png" alt><br>
第二次构建：<br>
<img src="/2020/01/11/webpack构建速度优化/terser-second.png" alt></p>
<p>可以看到，开启缓存后，优化效果明显。</p>
<h2 id="hard-source-webpack-plugin-huan-cun"><a class="header-anchor" href="#hard-source-webpack-plugin-缓存">¶</a>hard-source-webpack-plugin 缓存</h2>
<p>添加插件 <code>hard-source-webpack-plugin</code> 即可开启缓存：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">new</span> HardSourceWebpackPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>第一次构建：<br>
<img src="/2020/01/11/webpack构建速度优化/hard-source-first.png" alt><br>
第二次构建：<br>
<img src="/2020/01/11/webpack构建速度优化/hard-source-second.png" alt></p>
<p>可以看到，开启缓存后，优化效果明显。</p>
<h1 id="yu-bian-yi-zi-yuan-mo-kuai">预编译资源模块</h1>
<ol>
<li>在 <code>npm run build</code> 构建之前，先把一些基础包和业务包打包成一个文件</li>
<li>使用 <code>DllPlugin</code> 进行分包</li>
<li><code>DllPlugin</code> 把基础包打包成一个文件，然后全局暴露一个变量，需要在 html 引入进来</li>
<li><code>DllPlugin</code> 中的 <code>options[name]</code> 要和 <code>output[library]</code> 对应起来，不然会报一个引用错误</li>
<li>通过引入 <code>add-asset-html-webpack-plugin</code> 把已经打包的 js，通过 html 引入。注意不要和 <code>SpeedMeasurePlugin</code> 同时使用，会出错</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.dll.js -- 打包成 dll</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        library: [<span class="string">'react'</span>, <span class="string">'react-dom'</span>] <span class="comment">// 要打包的库</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name].dll.js'</span>,</span><br><span class="line">        path: path.join(__dirname, <span class="string">'build/library'</span>),</span><br><span class="line">        library: <span class="string">'[name]'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">            name: <span class="string">'[name]'</span>,</span><br><span class="line">            path: <span class="string">'./build/library/[name].manifest.json'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js -- 使用 dll</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> AddAssetHtmlPlugin = <span class="built_in">require</span>(<span class="string">'add-asset-html-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllReferencePlugin(&#123; <span class="comment">// 通过引用 .dll.js 中打包生成的 manifest,json 文件，来引用打包的库文件</span></span><br><span class="line">      manifest: <span class="built_in">require</span>(<span class="string">'./build/library/library.manifest.json'</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> AddAssetHtmlPlugin(&#123; <span class="comment">// 把 .dll.js 文件添加到 html 中。注意！AddAssetHtmlPlugin 必须在 HtmlWebpackPlugin 后使用</span></span><br><span class="line">      filepath: path.resolve(<span class="string">'./build/library/*.dll.js'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用前：<br>
<img src="/2020/01/11/webpack构建速度优化/dll-before.png" alt><br>
使用后：<br>
<img src="/2020/01/11/webpack构建速度优化/dll-after.png" alt><br>
<img src="/2020/01/11/webpack构建速度优化/dll-build.png" alt><br>
<img src="/2020/01/11/webpack构建速度优化/dll-html.png" alt></p>
<p>可以看到，构建体积明显小了很多。</p>
<h1 id="suo-xiao-gou-jian-mu-biao">缩小构建目标</h1>
<p>可以通过减少构建的模块，来使构建速度得到一定的优化，比如 <code>babel-loader</code> 不解析 <code>node_modules</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">        use: <span class="string">'babel-loader'</span>,</span><br><span class="line">        exclude: <span class="string">'node_modules'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="jian-shao-wen-jian-sou-suo-fan-wei">减少文件搜索范围</h1>
<p>webpack 在解析文件时，会逐层往上找，比如 <code>require('react')</code> ，会先搜索当前目录下是否存在 <code>react.js/.json</code> 等文件，没找到的话，再到 <code>node_modules</code> 及上层目录中找，较为耗时。</p>
<p>因此，可以指定搜索范围来减少这种不必要的搜索。主要有以下4点：</p>
<ol>
<li>优化 <code>resolve.modules</code> 配置：指定模块查找位置</li>
<li>优化 <code>resolve.mainFileds</code> 配置：模块入口文件字段</li>
<li>优化 <code>resolve.extensions</code> 配置：缺少扩展名时，尝试补齐的文件类型</li>
<li>使用 <code>alias</code>：模块位置</li>
</ol>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'react'</span>: path.resolve(__dirname, <span class="string">'./node_modules/react/umd/react.production.min.js'</span>),</span><br><span class="line">      <span class="string">'react-dom'</span>: path.resolve(__dirname, <span class="string">'./node_modules/react-dom/umd/react-dom.production.min.js'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    modules: [path.resolve(__dirname, <span class="string">'src'</span>), <span class="string">'node_modules'</span>],</span><br><span class="line">    extensions: [<span class="string">'.js'</span>, <span class="string">'.jsx'</span>],</span><br><span class="line">    mainFields: [<span class="string">'main'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack构建情况分析</title>
    <url>/2020/01/09/webpack%E6%9E%84%E5%BB%BA%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>本文介绍了如何分析 webpack 的构建情况，为后续的优化提供了基础。</p>
<a id="more"></a>
<h1 id="shi-yong-webpack-nei-zhi-de-stats">使用 webpack 内置的 stats</h1>
<p>启动 webpack 时使用以下带参的命令，生成一个json文件：<br>
<code>webpack --profile --json &gt; stats.json</code></p>
<p><code>--profile</code>：记录构建过程中的耗时信息<br>
<code>--json</code>：以JSON的格式输出构建结果</p>
<p>该文件的结构可参考<a href="https://webpack.docschina.org/api/stats/" target="_blank" rel="noopener">官网文档</a></p>
<p>得到<code>stats.json</code>后，可使用官方工具 <a href="http://webpack.github.io/analyse/" target="_blank" rel="noopener">Webpack Analyse</a> 对这个文件进行分析。<br>
在该工具中，能够得到类似的依赖图：<br>
<img src="/2020/01/09/webpack构建情况分析/%E4%BE%9D%E8%B5%96%E5%9B%BE.png" alt></p>
<p>由于<code>stats.json</code>的粒度较粗，比较难看出构建的问题所在。为此，我们可以使用以下两个方法，来具体分析构建的速度与体积。</p>
<h1 id="gou-jian-su-du-fen-xi">构建速度分析</h1>
<p>在 webpack 中，可以使用插件<a href="https://www.npmjs.com/package/speed-measure-webpack-plugin" target="_blank" rel="noopener"><code>speed-measure-webpack-plugin</code></a>进行构建速度分析。</p>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i speed-measure-webpack-plugin -D</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> SpeedMeasureWebpackPlugin = <span class="built_in">require</span>(<span class="string">'speed-measure-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> smp = <span class="keyword">new</span> SpeedMeasureWebpackPlugin()</span><br><span class="line"><span class="built_in">module</span>.exports = smp.wrap(&#123;</span><br><span class="line">  <span class="comment">// 原来的配置</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在导出的配置外面包裹上<code>smp.wrap</code>之后，再次运行构建，就能看到以下输出：<br>
<img src="/2020/01/09/webpack构建情况分析/smp.png" alt></p>
<p><code>SpeedMeasureWebpackPlugin</code>会将各个模块及插件的耗时情况用不同颜色标出，比如，绿色表示构建快，黄色表示构建速度一般，红色表示构建慢。</p>
<p>得到了各模块的耗时情况，就可以根据具体的情况进行优化。<br>
比如图中的<code>ExtractTextPlugin</code>耗时将近两分钟，我们就可以看下其中实现的代码，找出其中耗时的部分，fork 一份代码下来，根据自己的实际使用情况进行优化。<br>
再比如图中的<code>sass-loader</code>耗时24秒，我们就能试试如果用 less 是否能够更快一些。</p>
<h1 id="gou-jian-ti-ji-fen-xi">构建体积分析</h1>
<p>在 webpack 中，可以使用插件<a href="https://www.npmjs.com/package/webpack-bundle-analyzer" target="_blank" rel="noopener"><code>webpack-bundle-analyzer</code></a>进行构建速度分析。</p>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i webpack-bundle-analyzer -D</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; BundleAnalyzerPlugin &#125; = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ... 其他配置</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin(),</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构建之后，会自动打开<a href="http://127.0.0.1:8888/" target="_blank" rel="noopener">http://127.0.0.1:8888/</a>，显示各个模块的体积大小：<br>
<img src="/2020/01/09/webpack构建情况分析/BundleAnalyzerPlugin.png" alt></p>
<p>从图上可以看出，react占据了绝大部分的体积。所以我们在优化的时候，可以考虑将react等库抽离出来，使用CDN等方式导入，以减小体积占用。</p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中的动态import</title>
    <url>/2019/12/29/webpack%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81import/</url>
    <content><![CDATA[<p>本文介绍了 webpack 中的动态import。</p>
<a id="more"></a>
<h1 id="lan-jia-zai-jiao-ben">懒加载脚本</h1>
<p>在项目中，我们的某些代码块是在某些特殊的时候才会用到，如果我们把这些代码打包到一个 bundle 中，不仅会使 bundle 体积变大，也会让浏览器加载不必要的代码。如果使用脚本懒加载，就能够使得初始下载的代码更小，实现按需加载。</p>
<h1 id="lan-jia-zai-de-liang-chong-fang-shi">懒加载的两种方式</h1>
<p>懒加载有两种方式，分别是：</p>
<ol>
<li>Common JS: <code>require.ensure</code>（已被<code>import()</code>替代），参考：<a href="https://webpack.docschina.org/api/module-methods/#require-ensure" target="_blank" rel="noopener">webpack 模块方法 - require.ensure</a></li>
<li>ES6: 动态import</li>
</ol>
<h2 id="dong-tai-import"><a class="header-anchor" href="#动态import">¶</a>动态import</h2>
<blockquote>
<p><code>import('path/to/module') -&gt; Promise</code></p>
</blockquote>
<p>调用<code>import()</code>之处，被作为分离的模块起点，意思是，被请求的模块和它引用的所有子模块，会分离到一个单独的 chunk 中。</p>
<p>通过 webpack 构建之后，import() 会将模块抽离成为一个独立的文件，并在调用的地方，触发一个<code>jsonp</code>请求，加载这个模块。</p>
<p>调用 import()：<br>
<img src="/2019/12/29/webpack中的动态import/code-module.png" alt><br>
<img src="/2019/12/29/webpack中的动态import/code.png" alt></p>
<p>构建后的代码：<br>
<img src="/2019/12/29/webpack中的动态import/compile-code.png" alt><br>
<img src="/2019/12/29/webpack中的动态import/compile-module.png" alt></p>
<p>页面效果：<br>
<img src="/2019/12/29/webpack中的动态import/html.png" alt></p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中的Scope Hoisting</title>
    <url>/2019/12/23/webpack%E4%B8%AD%E7%9A%84ScopeHoisting/</url>
    <content><![CDATA[<p>本文介绍了 webpack 中的 Scope Hoisting。</p>
<a id="more"></a>
<h1 id="xian-xiang">现象</h1>
<p>在使用 webpack 构建后，如果查看其构建完成的 bundle 文件，会发现其中存在大量的闭包代码：<br>
源码：<br>
<img src="/2019/12/23/webpack中的ScopeHoisting/source-code.png" alt><br>
<img src="/2019/12/23/webpack中的ScopeHoisting/source-code2.png" alt><br>
构建后的代码：<br>
<img src="/2019/12/23/webpack中的ScopeHoisting/non-scope-hoisting.png" alt></p>
<p>可以看到，一个模块在经过 webpack 转换过后，会带上一层包裹，同时 <code>import</code> 会被转换成 <code>__webpack_require__</code> 调用；<code>export</code> 也会转换成调用 <code>__webpack_require__.d</code>（就是在模块上定义一个 getter 函数），并且加上注释 <code>/* harmony export (binding) */</code>。</p>
<p>由于大量的作用域包裹代码，会导致体积增大，并且模块越多越明显。同时，运行时创建的函数作用域变多，内存开销变大。</p>
<h1 id="jin-yi-bu-fen-xi">进一步分析</h1>
<p>一个构建完成的文件格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123; <span class="comment">// 入口</span></span><br><span class="line">  <span class="comment">// 用来缓存模块</span></span><br><span class="line">  <span class="keyword">var</span> installedModules = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于加载模块的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span> (<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (installedModules[moduleId]) &#123;</span><br><span class="line">      <span class="keyword">return</span> installedModules[moduleId].exports</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个新模块，并加入到缓存中</span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">module</span> = (installedModules[moduleId] = &#123;</span><br><span class="line">      i: moduleId,</span><br><span class="line">      l: <span class="literal">false</span>,</span><br><span class="line">      exports: &#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行模块初始化函数</span></span><br><span class="line">    modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将模块标记为已加载</span></span><br><span class="line">    <span class="built_in">module</span>.l = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回导出的模块</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载入口模块</span></span><br><span class="line">  <span class="keyword">return</span> __webpack_require__((__webpack_require__.s = <span class="number">0</span>))</span><br><span class="line">&#125;)([</span><br><span class="line">  <span class="comment">/* 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>可以看到，构建出来的是一个<code>IIFE</code>(匿名闭包函数)，<code>modules</code>是一个数组，每项都是一个模块初始化函数。</p>
<h1 id="scope-hoisting-yuan-li">Scope Hoisting 原理</h1>
<p>将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突。</p>
<p>可以简单的把 Scope Hoisting 理解为是把每个模块被 webpack 处理成的模块初始化函数整理到一个统一的包裹函数里，也就是把多个作用域用一个作用域取代，以减少内存消耗并减少包裹块代码，从每个模块有一个包裹函数变成只有一个包裹函数包裹所有的模块，但是有一个前提就是，当模块的引用次数<code>大于1</code>时，比如被引用了两次或以上，那么这个效果会无效，也就是被引用多次的模块在被 webpack 处理后，会被独立的包裹函数所包裹，因为如果一个模块引用次数大于1次，那么这个模块的代码会被内联多次，从而增加了打包出来的 js bundle 的体积。</p>
<h1 id="scope-hositing-shi-yong">Scope Hositing 使用</h1>
<p>在 webpack 中，设置 <code>mode: 'production'</code> 之后，就默认添加了插件<code>webpack.optimize.ModuleConcatenationPlugin()</code>，开启了 Scope Hoisting。<br>
使用前后对比：<br>
使用前：<br>
<img src="/2019/12/23/webpack中的ScopeHoisting/non-scope-hoisting.png" alt><br>
使用后：<br>
<img src="/2019/12/23/webpack中的ScopeHoisting/after-scope-hoisting.png" alt></p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中的Tree Shaking</title>
    <url>/2019/12/16/webpack%E4%B8%AD%E7%9A%84TreeShaking/</url>
    <content><![CDATA[<p>本文介绍了webpack中的Tree Shaking相关内容。</p>
<a id="more"></a>
<h1 id="shi-yao-shi-tree-shaking">什么是Tree Shaking</h1>
<p>1 个模块可能有多个方法，只要其中的某个方法使用到了，则整个文件都会被打到 <code>bundle</code> 里面去，tree shaking 就是<code>只把用到的方法</code>打入 bundle ，没用到的方法会在 <code>uglify</code> 阶段被擦除掉。</p>
<p>可以将应用想象成一棵树，其中，绿色表示实际用到的代码，是树上活的树叶；灰色表示未引用代码，是秋天树上枯萎的树叶。为了除去死去的树叶，你必须摇动这棵树，使它们落下。这就是 Tree Shaking。</p>
<h1 id="yuan-li">原理</h1>
<p>利用<code>ES6模块</code>的特点：</p>
<ol>
<li>只能作为模块顶层的语句出现</li>
<li>import 的模块名只能是字符串常量</li>
<li>import binding 是 immutable 的</li>
</ol>
<p>在分析的时候，Tree Shaking 会知道哪些代码没用到，会给这些没用到的代码加一个注释，并在 uglify 的时候进行删除。</p>
<p><strong>注意</strong>：由于使用到了<code>ES6模块</code>的特点，所以在使用<code>babel</code>的时候，需要将默认的<code>es6 模块</code>转为<code>es5 commonjs</code>禁止掉，即在<code>.babelrc</code>中，添加配置<code>modules: false</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>: [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"modules"</span>: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"@babel/preset-react"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="zen-yao-yong">怎么用</h1>
<p>webpack 默认支持，<code>production</code>模式下默认开启。</p>
<p>新建一个模块 treeshaking.js:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// treeshaking.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'func a'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">b</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'func b'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在另一模块中导入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">'/path/to/treeshaking.js'</span></span><br><span class="line"><span class="comment">// ... 余下代码中并不使用函数a</span></span><br></pre></td></tr></table></figure>
<p>开启 Tree Shaking 前：<br>
<img src="/2019/12/16/webpack中的TreeShaking/before.png" alt></p>
<p>开启 Tree Shaking 后：<br>
<img src="/2019/12/16/webpack中的TreeShaking/after.png" alt></p>
<p>在 index.js 中使用函数 a，并开启 Tree Shaking 后：<br>
<img src="/2019/12/16/webpack中的TreeShaking/use-a.png" alt></p>
<h1 id="can-kao">参考</h1>
<p><a href="https://webpack.docschina.org/guides/tree-shaking/" target="_blank" rel="noopener">Tree Shaking - WebPack中文文档</a></p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中的一些常用配置【二】</title>
    <url>/2019/12/03/webpack%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E3%80%90%E4%BA%8C%E3%80%91/</url>
    <content><![CDATA[<p>本文继续介绍几个 webpack 中常见的配置。</p>
<a id="more"></a>
<h1 id="duo-ye-mian-da-bao">多页面打包</h1>
<p>在 webpack 中，我们通过设置 <a href="/2019/11/17/webpack%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/#entry"><code>entry</code> 字段</a>来指定页面入口。同时我们也可以使用 <a href="/2019/11/26/webpack%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8E%8B%E7%BC%A9/#html"><code>html-webpack-plugin</code> 插件</a>来设置每个入口的 html 页面。</p>
<p>但是如果是像上面链接中那样，手动设置每个页面，较为麻烦，需要手动去维护这两个字段。</p>
<p>在 webpack 中，我们可以使用 <a href="https://www.npmjs.com/package/glob" target="_blank" rel="noopener"><code>glob</code></a> 读取文件，并根据指定的规则匹配到模块名，并动态设置 entry 及 html-webpack-plugin 插件的内容。</p>
<p>假设我们规定，所有页面的入口文件都为 <code>/src/模块名/index.js</code>，即 src 下的一级目录中的 index.js；同时使用的页面模板文件为 <code>/src/模块名/index.html</code> 。</p>
<p>首先，安装下 <code>glob</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i glob -D</span><br></pre></td></tr></table></figure>
<p>接着修改 webpack.config.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setMPA = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> entry = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> htmlWebpackPlugins = []</span><br><span class="line">    <span class="keyword">const</span> entryFiles = glob.sync(path.join(__dirname, <span class="string">'./src/*/index.js'</span>)) <span class="comment">// 同步获取文件</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.keys(entryFiles)</span><br><span class="line">        .map(<span class="function"><span class="params">index</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> entryFile = entryFiles[index]</span><br><span class="line">            <span class="keyword">const</span> match = entryFile.match(<span class="regexp">/src\/(.*)\/index\.js/</span>) <span class="comment">// 正则匹配模块名</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">const</span> pageName = match &amp;&amp; match[<span class="number">1</span>]</span><br><span class="line">            entry[pageName] = entryFile</span><br><span class="line">            </span><br><span class="line">            htmlWebpackPlugins.push(</span><br><span class="line">                <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">                    inlineSource: <span class="string">'.css$'</span>,</span><br><span class="line">                    template: path.join(__dirname, <span class="string">`src/<span class="subst">$&#123;pageName&#125;</span>/index.html`</span>), <span class="comment">// 设置页面模板</span></span><br><span class="line">                    filename: <span class="string">`<span class="subst">$&#123;pageName&#125;</span>.html`</span>, <span class="comment">// 输出的文件名</span></span><br><span class="line">                    chunks: [pageName], <span class="comment">// 使用到的chunk名，可以根据需要，将要用到的 js 文件名写在这</span></span><br><span class="line">                    inject: <span class="literal">true</span>,</span><br><span class="line">                    minify: &#123; <span class="comment">// 压缩 html</span></span><br><span class="line">                        html5: <span class="literal">true</span>,</span><br><span class="line">                        collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">                        preserveLineBreaks: <span class="literal">false</span>,</span><br><span class="line">                        minifyCSS: <span class="literal">true</span>,</span><br><span class="line">                        minifyJS: <span class="literal">true</span>,</span><br><span class="line">                        removeComments: <span class="literal">false</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        entry,</span><br><span class="line">        htmlWebpackPlugins</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; entry, htmlWebpackPlugins &#125; = setMPA()</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: entry,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">'[name].[chunkhash:8].js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    ].concat(htmlWebpackPlugins),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="source-map-de-shi-yong">source map 的使用</h1>
<blockquote>
<p>什么是 <code>source map</code>：参见 <a href="https://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html" target="_blank" rel="noopener">阮一峰 - JavaScript Source Map 详解</a></p>
</blockquote>
<p>source map 有五个关键字：</p>
<ol>
<li>eval: 使用 <code>eval</code> 包裹代码</li>
<li>source map: 产生 .map 文件</li>
<li>cheap: 不包含列信息</li>
<li>inline: 将 .map 作为 DataURI 嵌入，不单独产生 .map 文件</li>
<li>module: 包含 loader 的 sourcemap</li>
</ol>
<p>在 webpack 中，可以通过设置 <code>devtool</code> 字段，来设置 source map 的类型。<br>
<code>devtool</code> 字段的取值为上述五个关键字的组合，具体取值可参考<a href="https://webpack.docschina.org/configuration/devtool/" target="_blank" rel="noopener">官方文档</a>。</p>
<p>使用例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">'[name].[chunkhash:8].js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: <span class="string">'cheap-module-source- map'</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="gong-gong-zi-yuan-ti-qu">公共资源提取</h1>
<h2 id="ji-chu-ku-fen-chi"><a class="header-anchor" href="#基础库分离">¶</a>基础库分离</h2>
<p>在 React 开发时，基本上每个页面都会用到 React / ReactDOM，在每次打包的时候，构建工具就会把 React / ReactDOM 打包到 bundle 里，导致构建速度较慢，因此，可以使用 <a href="https://www.npmjs.com/package/html-webpack-externals-plugin" target="_blank" rel="noopener"><code>html-webpack-externals-plugin</code></a> 将 React / ReactDOM 基础库通过 CDN 的形式引入，而不打入 bundle 中。</p>
<p>使用方法（以 React 为例）：<br>
在webpack.config.js 中添加 html-webpack-externals-plugin 的配置。<strong>注意</strong>：html-webpack-externals-plugin 需要添加在 html-webpack-plugin 之后：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackExternalsPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-externals-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; entry, htmlWebpackPlugins &#125; = setMPA()</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: entry,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">'[name].[chunkhash:8].js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">        .concat(htmlWebpackPlugins)</span><br><span class="line">        .concat([</span><br><span class="line">            <span class="keyword">new</span> HtmlWebpackExternalsPlugin(&#123;  <span class="comment">// 添加在 htmlWebpackPlugin 之后</span></span><br><span class="line">                externals: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">module</span>: <span class="string">'react'</span>,</span><br><span class="line">                        entry: <span class="string">'https://cdn.bootcss.com/react/16.10.2/umd/react.profiling.min.js'</span>,</span><br><span class="line">                        global: <span class="string">'React'</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">module</span>: <span class="string">'react-dom'</span>,</span><br><span class="line">                        entry: <span class="string">'https://cdn.bootcss.com/react-dom/16.10.2/umd/react-dom.profiling.min.js'</span>,</span><br><span class="line">                        global: <span class="string">'ReactDOM'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;)</span><br><span class="line">        ]),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，这样子会导致页面<em>多次引入</em> React / ReactDOM，暂不知如何解决。<br>
提取前：<br>
<img src="/2019/12/03/webpack中的一些常用配置【二】/external-before-size.png" alt><br>
<img src="/2019/12/03/webpack中的一些常用配置【二】/external-before.png" alt><br>
提取后：<br>
<img src="/2019/12/03/webpack中的一些常用配置【二】/external-after-size.png" alt><br>
<img src="/2019/12/03/webpack中的一些常用配置【二】/external-after.png" alt></p>
<h2 id="shi-yong-split-chunks-plugin-jin-xing-gong-gong-jiao-ben-fen-chi"><a class="header-anchor" href="#使用-splitchunksplugin-进行公共脚本分离">¶</a>使用 SplitChunksPlugin 进行公共脚本分离</h2>
<p><code>SplitChunksPlugin</code>是 webpack4 内置的插件，替代 CommonsChunkPlugin 插件，更多介绍请参考<a href="https://webpack.js.org/plugins/split-chunks-plugin/" target="_blank" rel="noopener">官方文档</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    optimization: &#123;</span><br><span class="line">        splitChunks: &#123;</span><br><span class="line">            chunks: <span class="string">'all'</span>, <span class="comment">// async: 异步引入的库进行分离（默认）；initial: 同步引入的库进行分离；all: 所以引入的库进行分离（推荐）</span></span><br><span class="line">            minSize: <span class="number">30000</span>, <span class="comment">// 分离的公共包体积的最小大小，单位：字节</span></span><br><span class="line">            maxSize: <span class="number">0</span>,</span><br><span class="line">            minChunks: <span class="number">2</span>, <span class="comment">// 最小引用次数</span></span><br><span class="line">            maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">            maxInitialRequests: <span class="number">3</span>,</span><br><span class="line">            automaticNameDelimiter: <span class="string">'~'</span>,</span><br><span class="line">            automaticNameMaxLength: <span class="number">30</span>,</span><br><span class="line">            name: <span class="literal">true</span>,</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">                vendors: &#123;</span><br><span class="line">                    test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,  <span class="comment">// 匹配出需要分离的包</span></span><br><span class="line">                    priority: <span class="number">-10</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">default</span>: &#123;</span><br><span class="line">                    minChunks: <span class="number">2</span>,</span><br><span class="line">                    priority: <span class="number">-20</span>,</span><br><span class="line">                    reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中的一些常用配置【一】</title>
    <url>/2019/11/29/webpack%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E3%80%90%E4%B8%80%E3%80%91/</url>
    <content><![CDATA[<p>本文介绍了webpack中4个插件的使用。</p>
<a id="more"></a>
<h1 id="zi-dong-qing-li-gou-jian-mu-lu">自动清理构建目录</h1>
<p>每次webpack构建完之后，都会在输出目录生成构建好的文件。如果没有清理掉之前的构建文件的话，在多次构建之后，这个输出目录无用文件就会很多。而手动清理又比较麻烦。webpack中<a href="https://github.com/johnagan/clean-webpack-plugin" target="_blank" rel="noopener"><code>clean-webpack-plugin</code></a>可以实现每次构建前，自动删除<code>output</code>指定的目录：<br>
使用前先安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i clean-webpack-plugin -D</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exporte = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">        search: <span class="string">'./src/search.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">'[name].[chunkhash:8].js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin()</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，在clean-webpack-plugin v3的版本中，只能够使用解构的方式引入</p>
</blockquote>
<h1 id="zi-dong-bu-qi-css-3-qian-zhui">自动补齐CSS3前缀</h1>
<p>由于浏览器标准没有统一，我们需要去兼容许多问题，比如样式不一样。不同浏览器CSS样式可能需要不同的前缀，如 <code>-webkit</code>、<code>-moz</code> 等等，可以使用 <code>autoprefixer</code> 来自动补全前缀。</p>
<p><code>autoprefixer</code> 是一个后置处理器，根据的是 <a href="https://caniuse.com" target="_blank" rel="noopener">Can I Use</a> 这个网站上给出的兼容情况进行补齐前缀。<br>
<code>autoprefixer</code> 一般是与 <a href="https://github.com/postcss/postcss-loader" target="_blank" rel="noopener"><code>postcss-loader</code></a> 一起使用，所以使用前需要先安装两者：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i postcss-loader autoprefixer -D</span><br></pre></td></tr></table></figure>
<p>安装完毕之后，就可以配置下  <code>webpack.config.js</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exporte = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">        search: <span class="string">'./src/search.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">'[name].[chunkhash:8].js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">             &#123;</span><br><span class="line">                 test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">                 use: <span class="string">'babel-loader'</span></span><br><span class="line">             &#125;,</span><br><span class="line">             &#123;</span><br><span class="line">                  test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                  use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                  test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">                  use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">              &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: <span class="string">'[name].[contenthash:8].css'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后增加<code>postcss-loader</code>的配置文件<code>postcss.config.js</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// postcss.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [<span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外还需要在<code>package.json</code>或<code>.broswerlistrc</code>中增加<code>autoprefixer</code>要兼容的浏览器版本：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">browserslist: ["last 2 version", "&gt;1%"]</span><br></pre></td></tr></table></figure>
<h1 id="jing-tai-zi-yuan-nei-lian">静态资源内联</h1>
<p>静态资源内联，可以减少HTTP请求数；CSS内联也可以避免页面闪动；JS代码内联可以用于上报相关打点，以及完成页面框架的初始化工作。</p>
<p>使用<code>raw-loader</code>达到静态资源内联的目的。</p>
<h2 id="js-html-de-nei-lian"><a class="header-anchor" href="#js-html的内联">¶</a>JS/HTML的内联</h2>
<p>在 html 页面中需要内联静态资源的地方，使用<code>raw-loader</code>的语法，将静态资源引入就可以：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// html</span><br><span class="line">$&#123;require('raw-loader!/path/to/assert.html').default&#125;</span><br><span class="line">// js</span><br><span class="line">$&#123;require('raw-loader!babel-loader!/path/to/assert.js').default&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：在 <code>raw-loader v0.5.1</code> 中，<code>require</code> 后不需要加 <code>.default</code></p>
<h2 id="css-de-nei-lian"><a class="header-anchor" href="#css的内联">¶</a>CSS的内联</h2>
<p>在 <code>webpack.config.js</code> 的 module 使用 <code>style-loader</code> 插件即可。</p>
<h1 id="px-zi-dong-zhuan-huan-wei-rem">px 自动转换为 rem</h1>
<blockquote>
<p><code>rem</code>: font-size of root element<br>
-&gt; <a href="https://zhuanlan.zhihu.com/p/30413803" target="_blank" rel="noopener">Rem布局的原理解析</a></p>
</blockquote>
<p>px转换为rem，可以使用 <code>px2rem-loader</code> 插件完成。使用时，需要指定两个参数：<code>remUnit</code> - rem的单位，即 1rem = remUnit px，<code>remPrecesion</code> - 转换成 rem 后保留的小数位数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exporte = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">        search: <span class="string">'./src/search.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">'[name].[chunkhash:8].js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">             &#123;</span><br><span class="line">                 test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">                 use: <span class="string">'babel-loader'</span></span><br><span class="line">             &#125;,</span><br><span class="line">             &#123;</span><br><span class="line">                  test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                  use: [</span><br><span class="line">                      MiniCssExtractPlugin.loader,</span><br><span class="line">                      <span class="string">'css-loader'</span>,</span><br><span class="line">                      <span class="string">'less-loader'</span>,</span><br><span class="line">                      <span class="string">'postcss-loader'</span>,</span><br><span class="line">                      &#123;</span><br><span class="line">                          loader: <span class="string">'px2rem-loader'</span>,</span><br><span class="line">                          options: &#123;</span><br><span class="line">                              remUnit: <span class="number">75</span>,</span><br><span class="line">                              remPrecesion: <span class="number">8</span></span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  ]</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                  test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">                  use: [</span><br><span class="line">                      MiniCssExtractPlugin.loader,</span><br><span class="line">                      <span class="string">'css-loader'</span>,</span><br><span class="line">                      <span class="string">'less-loader'</span>,</span><br><span class="line">                      <span class="string">'postcss-loader'</span>,</span><br><span class="line">                      &#123;</span><br><span class="line">                          loader: <span class="string">'px2rem-loader'</span>,</span><br><span class="line">                          options: &#123;</span><br><span class="line">                              remUnit: <span class="number">75</span>,</span><br><span class="line">                              remPrecesion: <span class="number">8</span></span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  ]</span><br><span class="line">              &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: <span class="string">'[name].[contenthash:8].css'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，为了动态计算根节点的 <code>font-size</code>，可以在CSS中加入：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>: &#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="built_in">calc</span>(100vw/固定分辨率)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中的代码压缩</title>
    <url>/2019/11/26/webpack%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<p>本文介绍了webpack中JS、HTML、CSS进行代码压缩的方式。</p>
<a id="more"></a>
<h1 id="js">JS</h1>
<p>设置 <code>mode</code>为 <code>production</code> 配置后，webpack v4+ <code>默认</code>会压缩你的代码。生产环境下默认使用 <a href="https://webpack.docschina.org/plugins/uglifyjs-webpack-plugin/" target="_blank" rel="noopener"><code>UglifyJSPlugin</code></a>。</p>
<p>所以无需手动配置压缩选项。</p>
<h1 id="html">HTML</h1>
<p>压缩HTML可以使用插件<a href="https://webpack.docschina.org/plugins/html-webpack-plugin/" target="_blank" rel="noopener"><code>html-webpack-plugin</code></a>，并配置<a href="https://github.com/jantimon/html-webpack-plugin#options" target="_blank" rel="noopener">相关参数</a>进行使用，这里给出一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    search: <span class="string">'./src/index2.jsx'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].[chunkhash:8].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">        use: <span class="string">'babel-loader'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'file-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              name: <span class="string">'img/[name].[hash:8].[ext]'</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'[name].[contenthash:8].css'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: path.join(__dirname, <span class="string">'./src/index.html'</span>), <span class="comment">// 使用的模板</span></span><br><span class="line">      filename: <span class="string">'idnex.html'</span>, <span class="comment">// 生成的文件名</span></span><br><span class="line">      chunks: [<span class="string">'index'</span>], <span class="comment">// 生成的html使用的chunk</span></span><br><span class="line">      inject: <span class="literal">true</span>, <span class="comment">// 设置为true时，使用到的chunk，css会自动注入到html中</span></span><br><span class="line">      minify: &#123;</span><br><span class="line">        html5: <span class="literal">true</span>,</span><br><span class="line">        minifyCSS: <span class="literal">true</span>, <span class="comment">// 压缩内联CSS</span></span><br><span class="line">        minifyJS: <span class="literal">true</span>, <span class="comment">// 压缩内联JS</span></span><br><span class="line">        removeComments: <span class="literal">true</span>, <span class="comment">// 移除注释</span></span><br><span class="line">        collapseWhitespace: <span class="literal">true</span>, <span class="comment">// 删除空格、换行等空白符</span></span><br><span class="line">        preserveLineBreaks: <span class="literal">false</span>, <span class="comment">// 保留换行</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: path.join(__dirname, <span class="string">'./src/search.html'</span>), <span class="comment">// 使用的模板</span></span><br><span class="line">      filename: <span class="string">'search.html'</span>, <span class="comment">// 生成的文件名</span></span><br><span class="line">      chunks: [<span class="string">'search'</span>], <span class="comment">// 生成的html使用的chunk</span></span><br><span class="line">      inject: <span class="literal">true</span>, <span class="comment">// 设置为true时，使用到的chunk，css会自动注入到html中</span></span><br><span class="line">      minify: &#123;</span><br><span class="line">        html5: <span class="literal">true</span>,</span><br><span class="line">        minifyCSS: <span class="literal">true</span>, <span class="comment">// 压缩内联CSS</span></span><br><span class="line">        minifyJS: <span class="literal">true</span>, <span class="comment">// 压缩内联JS</span></span><br><span class="line">        removeComments: <span class="literal">true</span>, <span class="comment">// 移除注释</span></span><br><span class="line">        collapseWhitespace: <span class="literal">true</span>, <span class="comment">// 删除空格、换行等空白符</span></span><br><span class="line">        preserveLineBreaks: <span class="literal">false</span>, <span class="comment">// 保留换行</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>压缩前：<br>
<img src="/2019/11/26/webpack中的代码压缩/html-before.png" alt><br>
<img src="/2019/11/26/webpack中的代码压缩/html-before-code.png" alt><br>
压缩后：<br>
<img src="/2019/11/26/webpack中的代码压缩/html-after.png" alt><br>
<img src="/2019/11/26/webpack中的代码压缩/html-after-code.png" alt></p>
<h1 id="css">CSS</h1>
<p>压缩CSS代码，可通过<a href="https://github.com/NMFR/optimize-css-assets-webpack-plugin" target="_blank" rel="noopener"><code>optimize-css-assets-webpack-plugin</code></a>插件完成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> OptimizeCssAssetsWebpackPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    search: <span class="string">'./src/index2.jsx'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].[chunkhash:8].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">        use: <span class="string">'babel-loader'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'file-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              name: <span class="string">'img/[name].[hash:8].[ext]'</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'[name].[contenthash:8].css'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: path.join(__dirname, <span class="string">'./src/index.html'</span>), <span class="comment">// 使用的模板</span></span><br><span class="line">      filename: <span class="string">'index.html'</span>, <span class="comment">// 生成的文件名</span></span><br><span class="line">      chunks: [<span class="string">'index'</span>], <span class="comment">// 生成的html使用的chunk</span></span><br><span class="line">      inject: <span class="literal">true</span>, <span class="comment">// 设置为true时，使用到的chunk，css会自动注入到html中</span></span><br><span class="line">      minify: &#123;</span><br><span class="line">        html5: <span class="literal">true</span>,</span><br><span class="line">        minifyCSS: <span class="literal">true</span>, <span class="comment">// 压缩内联CSS</span></span><br><span class="line">        minifyJS: <span class="literal">true</span>, <span class="comment">// 压缩内联JS</span></span><br><span class="line">        removeComments: <span class="literal">true</span>, <span class="comment">// 移除注释</span></span><br><span class="line">        collapseWhitespace: <span class="literal">true</span>, <span class="comment">// 删除空格、换行等空白符</span></span><br><span class="line">        preserveLineBreaks: <span class="literal">false</span>, <span class="comment">// 保留换行</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: path.join(__dirname, <span class="string">'./src/search.html'</span>), <span class="comment">// 使用的模板</span></span><br><span class="line">      filename: <span class="string">'search.html'</span>, <span class="comment">// 生成的文件名</span></span><br><span class="line">      chunks: [<span class="string">'search'</span>], <span class="comment">// 生成的html使用的chunk</span></span><br><span class="line">      inject: <span class="literal">true</span>, <span class="comment">// 设置为true时，使用到的chunk，css会自动注入到html中</span></span><br><span class="line">      minify: &#123;</span><br><span class="line">        html5: <span class="literal">true</span>,</span><br><span class="line">        minifyCSS: <span class="literal">true</span>, <span class="comment">// 压缩内联CSS</span></span><br><span class="line">        minifyJS: <span class="literal">true</span>, <span class="comment">// 压缩内联JS</span></span><br><span class="line">        removeComments: <span class="literal">true</span>, <span class="comment">// 移除注释</span></span><br><span class="line">        collapseWhitespace: <span class="literal">true</span>, <span class="comment">// 删除空格、换行等空白符</span></span><br><span class="line">        preserveLineBreaks: <span class="literal">false</span>, <span class="comment">// 保留换行</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> OptimizeCssAssetsWebpackPlugin(&#123;</span><br><span class="line">      assetNameRegExp: <span class="regexp">/\.css$/g</span>, <span class="comment">// 需要压缩的文件名的正则表达式</span></span><br><span class="line">      cssProcessor: <span class="built_in">require</span>(<span class="string">'cssnano'</span>) <span class="comment">// 使用的压缩处理器</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>压缩前：<br>
<img src="/2019/11/26/webpack中的代码压缩/css-before.png" alt><br>
<img src="/2019/11/26/webpack中的代码压缩/css-before-code.png" alt><br>
压缩后：<br>
<img src="/2019/11/26/webpack中的代码压缩/css-after.png" alt><br>
<img src="/2019/11/26/webpack中的代码压缩/css-after-code.png" alt></p>
<h1 id="zong-jie">总结</h1>
<p>webpack中对于代码压缩还是比较简单的，只要配置一些插件就能够实现了，因此上手难度并不大。</p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中的文件指纹:hash/chunkhash/contenthash</title>
    <url>/2019/11/23/webpack%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%8C%87%E7%BA%B9-hash-chunkhash-contenthash/</url>
    <content><![CDATA[<p>本文介绍了webpack中的三种文件指纹的用法及其区别。</p>
<a id="more"></a>
<h1 id="shi-yao-shi-wen-jian-zhi-wen">什么是文件指纹</h1>
<p>所谓的文件指纹就是一个hash值（或hash值的一部分），我们可以通过文件指纹来实现前端资源的增量更新。具体而言，就是在资源名上添加一段hash值，通过浏览器的缓存策略，实现未改动的资源不重复下载。比如<a href="https://element.eleme.cn/#/zh-CN/component/quickstart" target="_blank" rel="noopener">Element UI官网</a>中，就有使用到文件指纹：<br>
<img src="/2019/11/23/webpack中的文件指纹-hash-chunkhash-contenthash/ele-demo.png" alt></p>
<h1 id="shi-yong">使用</h1>
<p>在webpack中，我们可以通过配置<code>output</code>的<code>filename</code>字段，来控制输出的文件名。因此，我们可以在这边加上<code>[hash]</code>等<a href="https://www.webpackjs.com/configuration/output/#output-filename" target="_blank" rel="noopener">占位符</a>，来实现文件指纹。<br>
例如，我们配置<code>webpack.config.js</code>内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendor: <span class="string">'./src/vendor.js'</span>,</span><br><span class="line">    index: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].[hash].js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行<code>npm run build</code>后就能得到如下输出：<br>
<img src="/2019/11/23/webpack中的文件指纹-hash-chunkhash-contenthash/build-hash-1.png" alt><br>
可以看到，输出的文件名上已经多出了一串hash值。但是，我们也可以看到，这两个文件名上的hash是一样的，也就是说，每次构建出来，每个文件都是一个新构建的，不管其是否真正改动过。这样并不符合我们的预期：只更新我们有改动的文件，而未改动的不需要用户去下载。</p>
<p>为此，我们根据不同文件，使用webpack给我们提供的不同占位符：<code>[hash]</code>、<code>[chunkhash]</code>、<code>[contenthash]</code></p>
<h2 id="hash"><a class="header-anchor" href="#hash">¶</a>[hash]</h2>
<p>hash是根据整个项目的构建求出来的，如果使用了hash，那么每个模块都会有同样的hash值，不管这个模块是不是又改动过。因此不能达到增量更新的效果。</p>
<h2 id="chunkhash"><a class="header-anchor" href="#chunkhash">¶</a>[chunkhash]</h2>
<p>chunkhash是由chunk计算的得出的hash值，chunk指的是模块，这个hash值就是模块内容计算出来的hash值。</p>
<h3 id="yong-fa"><a class="header-anchor" href="#用法">¶</a>用法</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendor: <span class="string">'./src/vendor.js'</span>,</span><br><span class="line">    index: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].[chunkhash].js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行<code>npm run build</code>后就能得到如下输出：<br>
改变前：<br>
<img src="/2019/11/23/webpack中的文件指纹-hash-chunkhash-contenthash/build-chunkhash-1.png" alt><br>
改变vendor.js后：<br>
<img src="/2019/11/23/webpack中的文件指纹-hash-chunkhash-contenthash/build-chunkhash-2.png" alt><br>
可以看到vendor的hash已经改变了，而index得没有发生改变。</p>
<p><strong>注意</strong>：为了让hash值保持稳定，还应添加<a href="https://webpack.docschina.org/plugins/named-modules-plugin/" target="_blank" rel="noopener"><code>NamedModulesPlugin</code></a>(开发环境)或<a href="https://webpack.docschina.org/plugins/hashed-module-ids-plugin/" target="_blank" rel="noopener"><code>HashedModuleIdsPlugin</code></a>(生产环境)，这两个plugin能够让webpack使用相对路径而非模块id来命名模块。</p>
<p>如果我们将js中的css抽取成单独的文件后，并且也是用chunkhash，会出现这样一个问题：仅仅改动了js文件，css也跟着一起改了，这就导致了不必要的更新。<br>
<img src="/2019/11/23/webpack中的文件指纹-hash-chunkhash-contenthash/build-chunkhash-3.png" alt></p>
<p>为此，我们在css等文件中，需要使用下面的contenthash这个占位符。</p>
<h2 id="contenthash"><a class="header-anchor" href="#contenthash">¶</a>[contenthash]</h2>
<p>contenthash用于求文件内容的hash值。这个hash值只与文件内容有关，而与chunk无关。<br>
首先，我们使用<a href="https://webpack.docschina.org/plugins/mini-css-extract-plugin/" target="_blank" rel="noopener"><code>MiniCssExtractPlugin</code></a>将js中的css抽取出来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    vendor: <span class="string">'./src/vendor.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].[chunkhash].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">        use: <span class="string">'babel-loader'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">        use: [<span class="string">'file-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'[name].[contenthash].css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，loader上，我们使用了<code>MiniCssExtractPlugin.loader</code>而不是<code>style-loader</code>，因为<code>style-loader</code>的用处是将css放到<code>&lt;style&gt;</code>标签中，与<code>MiniCssExtractPlugin.loader</code>冲突了。</p>
<p>运行<code>npm run build</code>就能看到css的hash值已经与js无关了：<br>
<img src="/2019/11/23/webpack中的文件指纹-hash-chunkhash-contenthash/build-contenthash-1.png" alt></p>
<h1 id="zui-hou">最后</h1>
<p>我们可以看到上面生成的hash都是比较长的，我们可以在占位符上指定我们要的长度，来生成我们想要的位数，如：<code>[hash:8]</code>、<code>[chunkhash:8]</code>、<code>[contenthash:8]</code><br>
<img src="/2019/11/23/webpack中的文件指纹-hash-chunkhash-contenthash/build-hash-2.png" alt></p>
<h1 id="can-kao">参考</h1>
<p><a href="https://juejin.im/post/5a1bcdadf265da430e4ee137" target="_blank" rel="noopener">webpack稳定moduleid和chunkid以实现持久化缓存的梳理</a></p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中的文件监听及热更新</title>
    <url>/2019/11/18/webpack%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E7%9B%91%E5%90%AC%E5%8F%8A%E7%83%AD%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<p>本文介绍了webpack中开启文件监听的两种方法以及热更新的原理</p>
<a id="more"></a>
<h1 id="wen-jian-jian-ting">文件监听</h1>
<p>webpack中，为了避免每次更新代码后都需要手动构建，可以开启文件监听选项。开启文件监听后，webpack会调用Node.js里面的文件读取API fs这个模块来判断文件内容是否变化，并且在文件变化的时候自动构建。<br>
开启文件监听的方法有两种：</p>
<ol>
<li>命令行</li>
<li>webpack.config.js中进行配置</li>
</ol>
<h2 id="ming-ling-xing"><a class="header-anchor" href="#命令行">¶</a>命令行</h2>
<p>在启动<code>webpack</code>命令的时候，带上<code>--watch</code>参数即可，即：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">webpack --watch</span><br></pre></td></tr></table></figure>
<h2 id="pei-zhi-wen-jian"><a class="header-anchor" href="#配置文件">¶</a>配置文件</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 是否开启文件监听，默认false，即不开启</span></span><br><span class="line">    watch: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 只有设置了 watch === true，watchOptions才有用</span></span><br><span class="line">    watchOptions: &#123;</span><br><span class="line">        <span class="comment">// 不监听的文件或文件夹，支持正则，默认为空</span></span><br><span class="line">        ignored: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        <span class="comment">// 监听到改变后的延时，默认300ms</span></span><br><span class="line">        aggregateTimeout: <span class="number">300</span>,</span><br><span class="line">        <span class="comment">// 轮询间隔，默认1000ms</span></span><br><span class="line">        poll: <span class="number">1000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="re-geng-xin">热更新</h1>
<h2 id="shi-yong"><a class="header-anchor" href="#使用">¶</a>使用</h2>
<p>热更新需要使用到插件<code>webpack-dev-server</code>(WDS)，WDS使用时需要配合插件<code>HotModuleReplacementPlugin</code>一起使用（这个插件会在配置<code>hot: true</code>自动添加，可以不手动添加）<br>
首先，先安装WDS：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i webpack-dev-server -D</span><br></pre></td></tr></table></figure>
<p>使用时，在<code>webpack.config.js</code>中配置下devServer：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: <span class="string">'./dist'</span>, <span class="comment">// WDS的基础目录</span></span><br><span class="line">        hot: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后使用命令<code>webpack-dev-server --open</code>启动即可</p>
<blockquote>
<p>–open：在构建结束后自动打开浏览器</p>
</blockquote>
<h2 id="yuan-li"><a class="header-anchor" href="#原理">¶</a>原理</h2>
<p><img src="/2019/11/18/webpack中的文件监听及热更新/%E5%8E%9F%E7%90%86.png" alt></p>
<ul>
<li>webpack compiler: 将JS构建为Bundle</li>
<li>HMR Server: 将热更新的文件输出给HMR Runtime</li>
<li>Bundle Server: 提供文件在浏览器访问</li>
<li>HMR Runtime: 被注入到bundle.js中，更新文件变化</li>
<li>bundle.js: 构建输出的文件</li>
</ul>
<p>热更新中最核心的是HMR Server和HMR Runtime：<br>
<code>HMR Server</code>是服务端，用来将变化的 js 模块通过 websocket 的消息通知给浏览器端。<br>
<code>HMR Runtime</code>是浏览器端，用于接受 HMR Server 传递的模块数据，浏览器端可以看到 .hot-update.json 的文件。</p>
<p>热更新分为两个阶段：</p>
<ol>
<li>
<p>启动阶段：<br>
启动阶段就是在文件系统中，将初始代码通过<code>Webpack Compiler</code>打包，并将打包好的代码，传输给<code>Bundle Server</code>。Bundle Server其实就是一个服务器，通过Bundle Server，浏览器就能访问到打包好的文件。这个过程即图上的 1 -&gt; 2 -&gt; A -&gt; B</p>
</li>
<li>
<p>更新阶段：<br>
如果文件系统中的代码发生了改变，代码还是会经过<code>Webpack Compiler</code>打包，打包好了会把代码发送给<code>HMR Server</code>，HMR Server中能够对比得到具体是哪些文件发生了改变。接着HMR Server就会通知<code>HMR Runtime</code>，HMR Runtime就会更新代码，最终就可以不需要刷新浏览器就看到最新的代码。即图上的 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>使用webpack解析一些常见资源</title>
    <url>/2019/11/17/%E4%BD%BF%E7%94%A8webpack%E8%A7%A3%E6%9E%90%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<p>本文介绍了如何使用webpack解析ES6、JSX、CSS等资源</p>
<a id="more"></a>
<h1 id="jie-xi-es-6">解析ES6</h1>
<p>解析es6需要使用到<code>babel</code>，同时需要使用<code>babel-loader</code><br>
首先，先配置<code>babel</code>配置文件<code>.babelrc</code>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">// .babelrc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [</span><br><span class="line">        <span class="string">"@babel/preset-env"</span>  // 增加ES6的babel preset配置</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"plugins"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>.babelrc</code>文件中的<code>plugins</code>字段，可以理解为一个plugin对应一个功能，<br>
而<code>presets</code>则是多个plugin的集合</p>
</blockquote>
<p>接着需要在<code>webpack.config.js</code>中增加相关loader的配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                use: <span class="string">'babel-loader'</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后安装相关依赖：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i @babel/core @babel/preset-env babel-loader -D</span><br></pre></td></tr></table></figure>
<p>安装完毕重新编译下即可。</p>
<h1 id="jie-xi-react-jsx">解析React JSX</h1>
<p>首先，先配置<code>babel</code>配置文件<code>.babelrc</code>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">// .babelrc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [</span><br><span class="line">        <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">        <span class="string">"@babel/preset-react"</span> // 增加react jsx的babel preset配置</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"plugins"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着在<code>webpack.config.js</code>中修改<code>babel-loader</code>的校验规则：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.jsx?$/</span>,  <span class="comment">// js、jsx文件</span></span><br><span class="line">                use: <span class="string">'babel-loader'</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后安装相关依赖：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i @babel/preset-react -D</span><br></pre></td></tr></table></figure>
<p>安装完毕即可使用react的jsx相关语法。</p>
<h1 id="jie-xi-css">解析CSS</h1>
<p>解析CSS需要用到两个loader：</p>
<ol>
<li><code>css-loader</code>加载css文件，并转换为commonJS对象</li>
<li><code>style-loader</code>将样式通过<code>&lt;style&gt;</code>标签插入到head中</li>
</ol>
<p>在<code>webpack.config.js</code>中修改loader配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，loaders链式调用，<code>从右到左</code>，所以先写style-loader，再写css-loader</p>
</blockquote>
<p>然后安装相关依赖：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i style-loader css-loader -D</span><br></pre></td></tr></table></figure>
<h1 id="jie-xi-less-sass">解析Less、Sass</h1>
<p>Less和Sass的解析步骤与CSS类似，只需要多一步将Less/Sass转换为CSS即可。<br>
配置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">                use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.s[ac]ss$/</span>, <span class="comment">// sass和scss文件</span></span><br><span class="line">                use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<code>less-loader</code>需要一同安装<code>less</code>；<code>sass-loader</code>需要一同安装<code>node-sass</code></p>
<h1 id="jie-xi-tu-pian-zi-ti-deng">解析图片、字体等</h1>
<p>解析图片、字体等文件，可使用<code>file-loader</code>或<code>url-loader</code>。<br>
<code>url-loader</code>底层也是调用的<code>file-loader</code>。<br>
在使用上，<code>url-loader</code>可以将小资源以Base64的方式编码到文件中，减少文件数，使用方法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(png|jpg|ttf)$/</span>,</span><br><span class="line">                use: [&#123;</span><br><span class="line">                    loader: <span class="string">'url-loader'</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        limit: <span class="number">10240</span> <span class="comment">// = 10KB</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack的几个核心概念</title>
    <url>/2019/11/17/webpack%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="shi-yao-shi-webpack">什么是webpack</h1>
<p><code>webpack</code>本质上是一个打包工具，它会根据代码的内容解析模块依赖，帮助我们把多个模块的代码打包。下面是<a href="https://www.webpackjs.com/" target="_blank" rel="noopener">webpack官网</a>给的一个说明图。<br>
<img src="/2019/11/17/webpack的几个核心概念/introduction.png" alt="webpack-introduction"><br>
如上图，webpack 会把项目中使用到的多个代码模块（可以是不同文件类型），打包构建成项目运行仅需要的几个静态文件（如.js、.css等）。</p>
<a id="more"></a>
<h1 id="webpack-an-zhuang">webpack 安装</h1>
<p>webpack支持使用<code>npm</code>或者<code>yarn</code>方式进行安装，当然也可以作为一个全局的命令来使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack webpack-cli -g </span><br><span class="line"></span><br><span class="line"># 或者yarn global add webpack webpack-cli</span><br></pre></td></tr></table></figure>
<h1 id="webpack-de-ji-ge-he-xin-gai-nian">webpack的几个核心概念</h1>
<p>webpack的配置文件通常为<code>webpack.config.js</code>，放置于项目的根目录中。此外，也能够使用<code>webpack --config</code>来指定使用的配置文件。<br>
一个简单的配置文件如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = requore(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>,  <span class="comment">// 指定入口文件</span></span><br><span class="line">    output: &#123;  <span class="comment">// 指定输出文件</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'/dist'</span>),</span><br><span class="line">        filename: <span class="string">'bundle.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">'development'</span>,  <span class="comment">// 指定构建环境</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: []  <span class="comment">// 配置loaders</span></span><br><span class="line">    &#125;, </span><br><span class="line">    plugins: []  <span class="comment">// 配置plugins</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="entry"><a class="header-anchor" href="#entry">¶</a>entry</h2>
<blockquote>
<p><code>entry</code> 用于指定打包入口。目前入口文件只支持<code>js</code>，其它的如<code>html</code>和<code>css</code>都不支持。</p>
</blockquote>
<p>webpack会把<code>js</code>、<code>css</code>、<code>图片</code>等等当成一个个模块，各模块间会存在一系列的依赖关系，在webpack里面，会根据<code>entry</code>指定的文件，找到依赖，<code>entry</code>文件的依赖也可能会以来其他模块，这样就会生成一棵<code>依赖树</code>。webpack会遍历这课依赖树，遍历完了才会生成打包资源。</p>
<p>entry可以指定单入口与多入口。</p>
<h3 id="dan-ru-kou"><a class="header-anchor" href="#单入口">¶</a>单入口</h3>
<p>单入口适用于单页应用，其使用一个字符串来给定入口文件的地址，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">entry: &apos;./src/index.js&apos;</span><br></pre></td></tr></table></figure>
<h3 id="duo-ru-kou"><a class="header-anchor" href="#多入口">¶</a>多入口</h3>
<p>多入口适用于多页应用，其使用一个对象来给定入口文件的地址，该对象为键值对的形式，键为入口模块的名字，值为文件地址如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    app: &apos;./src/app.js&apos;,</span><br><span class="line">    search: &apos;./src/search.js&apos;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="output"><a class="header-anchor" href="#output">¶</a>output</h2>
<blockquote>
<p><code>output</code> 指定编译后的文件如何输出到磁盘，注意，即使可以存在多个<code>entry</code>起点，但只能指定一个<code>output</code>配置。</p>
</blockquote>
<p><code>output</code>的值必须为一个对象，并且包含以下两个属性：</p>
<ol>
<li><code>filename</code> 用于输出文件的文件名。</li>
<li><code>path</code> 用于指定目标输出文件的<strong>绝对</strong>路径。</li>
</ol>
<p>示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: &apos;bundle.js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">&#125;</span><br><span class="line">// 此配置将生成一个单独的 bundle.js 文件输出到项目的 /dist 目录中。</span><br></pre></td></tr></table></figure>
<p>以上示例是针对单入口的配置。如果是多入口，可以使用<a href="https://www.webpackjs.com/configuration/output/#output-filename" target="_blank" rel="noopener">占位符</a><code>[name]</code>来确保每个文件具有唯一的名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    app: &apos;./src/app.js&apos;,</span><br><span class="line">    search: &apos;./src/search.js&apos;</span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">    filename: &apos;[name].js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">&#125;</span><br><span class="line">// 此配置将生成两个文件 ./dist/app.js, ./dist/search.js。</span><br></pre></td></tr></table></figure>
<h2 id="loaders"><a class="header-anchor" href="#loaders">¶</a>loaders</h2>
<blockquote>
<p>webpack原生只支持js和json，通过<code>loaders</code>去支持其他文件类型，如css，并把他们转化为有效模块，并可以添加到依赖图中。</p>
</blockquote>
<p><code>loader</code>本身是一个函数，接受源文件为参数，返回转换后的结果。</p>
<h3 id="chang-jian-de-loader"><a class="header-anchor" href="#常见的loader">¶</a>常见的loader</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>用处</th>
</tr>
</thead>
<tbody>
<tr>
<td>babel-loader</td>
<td>转换ES6/ES7等JS新特性语法</td>
</tr>
<tr>
<td>css-loader</td>
<td>支持.css的解析和加载</td>
</tr>
<tr>
<td>less-loader</td>
<td>将less转换为css</td>
</tr>
<tr>
<td>ts-loader</td>
<td>将TS转换为JS</td>
</tr>
</tbody>
</table>
<h3 id="yong-fa"><a class="header-anchor" href="#用法">¶</a>用法</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [ // 将需要的loader放在module对象的rules数组中</span><br><span class="line">         &apos;bable-loader&apos;, // 可以直接使用loader名称</span><br><span class="line">        &#123; test: /\.txt$/, use: &apos;raw-loader&apos; &#125;, // test - 指定匹配规则，use - 指定使用的loader名称</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="plugins"><a class="header-anchor" href="#plugins">¶</a>plugins</h2>
<blockquote>
<p><code>plugin</code>用于bundle文件的优化，资源管理和环境变量的引入，作用于整个构建过程</p>
</blockquote>
<h3 id="chang-jian-de-plugin"><a class="header-anchor" href="#常见的plugin">¶</a>常见的plugin</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>用处</th>
</tr>
</thead>
<tbody>
<tr>
<td>cleanWebpackPlugin</td>
<td>清理构建目录</td>
</tr>
<tr>
<td>miniCssExtractPlugin</td>
<td>将CSS从bundle里提取成一个独立的css文件</td>
</tr>
<tr>
<td>htmlWebpackPlugin</td>
<td>创建html文件</td>
</tr>
<tr>
<td>uglifyjsWebpackPlugin</td>
<td>压缩js</td>
</tr>
</tbody>
</table>
<h3 id="yong-fa-1"><a class="header-anchor" href="#用法-v2">¶</a>用法</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins: [ // 将使用的plugin放到plugins数组中</span><br><span class="line">    new HtmlWebpackPlugin(&#123; template: &apos;./src/index.html&apos; &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="mode"><a class="header-anchor" href="#mode">¶</a>mode</h2>
<blockquote>
<p><code>mode</code>用于指定当前构建环境，可取值为：development / production / none</p>
</blockquote>
<p>设置<code>mode</code>可以使用webpack的一些内置函数。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>development</td>
<td>设置<code>process.env.NODE_ENV</code>的值为<code>development</code>，开启<code>NamedChunksPlugin</code>和<code>NamedModulesPlugin</code></td>
</tr>
<tr>
<td>production</td>
<td>设置<code>process.env.NODE_ENV</code>的值为<code>production</code>，开启<code>FlagDependencyUsagePlugin</code>，<code>FlagIncludedChunksPlugin</code>，<code>ModuleConcatenationPlugin</code>，<code>NoEmitOnErrorPlugin</code>，<code>OccurrenceOrderPlugin</code>，<code>SideEffectsFlagPlugin</code>，<code>TerserPlugin</code></td>
</tr>
<tr>
<td>none</td>
<td>不开启任何优化选项</td>
</tr>
</tbody>
</table>
<h1 id="guan-yu-path-resolve-paths">关于path.resolve([…paths])</h1>
<blockquote>
<p>将路径或路径片段处理成绝对路径。</p>
</blockquote>
<p>path 从右到左依次处理，直到构造出绝对路径。 例如，指定的路径片段是：/foo、/bar、baz，则调用 <code>path.resolve('/foo', '/bar', 'baz')</code> 会返回 <code>/bar/baz</code>。<br>
如果处理完全部 path 片段后还未产生绝对路径，则加上当前工作目录。<br>
生成的路径会进行规范化，并且删除末尾的斜杠，除非路径是根目录。<br>
空字符串的 path 片段会被忽略。<br>
如果没有指定 path，则返回当前工作目录的绝对路径。<br>
Node.js 中，<code>__dirname</code>总是指向被执行 js 文件的绝对路径，所以当在 /d1/d2/myscript.js 文件中写了 <code>__dirname</code>， 它的值就是 /d1/d2 。</p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|28. 实现strStr()</title>
    <url>/2019/09/08/LeetCode%E9%A2%98%E8%A7%A3-28-%E5%AE%9E%E7%8E%B0strStr/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode-cn.com/problems/implement-strstr/description/" target="_blank" rel="noopener">28. 实现strStr()</a></p>
</blockquote>
<h1 id="gai-shu">概述</h1>
<p>给定一个<code>haystack</code>字符串和一个<code>needle</code>字符串，在<code>haystack</code>字符串中找出<code>needle</code>字符串出现的第一个位置 (从0开始)。如果不存在，则返回<code>-1</code>。</p>
<a id="more"></a>
<h1 id="si-lu">思路</h1>
<p>字符串匹配，有这么几种方法：<a href="https://baike.baidu.com/item/BF%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">BF算法</a>、<a href="https://blog.csdn.net/xlxxcc/article/details/64125265" target="_blank" rel="noopener">RK算法</a>、<a href="http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html" target="_blank" rel="noopener">BM算法</a>、<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">KMP算法</a></p>
<p>本文使用了最简单的BF算法，击败了90.34%的JavaScript提交记录。</p>
<h1 id="shi-xian">实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; haystack</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; needle</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> strStr = <span class="function"><span class="keyword">function</span>(<span class="params">haystack, needle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (needle === <span class="string">''</span> || needle === haystack) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> needleLen = needle.length</span><br><span class="line">    <span class="keyword">const</span> hayLen = haystack.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= hayLen - needleLen; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack.slice(i, needleLen + i) === needle) &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|27. 移除元素</title>
    <url>/2019/09/08/LeetCode%E9%A2%98%E8%A7%A3-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode-cn.com/problems/remove-element/description/" target="_blank" rel="noopener">27. 移除元素</a></p>
</blockquote>
<h1 id="gai-shu">概述</h1>
<p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p>
<a id="more"></a>
<h1 id="si-lu">思路</h1>
<p>解法与<a href="http://localhost:4000/2019/09/08/LeetCode%E9%A2%98%E8%A7%A3-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/" target="_blank" rel="noopener">LeetCode题解|26. 删除排序数组中的重复项</a>类似。</p>
<p>使用双指针<code>p1</code>、<code>p2</code>，其中<code>p1</code>是慢指针、<code>p2</code>是快指针。<br>
如果<code>val === nums[p2]</code>，我们就增加<code>p2</code>跳过这个目标值<br>
如果<code>val !== nums[p2]</code>，说明已经跳过了所有目标值，所以我们需要把<code>nums[p2]</code>的值复制到<code>nums[p1]</code>中，并把<code>p1</code>往后移动。<br>
直到<code>p2 === nums.length</code>时，算法结束。</p>
<h1 id="shi-xian">实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; val</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElement = <span class="function"><span class="keyword">function</span>(<span class="params">nums, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> p2 = <span class="number">0</span>; p2 &lt; nums.length; p2++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val !== nums[p2]) &#123;</span><br><span class="line">            nums[p1] = nums[p2]</span><br><span class="line">            p1++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|26. 删除排序数组中的重复项</title>
    <url>/2019/09/08/LeetCode%E9%A2%98%E8%A7%A3-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/description/" target="_blank" rel="noopener">26. 删除排序数组中的重复项</a></p>
</blockquote>
<h1 id="gai-shu">概述</h1>
<p>题目给定一个排序数组，需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<a id="more"></a>
<h1 id="si-lu">思路</h1>
<p>使用双指针<code>p1</code>、<code>p2</code>，其中<code>p1</code>是慢指针、<code>p2</code>是快指针。<br>
如果<code>nums[p1] === nums[p2]</code>，我们就增加<code>p2</code>跳过重复项<br>
如果<code>nums[p1] !== nums[p2]</code>，说明已经跳过了所有重复项，所以我们需要把<code>nums[p2]</code>的值复制到<code>nums[p1 + 1]</code>中，并把<code>p1</code>往后移动。<br>
直到<code>p2 === nums.length</code>时，算法结束。<br>
因为<code>p1</code>指向的是不重复项的最后一个，因此，最终的数组长度就是<code>p1 + 1</code>。</p>
<h1 id="shi-xian">实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums.length</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> p1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> p2 = <span class="number">0</span>; p2 &lt; nums.length; p2++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[p1] !== nums[p2]) &#123;</span><br><span class="line">            p1++</span><br><span class="line">            nums[p1] = nums[p2]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1 + <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>js中的几种for循环</title>
    <url>/2019/09/03/js%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8Dfor%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<p>在JS刚出来的时候，想要遍历一个数组，可以像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">  conosole.log(array[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="for-each">forEach</h1>
<p>在ES5之后，新加了一个<code>forEach</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>forEach</code>的写法比原来的<code>for</code>循环简洁，但是在其内部，却不能使用<code>break</code>和<code>return</code>结束循环以及<code>continue</code>跳过循环，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(item === <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">		<span class="comment">// 使用 break 及 continue 均会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(item) <span class="comment">// 1 3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="for-in">for…in</h1>
<p>ES5中，还有一个<code>for...in</code>循环，其用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> array) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(array[index])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，<code>for...in</code>有以下几个特点：</p>
<ol>
<li>枚举的索引<code>index</code>是字符型，不能直接进行数字运算，如：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123;</span><br><span class="line">  sum += index</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">// '0012', 而不是 3</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>会将原型对象也一起枚举出来，如：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.objCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; </span><br><span class="line"><span class="built_in">Array</span>.prototype.arrCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.foo = <span class="string">'bar'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// arrCustom</span></span><br><span class="line"><span class="comment">// objCustom</span></span><br></pre></td></tr></table></figure>
<p>如果不想枚举出原型对象，可以配合使用<code>hasOwnProperty</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.objCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; </span><br><span class="line"><span class="built_in">Array</span>.prototype.arrCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.foo = <span class="string">'bar'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.hasOwnProperty(i)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>循环出来的属性顺序如下：先遍历出整数属性（integer properties，按照升序），然后其他属性按照创建时候的顺序遍历出来。</li>
</ol>
<blockquote>
<p>整数属性满足 <code>String(Math.trunc(Number(prop)) === prop</code><br>
如<br>
&quot;49&quot; 是整数属性，因为 <code>String(Math.trunc(Number('49'))</code> 的结果还是 “49”。<br>
&quot;+49&quot; 不是整数属性，因为 <code>String(Math.trunc(Number('+49'))</code> 的结果是 “49”，不是 “+49”。<br>
“1.2” 不是整数属性，因为 <code>String(Math.trunc(Number('1.2'))</code> 的结果是 “1”，不是 “1.2”。</p>
</blockquote>
<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> codes = &#123;</span><br><span class="line">  <span class="string">"49"</span>: <span class="string">"Germany"</span>,</span><br><span class="line">  <span class="string">"41"</span>: <span class="string">"Switzerland"</span>,</span><br><span class="line">  <span class="string">"44"</span>: <span class="string">"Great Britain"</span>,</span><br><span class="line">  <span class="string">"1"</span>: <span class="string">"USA"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> code <span class="keyword">in</span> codes) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(code)  <span class="comment">// 1, 41, 44, 49</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="for-of">for…of</h1>
<p>在ES6中，新加了一个<code>for...of</code>循环，其用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> array) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与前面几种方式比较，<code>for...of</code>是循环数组元素最简洁的方法，避免了<code>for...in</code>的几个不足，同时也能够使用<code>return</code>、<code>break</code>、<code>continue</code></p>
<p><code>for...of</code>能够使用的范围包括了数组、<code>Set</code>、<code>Map</code>、字符串、类数组对象（如<code>arguments</code>、<code>DOM NodeList</code>对象）、 <code>Generator</code>对象。</p>
<h2 id="shu-zu"><a class="header-anchor" href="#数组">¶</a>数组</h2>
<p><code>for...of</code>能够直接使用在数组上，其遍历得到的是键值，而不像<code>for...in</code>一样得到的是键名：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index) <span class="comment">// 0 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value) <span class="comment">// a b c d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，<code>for...of</code>只会遍历数组的数字索引的属性，而<code>for...in</code>会遍历所有属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">arr.foo = <span class="string">'bar'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index) <span class="comment">// "0", "1", "2", "foo"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value) <span class="comment">//  "3", "5", "7"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="set-map"><a class="header-anchor" href="#set-map">¶</a>Set、Map</h2>
<p>Set、Map在使用<code>for...of</code>进行遍历的时候，顺序是<strong>按照各个成员添加到数据结构中的顺序</strong>。另外，Set 遍历时，返回的是一个值，而 Map 遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> engines = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">"Gecko"</span>, <span class="string">"Trident"</span>, <span class="string">"Webkit"</span>, <span class="string">"Webkit"</span>])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">of</span> engines) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Gecko</span></span><br><span class="line"><span class="comment">// Trident</span></span><br><span class="line"><span class="comment">// Webkit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> es6 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">es6.set(<span class="string">"edition"</span>, <span class="number">6</span>)</span><br><span class="line">es6.set(<span class="string">"committee"</span>, <span class="string">"TC39"</span>)</span><br><span class="line">es6.set(<span class="string">"standard"</span>, <span class="string">"ECMA-262"</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [name, value] <span class="keyword">of</span> es6) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name + <span class="string">": "</span> + value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// edition: 6</span></span><br><span class="line"><span class="comment">// committee: TC39</span></span><br><span class="line"><span class="comment">// standard: ECMA-262</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> pair <span class="keyword">of</span> es6) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pair)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ['edition', 6]</span></span><br><span class="line"><span class="comment">// ['committee', TC39]</span></span><br><span class="line"><span class="comment">// ['standard', ECMA-262]</span></span><br></pre></td></tr></table></figure>
<h2 id="zi-fu-chuan"><a class="header-anchor" href="#字符串">¶</a>字符串</h2>
<p>在使用<code>for...of</code>遍历字符串时，还能够正确的识别Unicode编码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> chr <span class="keyword">of</span> <span class="string">"😺😲"</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(chr) <span class="comment">// 😺, 😲</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> chr <span class="keyword">in</span> <span class="string">"😺😲"</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(chr) <span class="comment">// '0', '1', '2', '3'   &lt;--- 将2个Unicode字符识别成了4个字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lei-shu-zu-dui-xiang"><a class="header-anchor" href="#类数组对象">¶</a>类数组对象</h2>
<p>类数组对象的遍历方法也和数组一样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DOM NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> paras = <span class="built_in">document</span>.querySelectorAll(<span class="string">"p"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> paras) &#123;</span><br><span class="line">  p.classList.add(<span class="string">"test"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">printArgs(<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// 'b'</span></span><br></pre></td></tr></table></figure>
<h2 id="pu-tong-dui-xiang"><a class="header-anchor" href="#普通对象">¶</a>普通对象</h2>
<p><code>for...of</code>并不能像<code>for...in</code>一样直接遍历普通对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> es6 = &#123;</span><br><span class="line">  edition: <span class="number">6</span>,</span><br><span class="line">  committee: <span class="string">"TC39"</span>,</span><br><span class="line">  standard: <span class="string">"ECMA-262"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">in</span> es6) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// edition</span></span><br><span class="line"><span class="comment">// committee</span></span><br><span class="line"><span class="comment">// standard</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">of</span> es6) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TypeError: es6 is not iterable</span></span><br></pre></td></tr></table></figure>
<p>解决方法有两种，一是使用<code>Object.entries</code>/<code>Object.keys</code>/<code>Object.values</code>方法由普通对象生成键值对/键名/键值数组，然后遍历这个数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> es6 = &#123;</span><br><span class="line">  edition: <span class="number">6</span>,</span><br><span class="line">  committee: <span class="string">"TC39"</span>,</span><br><span class="line">  standard: <span class="string">"ECMA-262"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">of</span> <span class="built_in">Object</span>.entries(es6)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ["edition", 6]</span></span><br><span class="line"><span class="comment">// ["committee", "TC39"]</span></span><br><span class="line"><span class="comment">// ["standard", "ECMA-262"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">of</span> <span class="built_in">Object</span>.keys(es6)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e + <span class="string">': '</span> + es6[e])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// edition: 6</span></span><br><span class="line"><span class="comment">// committee: TC39</span></span><br><span class="line"><span class="comment">// standard: ECMA-262</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">of</span> <span class="built_in">Object</span>.values(es6)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// TC39</span></span><br><span class="line"><span class="comment">// ECMA-262</span></span><br></pre></td></tr></table></figure>
<p>另一种是使用<code>Generator</code>函数将对象包装一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">entries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> entries(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, <span class="string">'-&gt;'</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a -&gt; 1</span></span><br><span class="line"><span class="comment">// b -&gt; 2</span></span><br><span class="line"><span class="comment">// c -&gt; 3</span></span><br></pre></td></tr></table></figure>
<h1 id="can-kao">参考</h1>
<ol>
<li><a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/" target="_blank" rel="noopener">ES6 In Depth: Iterators and the for-of loop</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/iterator#for---of-%E5%BE%AA%E7%8E%AF" target="_blank" rel="noopener">Iterator 和 for…of 循环</a></li>
<li><a href="http://javascript.info/object#the-for-in-loop" target="_blank" rel="noopener">http://javascript.info/object#the-for-in-loop</a></li>
</ol>
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>arts-week-1</title>
    <url>/2019/09/02/arts-week-1/</url>
    <content><![CDATA[<h1 id="algorithm">Algorithm</h1>
<p>本周完成了LeetCode的三题简单题：</p>
<table>
<thead>
<tr>
<th>#</th>
<th>Title</th>
<th>Solution</th>
<th>Difficulty</th>
<th>Tag</th>
</tr>
</thead>
<tbody>
<tr>
<td>26</td>
<td><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/description/" target="_blank" rel="noopener">删除排序数组中的重复项</a></td>
<td><a href="/2019/09/08/LeetCode%E9%A2%98%E8%A7%A3-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/">js</a></td>
<td>Easy</td>
<td>Array</td>
</tr>
<tr>
<td>27</td>
<td><a href="https://leetcode-cn.com/problems/remove-element/description/" target="_blank" rel="noopener">移除元素</a></td>
<td><a href="/2019/09/08/LeetCode%E9%A2%98%E8%A7%A3-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/">js</a></td>
<td>Easy</td>
<td>Array</td>
</tr>
<tr>
<td>28</td>
<td><a href="https://leetcode-cn.com/problems/implement-strstr/description/" target="_blank" rel="noopener">实现strStr()</a></td>
<td><a href="/2019/09/08/LeetCode%E9%A2%98%E8%A7%A3-28-%E5%AE%9E%E7%8E%B0strStr/">js</a></td>
<td>Easy</td>
<td>String</td>
</tr>
</tbody>
</table>
<h1 id="review">Review</h1>
<p>本周看了ES6 In Depth的第一篇：<a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/" target="_blank" rel="noopener">Iterators and the for-of loop</a></p>
<p>本文主要对比了js中几种for循环各自的特点，着重介绍了迭代器<code>Iterators</code>和<code>for...of</code>。<br>
只要实现了<code>[Symbol.iterator]</code>及<code>next()</code>方法的对象，都可以使用<code>for...of</code>进行迭代。<br>
<code>[Symbol.iterator]</code>方法返回一个可迭代对象，而<code>next()</code>方法返回一个形如<code>{ done: false, value: 1 }</code>的对象。<br>
在使用<code>for...of</code>循环时，首先会调用<code>[Symbol.iterator]</code>方法，得到一个可迭代对象，然后不断执行<code>next()</code>方法，直到<code>next().done === true</code>就会停止循环。</p>
<h1 id="tip">Tip</h1>
<ol>
<li>javascript中的<code>for</code>、<code>for...in</code>、<code>for...of</code>、<code>while</code>、<code>do...while</code>均不能使用<code>return</code>语句，会报错<code>SyntaxError: Illegal return statement</code>。</li>
<li>git中，可以使用<code>git stash</code>将代码存到暂存区中，然后就可以放心的切换到其他分支了。使用<code>git stash pop</code>可以将暂存区中的代码恢复。参见：<a href="https://blog.csdn.net/qq_32452623/article/details/76100140" target="_blank" rel="noopener">这篇文章</a></li>
</ol>
<h1 id="share">Share</h1>
<p>本周看了<a href="/2019/09/03/js%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8Dfor%E5%BE%AA%E7%8E%AF">js中的几种for循环</a>，了解了几种循环的区别。</p>
]]></content>
      <tags>
        <tag>arts</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|775. Global and Local Inversions</title>
    <url>/2019/04/16/LeetCode%E9%A2%98%E8%A7%A3-775-Global-and-Local-Inversions/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode.com/problems/global-and-local-inversions/" target="_blank" rel="noopener">775. Global and Local Inversions</a></p>
</blockquote>
<h1 id="gai-shu">概述</h1>
<p>题目给定一个长度为<code>N</code>的数组<code>A</code>，为<code>[0, 1, ..., N - 1]</code>的一种排列。<code>全局倒置</code>指的是 <code>i,j</code> 满足 <code>0 &lt;= i &lt; j &lt; N 并且 A[i] &gt; A[j]</code> ，<code>局部倒置</code>指的是<code>i</code>满足 <code>0 &lt;= i &lt; N 并且 A[i] &gt; A[i+1]</code> 。问该数组的全局倒置是否等于局部倒置。</p>
<a id="more"></a>
<h1 id="si-lu">思路</h1>
<p>这个问题暴力求解也很好办，按照题目要求扫描下数组即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; A</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isIdealPermutation = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> local = <span class="number">0</span>,</span><br><span class="line">        global = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; A.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt; A[i + <span class="number">1</span>])&#123;</span><br><span class="line">            local++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; A.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; A.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &gt; A[j])&#123;</span><br><span class="line">                global++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> global === local;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这段代码的时间复杂度为 O(n<sup>2</sup>)，只能beat 30%，有点慢。考虑下优化。</p>
<p>题目的两个条件可以总结为：</p>
<blockquote>
<p>当<code>0 &lt;= i &lt; i + k &lt; N 并且 A[i] &gt; A[i + k]</code>时，则存在<code>倒置</code>。若<code>k = 1</code>，则为<code>local</code>，若<code>k ≥ 1</code>，则为<code>global</code>。</p>
</blockquote>
<p>也就是说，<code>如果存在k &gt; 1，使得A[i] &gt; A[i + k]成立，则 global !== local</code>。</p>
<p>最原始的数组，为<code>[0, 1, 2, ..., i-1, i, i+1, ..., N-1]</code>，即<code>A[i] = i</code>。<br>
假设<code>存在k &gt; 1，使得A[i] &gt; A[i + k]成立</code>，<br>
则 <code>A[i] != i 且 A[i] &gt; i + 1 或 A[i] &lt; i - 1</code>，即<code>|A[i]-i| &gt; 1</code>。</p>
<p>因此，只要遍历一遍数组即可得到答案。</p>
<h1 id="shi-xian">实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; A</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isIdealPermutation = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; A.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Math</span>.abs(A[i] - i) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|988. Smallest String Starting From Leaf</title>
    <url>/2019/04/16/LeetCode%E9%A2%98%E8%A7%A3-988-Smallest-String-Starting-From-Leaf/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode.com/problems/smallest-string-starting-from-leaf/" target="_blank" rel="noopener">988. Smallest String Starting From Leaf</a></p>
</blockquote>
<h1 id="gai-shu">概述</h1>
<p>题目给定一棵二叉树，每个节点值为<code>0</code>到<code>25</code>的值，分别对应<code>a</code>到<code>z</code>，求树中字典序最小的字符串。</p>
<a id="more"></a>
<h1 id="si-lu">思路</h1>
<p>一开始想到的方法，就是去深度遍历，每个节点对应的字符串为<code>min(左子树的字符串 + 当前节点值, 右子树的字符串 + 当前节点值)</code>，</p>
<p>实现代码大致如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> smallestFromLeaf = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="string">""</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> dfs = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node === <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> leftStr = dfs(node.left);</span><br><span class="line">        <span class="keyword">let</span> rightStr = dfs(node.right);</span><br><span class="line">        <span class="keyword">let</span> ch = <span class="built_in">String</span>.fromCharCode(<span class="number">97</span> + node.val);</span><br><span class="line">        <span class="keyword">var</span> ret = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(leftStr == <span class="string">''</span> &amp;&amp; rightStr == <span class="string">''</span>)&#123;</span><br><span class="line">            ret = ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(leftStr == <span class="string">''</span> || rightStr == <span class="string">''</span>)&#123;</span><br><span class="line">            ret = (leftStr != <span class="string">''</span> ? leftStr : rightStr) + ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ret = leftStr + ch &lt; rightStr + ch ? leftStr + ch : rightStr + ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> dfs(root);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是！这段代码只能通过<code>66/67</code>的测试样例，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">25</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>这个无法通过。</p>
<p>在看了<a href="https://leetcode.com/problems/smallest-string-starting-from-leaf/discuss/231102/C%2B%2B-3-lines" target="_blank" rel="noopener">评论区</a>大神的说明后，明白了。</p>
<p>考虑 <code>ab</code> 和 <code>abab</code>以及节点值<code>z</code>，显然，<code>ab &lt; abab</code>，<code>abz &gt; ababz</code>。<br>
本测试样例的树如下：<br>
<img src="/2019/04/16/LeetCode题解-988-Smallest-String-Starting-From-Leaf/67.jpg" alt><br>
上述代码执行过程如下：<br>
<img src="/2019/04/16/LeetCode题解-988-Smallest-String-Starting-From-Leaf/67-1.jpg" alt><br>
错误发生在第二层的节点<code>b</code>处。</p>
<p>如果只以子树的字符串为依据，由于不知道加上父亲节点之后，构成的字典序是否仍是较小的那个，所以在这边发生了错误。</p>
<p>想到这，也好修正了，只需要传入父亲节点的值，即可。</p>
<h1 id="shi-xian">实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> smallestFromLeaf = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="string">""</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> dfs = <span class="function">(<span class="params">node, s</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node === <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'&#123;'</span>;  <span class="comment">// &#123; 的 ascii 码大于 z</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        s = <span class="built_in">String</span>.fromCharCode(<span class="number">97</span> + node.val) + s;</span><br><span class="line">        <span class="keyword">let</span> leftStr = dfs(node.left, s);</span><br><span class="line">        <span class="keyword">let</span> rightStr = dfs(node.right, s);</span><br><span class="line">        <span class="keyword">var</span> ret = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(leftStr == <span class="string">'&#123;'</span> &amp;&amp; rightStr == <span class="string">'&#123;'</span>)&#123;</span><br><span class="line">            ret = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ret = leftStr &lt; rightStr ? leftStr : rightStr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> dfs(root, <span class="string">''</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|279. Perfect Squares</title>
    <url>/2019/04/14/LeetCode%E9%A2%98%E8%A7%A3-279-Perfect-Squares/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode.com/problems/perfect-squares/" target="_blank" rel="noopener">279. Perfect Squares</a></p>
</blockquote>
<h1 id="gai-shu">概述</h1>
<p>本题目要求将一个给定的数<code>n</code>拆分为若干个平方数的和，求最小拆分数。</p>
<a id="more"></a>
<h1 id="si-lu">思路</h1>
<p>这个题目可以用动态规划来做。</p>
<p>dp[i]代表组成i的最少平方数的个数，这个值最大就是它本身（看作都由1组成）。<br>
而组成这个数的最小值要么就是本身，要么就是前面某一个数+一个平方数（所以看作值加上1）<br>
所以状态转移方程为：<code>dp[i] = min(dp[i - j * j] + 1, dp[i])</code>（其中 j &lt; sqrt(i）)<br>
有转移方程后代码就很好写了。</p>
<p>这个题目还有另外一个解法，是<a href="https://zh.wikipedia.org/wiki/%E5%9B%9B%E5%B9%B3%E6%96%B9%E5%92%8C%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">四平方和定理</a>（好吧，我没听过，读者有兴趣可以自己研究下）</p>
<h1 id="shi-xian">实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numSquares = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        dp[i] = n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> sqrt = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.sqrt(i));</span><br><span class="line">        <span class="keyword">if</span>(sqrt * sqrt == i)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= sqrt; j++)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">Math</span>.min(dp[i], dp[i - j * j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|652. Find Duplicate Subtrees</title>
    <url>/2019/04/14/LeetCode%E9%A2%98%E8%A7%A3-652-Find-Duplicate-Subtrees/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode.com/problems/find-duplicate-subtrees/" target="_blank" rel="noopener">652. Find Duplicate Subtrees</a></p>
</blockquote>
<h1 id="gai-shu">概述</h1>
<p>本题给定一棵二叉树，要求找出所有的重复子树。</p>
<a id="more"></a>
<h1 id="si-lu">思路</h1>
<p>对这棵树进行<code>前序遍历</code>，如果某一子树的前序遍历序列已经出现过，说明这棵子树是重复出现的，将其加入结果集即可。</p>
<h1 id="shi-xian">实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;TreeNode[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findDuplicateSubtrees = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> preorder = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> vs = preorder(node.left) + preorder(node.right) + node.val;</span><br><span class="line">        <span class="keyword">if</span>(map[vs])&#123;</span><br><span class="line">            <span class="keyword">if</span>(map[vs] == <span class="number">1</span>)&#123;</span><br><span class="line">                result.push(node);</span><br><span class="line">            &#125;</span><br><span class="line">            map[vs] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            map[vs] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vs;</span><br><span class="line">    &#125;</span><br><span class="line">    preorder(root);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|86. Partition List</title>
    <url>/2019/04/14/LeetCode%E9%A2%98%E8%A7%A3-86-Partition-List/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode.com/problems/partition-list/" target="_blank" rel="noopener">86. Partition List</a></p>
</blockquote>
<h1 id="gai-shu">概述</h1>
<p>这个题目给定一个单链表<code>L</code>以及一个整数<code>x</code>，使得所有小于<code>x</code>的节点在大于等于<code>x</code>的节点之前，同时要保证顺序和原链表一致。</p>
<a id="more"></a>
<h1 id="si-lu">思路</h1>
<p>这个题目只要创建两个链表，遍历一遍原链表<code>L</code>，将所有节点按照要求，分别插入到两个新链表中，就完成了分隔，紧接着在将两段链表连接起来，即可得到答案。</p>
<h1 id="shi-xian">实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; x</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> partition = <span class="function"><span class="keyword">function</span>(<span class="params">head, x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> smaller = p1 = <span class="keyword">new</span> ListNode(<span class="literal">null</span>),</span><br><span class="line">        larger = p2 = <span class="keyword">new</span> ListNode(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.val &lt; x)&#123;</span><br><span class="line">            smaller.next = head;</span><br><span class="line">            smaller = smaller.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            larger.next = head;</span><br><span class="line">            larger = larger.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    larger.next = <span class="literal">null</span>;</span><br><span class="line">    smaller.next = p2.next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> p1.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|687. Longest Univalue Path</title>
    <url>/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3-687-Longest-Univalue-Path/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode.com/problems/longest-univalue-path/" target="_blank" rel="noopener">687. Longest Univalue Path</a></p>
</blockquote>
<h1 id="gai-shu">概述</h1>
<p>给定一棵二叉树，找出树中有相同值的最长路径长度。</p>
<a id="more"></a>
<h1 id="si-lu">思路</h1>
<p>使用<code>DFS</code>，找出每个节点的左右子树左右两边的最长路径值<code>lr</code>，如果当前节点与左(右)子树的节点值相等，则将当前节点的左(右)值定为左(右)子树<code>lr</code>中的最大值+1。</p>
<h1 id="shi-xian">实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestUnivaluePath = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> dfs = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span> || (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">left</span>: <span class="number">0</span>, <span class="attr">right</span>: <span class="number">0</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> &#123; <span class="attr">left</span>: ll, <span class="attr">right</span>: lr &#125; = dfs(node.left);</span><br><span class="line">        <span class="keyword">const</span> &#123; <span class="attr">left</span>: rl, <span class="attr">right</span>: rr &#125; = dfs(node.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">0</span>,</span><br><span class="line">            right = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span> &amp;&amp; node.val == node.left.val)&#123;</span><br><span class="line">            left = <span class="built_in">Math</span>.max(ll, lr) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span> &amp;&amp; node.val == node.right.val)&#123;</span><br><span class="line">            right = <span class="built_in">Math</span>.max(rl, rr) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxLength = <span class="built_in">Math</span>.max(maxLength, left + right);</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">left</span>: left, <span class="attr">right</span>: right &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|143. Reorder List</title>
    <url>/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3-143-Reorder-List/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode.com/problems/reorder-list/" target="_blank" rel="noopener">143. Reorder List</a></p>
</blockquote>
<h1 id="gai-shu">概述</h1>
<p>给定一个单链表<code>L</code>: L<sub>0</sub>→L<sub>1</sub>→…→L<sub>n-1</sub>→L<sub>n</sub>，将其重排为：L<sub>0</sub>→L<sub>n</sub>→L<sub>1</sub>→L<sub>n-1</sub>→L<sub>2</sub>→L<sub>n-2</sub>→…，即将<code>L</code>头尾交替重排序。</p>
<a id="more"></a>
<h1 id="si-lu">思路</h1>
<p>整体四里路为：先将<code>L</code>一分为二，然后将后半段链表逆序，再依次插入前半段节点中。</p>
<p>在找链表的中间节点时，使用<code>快慢指针</code>就可以快速找到。</p>
<p>逆序时，将当前节点的后继节点进行位置交换，举例来说，给定链表<code>l</code>:head→b→c→d。首先，将<code>b</code>的后继，改为原后继<code>c</code>的后继<code>d</code>，即：head→b→d，然后将<code>c</code>指向<code>b</code>，<code>head</code>指向<code>c</code>，即：head→c→b→d</p>
<h1 id="shi-xian">实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;void&#125; Do not return anything, modify head in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reorderList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> fast = head,</span><br><span class="line">        slow = head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到中间节点</span></span><br><span class="line">    <span class="keyword">while</span>(fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> middle = slow,</span><br><span class="line">        cur = slow.next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 反转后半段链表</span></span><br><span class="line">    <span class="keyword">while</span>(cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> tmp = cur.next;</span><br><span class="line">        cur.next = tmp.next;</span><br><span class="line">        tmp.next = middle.next;</span><br><span class="line">        middle.next = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拼接</span></span><br><span class="line">    <span class="keyword">var</span> p1 = head,</span><br><span class="line">        p2 = slow.next;</span><br><span class="line">    <span class="keyword">while</span>(p1 != slow)&#123;</span><br><span class="line">        slow.next = p2.next;</span><br><span class="line">        p2.next = p1.next;</span><br><span class="line">        p1.next = p2;</span><br><span class="line">        p1 = p2.next;</span><br><span class="line">        p2 = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|3. Longest Substring Without Repeating Characters</title>
    <url>/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3-3-Longest-Substring-Without-Repeating-Characters/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. Longest Substring Without Repeating Characters</a></p>
</blockquote>
<h1 id="gai-shu">概述</h1>
<p>这个题目给定一个字符串<code>s</code>，找出其中不含有重复字符的<code>最长子串</code>的长度。</p>
<a id="more"></a>
<h1 id="si-lu">思路</h1>
<p>该题目可使用 <a href="https://www.zhihu.com/question/314669016" target="_blank" rel="noopener">滑动窗口</a> 来做。</p>
<p>具体来说，使用两个指针<code>left</code>、<code>right</code>来确定出一个子串的范围，如果<code>s[right]</code>已经在<code>s[left...right-1]</code>中出现过，则将<code>left</code>向右挪，反之则将<code>right</code>向右挪，直到<code>right</code>到达<code>s</code>结尾。</p>
<p>通过这样对<code>s</code>进行一次扫描，即可得到最长子串。</p>
<h1 id="shi-xian">实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span>,</span><br><span class="line">        right = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt;= s.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(maxLength &lt; right - left)&#123;</span><br><span class="line">            maxLength = right - left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.substring(left, right).indexOf(s[right]) != <span class="number">-1</span>)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|971. Flip Binary Tree To Match Preorder Traversal</title>
    <url>/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3-971-Flip-Binary-Tree-To-Match-Preorder-Traversal/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal/" target="_blank" rel="noopener">971. Flip Binary Tree To Match Preorder Traversal</a></p>
</blockquote>
<h1 id="gai-shu">概述</h1>
<p>这个题目给定了一棵有<code>N</code>个节点的二叉树以及一个序列<code>v</code>，问如何翻转最少的节点（交换左右子树），使得前序遍历结果和给定的序列一致。</p>
<a id="more"></a>
<h1 id="si-lu">思路</h1>
<p>使用<code>DFS</code>前序遍历这棵树，并且使用一个指针<code>i</code>，记录当前节点<code>node</code>应该和<code>v</code>中的哪个值相等，<code>DFS</code>时，可分为以下三种情况：</p>
<ol>
<li><code>node === null</code>，说明我们已经遍历完了，返回<code>true</code></li>
<li><code>node.val !== v[i]</code>，说明该节点值不是预期的，返回<code>false</code></li>
<li><code>node.left.!== null &amp;&amp; node.left.val !== v[i]</code>，说明左儿子存在但是其值并不是预期的，此时，我们应该翻转<code>node</code>节点，但是我们并不需要真的去修改指针，只要先去遍历右子树，再去遍历左子树，即可达到翻转并且前序遍历的目的。</li>
</ol>
<h1 id="shi-xian">实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; voyage</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> flipMatchVoyage = <span class="function"><span class="keyword">function</span>(<span class="params">root, voyage</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> dfs = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.val != voyage[i++])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span> &amp;&amp; node.left.val != voyage[i])&#123;</span><br><span class="line">            result.push(node.val);</span><br><span class="line">            <span class="keyword">return</span> dfs(node.right) &amp;&amp; dfs(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(node.left) &amp;&amp; dfs(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dfs(root) ? result : [<span class="number">-1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|1017. Convert to Base -2</title>
    <url>/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3-1017-Convert-to-Base-2/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode.com/problems/convert-to-base-2/" target="_blank" rel="noopener">1017. Convert to Base -2</a></p>
</blockquote>
<h1 id="gai-shu">概述</h1>
<p>这个题目要求很简单，就是实现一个十进制到负二进制的转换。</p>
<a id="more"></a>
<h1 id="si-lu">思路</h1>
<p>在实现前，先回顾下进制转换的方法：<strong>除k取余法</strong></p>
<p>以十进制下的<code>N = 5</code>转为二进制为例：<br>
第一步：5整除2，商为2，余1；<br>
第二步：2整除2，商为1，余0；<br>
第三步：1整除2，商为0，余1；<br>
由于到第三步时商已经等于0，故算法结束。所以，5<sub>10</sub>=101<sub>2</sub></p>
<p>进一步，我们可以使用<code>位运算</code>来取余数或做除法。</p>
<blockquote>
<p>设X对Y求余，Y等于2<sup>N</sup>，公式为：X &amp; (2<sup>N</sup> - 1) 或 X&amp;(~Y)。</p>
</blockquote>
<p>因此，在求余数的时候，我们只要使用<code>N &amp; 1</code>即可。完整的二进制转换代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; N</span></span><br><span class="line"><span class="comment"> * @return &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> base2 = <span class="function"><span class="keyword">function</span>(<span class="params">N</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> remainders = [];</span><br><span class="line">    <span class="keyword">while</span>(N != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> x = N &amp; <span class="number">1</span>;</span><br><span class="line">        remainders.push(x);</span><br><span class="line">        N = N &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> remainders.reverse().join(<span class="string">""</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>前面举的例子都是二进制的，那负二进制呢？类似的，我们在转换为负二进制时，只需要将除数改为<code>-2</code>即可。</p>
<h1 id="shi-xian">实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; N</span></span><br><span class="line"><span class="comment"> * @return &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> baseNeg2 = <span class="function"><span class="keyword">function</span>(<span class="params">N</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> remainders = [];</span><br><span class="line">    <span class="keyword">while</span>(N != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> x = N &amp; <span class="number">1</span>;</span><br><span class="line">        remainders.push(x);</span><br><span class="line">        N = -(N &gt;&gt; <span class="number">1</span>); <span class="comment">// 注意这里多了个负号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> remainders.reverse().join(<span class="string">""</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|380. Insert Delete GetRandom O(1)</title>
    <url>/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3-380-Insert-Delete-GetRandom-O-1/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode.com/problems/insert-delete-getrandom-o1/" target="_blank" rel="noopener">380. Insert Delete GetRandom O(1)</a></p>
</blockquote>
<h1 id="gai-shu">概述</h1>
<p>这个题目要求设计一个数据结构，使得能够在<code>O(1)</code>时间内完成插入、删除、随机获取。</p>
<a id="more"></a>
<h1 id="si-lu">思路</h1>
<p>看到这个要求，很自然就想到了数组。但是单纯数组并不能满足题目中要求的如果存在值才可删除/不可插入，为此，可以引入一个<code>Map</code>，用于保存数组中值的位置情况。</p>
<p>插入时，先在<code>map</code>中查找下是否存在<code>val</code>，若存在，则按题目要求，返回<code>false</code>，否则在数组尾部插入该值，并且在<code>map</code>中记录其位置。</p>
<p>删除时，同样是去<code>map</code>中查找下是否存在<code>val</code>，若不存在，也是按题目要求，返回<code>false</code>，否则的话，将数组最后一个元素<code>last</code>放到<code>val</code>的位置上，同时更新<code>last</code>在<code>map</code>中的索引，最后将数组最后一个元素删除掉。</p>
<h1 id="shi-xian">实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize your data structure here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> RandomizedSet = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.set = [];</span><br><span class="line">    <span class="keyword">this</span>.map = &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts a value to the set. Returns true if the set did not already contain the specified element. </span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; val</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RandomizedSet.prototype.insert = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(val <span class="keyword">in</span> <span class="keyword">this</span>.map)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.set.push(val);</span><br><span class="line">    <span class="keyword">this</span>.map[val] = <span class="keyword">this</span>.set.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes a value from the set. Returns true if the set contained the specified element. </span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; val</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RandomizedSet.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(val <span class="keyword">in</span> <span class="keyword">this</span>.map))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> last = <span class="keyword">this</span>.set.pop();</span><br><span class="line">    <span class="keyword">let</span> index = <span class="keyword">this</span>.map[val];</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.map[val];</span><br><span class="line">    <span class="keyword">if</span>(val !== last)&#123;</span><br><span class="line">        <span class="keyword">this</span>.set[index] = last;</span><br><span class="line">        <span class="keyword">this</span>.map[last] = index;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get a random element from the set.</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RandomizedSet.prototype.getRandom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> rand = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="keyword">this</span>.set.length);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.set[rand]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new RandomizedSet()</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.insert(val)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.remove(val)</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.getRandom()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解集合</title>
    <url>/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>每日来点LeetCode</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th>#</th>
<th>Title</th>
<th>Solution</th>
<th>Difficulty</th>
<th>Tag</th>
</tr>
</thead>
<tbody>
<tr>
<td>380</td>
<td><a href="https://leetcode.com/problems/insert-delete-getrandom-o1/" target="_blank" rel="noopener">Insert Delete GetRandom O(1)</a></td>
<td><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3-380-Insert-Delete-GetRandom-O-1/">js</a></td>
<td>Medium</td>
<td>Array</td>
</tr>
<tr>
<td>1017</td>
<td><a href="https://leetcode.com/problems/convert-to-base-2/" target="_blank" rel="noopener">Convert to Base -2</a></td>
<td><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3-1017-Convert-to-Base-2/">js</a></td>
<td>Medium</td>
<td>Math</td>
</tr>
<tr>
<td>971</td>
<td><a href="https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal/" target="_blank" rel="noopener">Flip Binary Tree To Match Preorder Traversal</a></td>
<td><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3-971-Flip-Binary-Tree-To-Match-Preorder-Traversal/">js</a></td>
<td>Medium</td>
<td>Tree</td>
</tr>
<tr>
<td>3</td>
<td><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">Longest Substring Without Repeating Characters</a></td>
<td><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3-3-Longest-Substring-Without-Repeating-Characters/">js</a></td>
<td>Medium</td>
<td>String</td>
</tr>
<tr>
<td>143</td>
<td><a href="https://leetcode.com/problems/reorder-list/" target="_blank" rel="noopener">Reorder List</a></td>
<td><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3-143-Reorder-List/">js</a></td>
<td>Medium</td>
<td>Linked List</td>
</tr>
<tr>
<td>687</td>
<td><a href="https://leetcode.com/problems/longest-univalue-path/" target="_blank" rel="noopener">Longest Univalue Path</a></td>
<td><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3-687-Longest-Univalue-Path/">js</a></td>
<td>Easy</td>
<td>Tree</td>
</tr>
<tr>
<td>86</td>
<td><a href="https://leetcode.com/problems/partition-list/" target="_blank" rel="noopener">Partition List</a></td>
<td><a href="/2019/04/14/LeetCode%E9%A2%98%E8%A7%A3-86-Partition-List/">js</a></td>
<td>Medium</td>
<td>Linked List</td>
</tr>
<tr>
<td>652</td>
<td><a href="https://leetcode.com/problems/find-duplicate-subtrees/" target="_blank" rel="noopener">Find Duplicate Subtrees</a></td>
<td><a href="/2019/04/14/LeetCode%E9%A2%98%E8%A7%A3-652-Find-Duplicate-Subtrees/">js</a></td>
<td>Medium</td>
<td>Tree</td>
</tr>
<tr>
<td>279</td>
<td><a href="https://leetcode.com/problems/perfect-squares/" target="_blank" rel="noopener">Perfect Squares</a></td>
<td><a href="/2019/04/14/LeetCode%E9%A2%98%E8%A7%A3-279-Perfect-Squares/">js</a></td>
<td>Medium</td>
<td>Math</td>
</tr>
<tr>
<td>988</td>
<td><a href="https://leetcode.com/problems/smallest-string-starting-from-leaf/" target="_blank" rel="noopener">Smallest String Starting From Leaf</a></td>
<td><a href="/2019/04/16/LeetCode%E9%A2%98%E8%A7%A3-988-Smallest-String-Starting-From-Leaf/">js</a></td>
<td>Medium</td>
<td>Tree</td>
</tr>
<tr>
<td>775</td>
<td><a href="https://leetcode.com/problems/global-and-local-inversions/" target="_blank" rel="noopener">Global and Local Inversions</a></td>
<td><a href="/2019/04/16/LeetCode%E9%A2%98%E8%A7%A3-775-Global-and-Local-Inversions/">js</a></td>
<td>Medium</td>
<td>Tree</td>
</tr>
<tr>
<td>26</td>
<td><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/description/" target="_blank" rel="noopener">删除排序数组中的重复项</a></td>
<td><a href="/2019/09/08/LeetCode%E9%A2%98%E8%A7%A3-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/">js</a></td>
<td>Easy</td>
<td>Array</td>
</tr>
<tr>
<td>27</td>
<td><a href="https://leetcode-cn.com/problems/remove-element/description/" target="_blank" rel="noopener">移除元素</a></td>
<td><a href="/2019/09/08/LeetCode%E9%A2%98%E8%A7%A3-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/">js</a></td>
<td>Easy</td>
<td>Array</td>
</tr>
<tr>
<td>28</td>
<td><a href="https://leetcode-cn.com/problems/implement-strstr/description/" target="_blank" rel="noopener">实现strStr()</a></td>
<td><a href="/2019/09/08/LeetCode%E9%A2%98%E8%A7%A3-28-%E5%AE%9E%E7%8E%B0strStr/">js</a></td>
<td>Easy</td>
<td>String</td>
</tr>
</tbody>
</table>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>CORS</title>
    <url>/2019/04/03/cors/</url>
    <content><![CDATA[<p><strong>CORS</strong>是一个W3C标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）。它允许浏览器向跨域服务器，发出<code>XMLHttpRequest</code>请求，从而克服了AJAX只能同源使用的限制。<br>
本文介绍了CORS的内部机制。</p>
<a id="more"></a>
<h1 id="jian-jie">简介</h1>
<p>CORS需要浏览器和服务器同时支持。目前，主流浏览器都已基本提供对跨域资源共享的支持，移动端浏览器也几乎全部支持。<br>
<img src="/2019/04/03/cors/support_browsers.png" alt="浏览器对CORS的支持情况"></p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<h1 id="shi-yao-qing-kuang-xia-xu-yao-cors">什么情况下需要CORS？</h1>
<blockquote>
<ul>
<li>由<code>XMLHttpRequest</code>或<code>Fetch</code>发起的跨域 HTTP 请求。</li>
<li>Web 字体 (CSS 中通过<code>@font-face</code>使用跨域字体资源)</li>
<li>使用<code>drawImage</code>将<code>Images/video</code>画面绘制到<code>canvas</code></li>
</ul>
</blockquote>
<p>例如，当你引用了某个第三方CDN上的字体文件时：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* CSS */</span></span><br><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">'FontAwesome'</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'http://cdn.com/fonts/fontawesome.ttf'</span>) <span class="built_in">format</span>(<span class="string">'truetype'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果该CDN服务商未正确设置<code>Access-Control-Allow-Origin</code>，那么浏览器无法加载字体资源。</p>
<h1 id="liang-chong-qing-qiu">两种请求</h1>
<p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>若请求满足以下条件，则该请求属于简单请求：</p>
<blockquote>
<ol>
<li>请求方法是下列三种之一：
<ul>
<li>GET</li>
<li>POST</li>
<li>HEAD</li>
</ul>
</li>
<li>HTTP的头信息不得包含以下几种字段之外的字段：
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type： 仅限于<code>text/plain</code>、<code>multipart/form-data</code>、<code>application/x-www-form-urlencoded</code>三个值</li>
</ul>
</li>
</ol>
</blockquote>
<p>凡是不同时满足上面两个条件，就属于非简单请求。<br>
浏览器对这两种请求的处理，是不一样的。</p>
<h2 id="jian-dan-qing-qiu"><a class="header-anchor" href="#简单请求">¶</a>简单请求</h2>
<p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。<br>
我们首先发起一个跨域请求：<br>
<img src="/2019/04/03/cors/request_cors_blocked.jpg" alt></p>
<p>可以看到，浏览器自动在请求头部加了一个<code>Origin</code>字段，同时服务器返回的状态码也为200，但是在控制台我们可以看到这样一个CORS的报错：<br>
<img src="/2019/04/03/cors/request_cors_blocked_2.jpg" alt><br>
在服务器我们也能看到这样的记录：<br>
<img src="/2019/04/03/cors/server_cors_record.jpg" alt><br>
这个也说明了，跨域请求可以正常发起，但是返回结果被浏览器拦截了。</p>
<p>我们对服务器稍加修改，给其响应头部加上如下字段：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span>: http://sender.com</span><br></pre></td></tr></table></figure>
<p>此时我们再发起请求，就可以看到结果如下：<br>
<img src="/2019/04/03/cors/request_cors_ok.jpg" alt><br>
同时在控制台也没有了CORS的报错了。</p>
<p>总结一下，在发起一个简单请求时，浏览器如果发现这次请求是一个跨域AJAX请求时，就自动在头信息之中，添加一个<code>Origin</code>字段。<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>
<p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段或者这个字段的值中不包含这个<code>Origin</code>指定的源，就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200也有可能是其他，这个取决于服务器是否有做这方面的处理。比如，服务器对请求头中的<code>Origin</code>进行了判断后，可能给出诸如<code>403</code>等返回码如下：<br>
<img src="/2019/04/03/cors/server_check_origin.jpg" alt><br>
服务器对<code>Origin</code>字段判断后，返回了<code>403</code>，同样的请求得到了不同的响应结果（对比上图）：<br>
<img src="/2019/04/03/cors/request_cors_blocked_3.jpg" alt></p>
<h2 id="fei-jian-dan-qing-qiu"><a class="header-anchor" href="#非简单请求">¶</a>非简单请求</h2>
<p>对于非简单请求，浏览器并不会立即执行对应的请求代码，而是会先发送一个被称为<code>“预检”(Preflight)</code>的<code>OPTION</code>请求，用于询问要被跨域访问的服务器，是否允许当前域名下的页面发送跨域的请求。</p>
<p>比如，使用下面的代码发起一个请求：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'http://receiver.com/testNotSimpleReq.php'</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'PUT'</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'X-Custom-Header'</span>, <span class="string">'value'</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
<p>这段代码中，HTTP请求的方法是<code>PUT</code>，并且发送一个自定义头信息<code>X-Custom-Header</code>。<br>
浏览器发现这是一个非简单请求，就会先自动发起一个“预检”请求，要求服务器确认可以这样请求：<br>
<img src="/2019/04/03/cors/preflight_request.jpg" alt><br>
在请求头部中，关键字段是<code>Origin</code>，表示请求来自哪个源。<br>
除了<code>Origin</code>字段，&quot;预检&quot;请求的头信息包括两个特殊字段。</p>
<ol>
<li><code>Access-Control-Request-Method</code><br>
该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是<code>PUT</code>。</li>
<li><code>Access-Control-Request-Headers</code><br>
该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code>。</li>
</ol>
<p>在“预检”请求的响应头部中，出现了三个字段：</p>
<ol>
<li><code>Access-Control-Allow-Origin</code><br>
和前面一样，表示接受的域名</li>
<li><code>Access-Control-Allow-Methods</code><br>
逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次&quot;预检&quot;请求。</li>
<li><code>Access-Control-Allow-Headers</code><br>
如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在&quot;预检&quot;中请求的字段。</li>
</ol>
<p>如果请求方法或者请求中含有的自定义头部不在响应头部的<code>Access-Control-Allow-Methods</code>和<code>Access-Control-Allow-Headers</code>中，浏览器就不会真正发起该请求，同时在控制台报错如下：<br>
<img src="/2019/04/03/cors/preflight_response_no_header.jpg" alt><br>
<img src="/2019/04/03/cors/preflight_response_no_method.jpg" alt></p>
<p>如果顺利通过“预检”的话，浏览器则会真正发起请求：<br>
<img src="/2019/04/03/cors/preflight_request_success.jpg" alt></p>
<h1 id="cookies-yu-cors">Cookies与CORS</h1>
<p>默认情况下，Cookie不包括在CORS请求之中。<br>
如果服务器允许请求中包含Cookies，则需要在响应头部中加入字段</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>
<p>如果服务器不要浏览器发送Cookie，删除该字段或者设置为<code>false</code>即可。<br>
另一方面，开发者必须在AJAX请求中打开withCredentials属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。</p>
<p>但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.withCredentials = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果要发送Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。<br>
同时，Cookie依然遵循同源策略，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且跨域的原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie。</p>
<h1 id="yu-jsonp-de-bi-jiao">与JSONP的比较</h1>
<p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p>
<p>JSONP只支持<code>GET</code>请求，CORS支持<code>所有类型</code>的HTTP请求。<br>
JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>
<h1 id="can-kao">参考</h1>
<p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解 - 阮一峰</a><br>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">HTTP访问控制（CORS） - MDN</a><br>
<a href="https://yq.aliyun.com/articles/69313" target="_blank" rel="noopener">CORS——跨域请求那些事儿</a></p>
]]></content>
      <tags>
        <tag>CORS</tag>
        <tag>跨域</tag>
        <tag>同源策略</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器的同源策略</title>
    <url>/2019/03/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>浏览器的<strong>同源策略</strong>是一个用于隔离潜在恶意文件的重要安全机制，其限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。<br>
本文介绍了同源策略的几个方面，以及如何避免。</p>
<a id="more"></a>
<h1 id="gai-shu">概述</h1>
<h2 id="shi-yao-shi-tong-yuan"><a class="header-anchor" href="#什么是同源">¶</a>什么是同源</h2>
<p>所谓的“同源”， 指的是“三个相同”，即：</p>
<blockquote>
<ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同</li>
</ul>
</blockquote>
<p>举例来说，<code>https://www.a.com/bbb/ccc.html</code>这个网址，协议为<code>https://</code>，域名为<code>www.a.com</code>，端口为<code>80</code>（默认的80端口可省略）。以下几个网址与之的同源情况为：</p>
<blockquote>
<ul>
<li><a href="https://www.a.com/xxx/yyy.html" target="_blank" rel="noopener">https://www.a.com/xxx/yyy.html</a> -&gt; 同源</li>
<li><a href="http://www.a.com/bbb/ccc.html" target="_blank" rel="noopener">http://www.a.com/bbb/ccc.html</a> -&gt; 不同源，协议不同</li>
<li><a href="https://m.a.com/bbb/ccc.com" target="_blank" rel="noopener">https://m.a.com/bbb/ccc.com</a> -&gt; 不同源，域名不同</li>
<li><a href="https://www.a.com:8080/bbb/ccc.html" target="_blank" rel="noopener">https://www.a.com:8080/bbb/ccc.html</a> -&gt; 不同源，端口不同</li>
</ul>
</blockquote>
<h2 id="tong-yuan-de-mu-de"><a class="header-anchor" href="#同源的目的">¶</a>同源的目的</h2>
<p>同源策略的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>
<h2 id="tong-yuan-de-xian-zhi-fan-wei"><a class="header-anchor" href="#同源的限制范围">¶</a>同源的限制范围</h2>
<p>目前，如果非同源，共有三种行为受到限制。</p>
<blockquote>
<ul>
<li>Cookie、LocalStorage 和 IndexDB 无法读取。</li>
<li>DOM 无法获得。</li>
<li>AJAX 请求不能发送。</li>
</ul>
</blockquote>
<p>以下将分别介绍如何避免这三个限制</p>
<h1 id="cookies">Cookies</h1>
<blockquote>
<p>服务器写入浏览器的一小段信息，只有同源的网页才能共享。</p>
</blockquote>
<p>但是，如果两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置<code>document.domain</code>共享 Cookie。</p>
<p>举例来说，A网页是<code>https://www.a.com/bbb/ccc.html</code>，B网页是<code>https://m.a.com/xxx/yyy.html</code>，那么，只要设置相同的<code>document.domain</code>，这两个网页就可以共享Cookies了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为两个页面设置相同的 document.domain</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'a.com'</span>;</span><br></pre></td></tr></table></figure>
<p>现在，A网页内通过脚本设置一个Cookies</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookies = <span class="string">"test1=hello"</span>;</span><br><span class="line"><span class="built_in">document</span>.cookies = <span class="string">"test2=world"</span>;</span><br></pre></td></tr></table></figure>
<p>B网页就可以读取到这个Cookies了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> allCookies = <span class="built_in">document</span>.cookies; <span class="comment">// test1=hello;test2=world</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：<code>document.domain</code>不能随意设置，只能把<code>document.domain</code>设置成自身或更高一级的父域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.a.com/bbb/ccc.html页面下</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">"b.com"</span>;</span><br><span class="line"><span class="comment">// Uncaught DOMException: Failed to set the 'domain' property on 'Document': 'b.com' is not a suffix of 'www.a.com'.</span></span><br></pre></td></tr></table></figure>
<p>此外，这种方法只适用于Cookie和iframe窗口，LocalStorage和IndexDB无法通过这种方法来规避同源策略，而要使用下文介绍的PostMessage API。</p>
<p>另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如<code>.a.com</code>。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span>: key=value; domain=.a.com; path=/</span><br></pre></td></tr></table></figure>
<p>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。</p>
<p>PS：如果两个网址，协议不同或端口不同，其Cookies可共享，即：Cookie共享跟协议、端口无关</p>
<h1 id="kua-yu-wen-dang-tong-xin">跨域文档通信</h1>
<blockquote>
<p>如果两个网页不同源，就无法拿到对方的<code>DOM</code>，也无法进行通信。典型的例子是<code>iframe</code>窗口和<code>window.open</code>方法打开的窗口，它们与父窗口无法通信。</p>
</blockquote>
<p>比如，父窗口运行下面的命令，如果<code>iframe</code>窗口不是同源，就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"myIFrame"</span>).contentWindow.document</span><br><span class="line"><span class="comment">// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame.</span></span><br></pre></td></tr></table></figure>
<p>上面命令中，父窗口想获取子窗口的DOM，因为跨源导致报错。</p>
<p>反之亦然，子窗口获取主窗口的DOM也会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.parent.document.body</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的<code>document.domain</code>属性，就可以规避同源策略，拿到<code>DOM</code>。</p>
<p>对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。</p>
<blockquote>
<ul>
<li>片段识别符（fragment identifier）</li>
<li><a href="http://window.name" target="_blank" rel="noopener">window.name</a></li>
<li>window.postMessage</li>
</ul>
</blockquote>
<h2 id="pian-duan-shi-bie-fu-fragment-identifier"><a class="header-anchor" href="#片段识别符-fragment-identifier">¶</a>片段识别符（fragment identifier）</h2>
<blockquote>
<p>片段标识符（fragment identifier）指的是，URL的<code>#</code>号后面的部分，比如<code>https://www.a.com/bbb/ccc.html#fragment</code>的<code>#fragment</code>。如果只是改变片段标识符，页面不会重新刷新。</p>
</blockquote>
<p>父窗口可以把信息，写入子窗口的片段标识符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> src = originURL + <span class="string">'#'</span> + data;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'myIFrame'</span>).src = src;</span><br></pre></td></tr></table></figure>
<p>子窗口通过监听<code>hashchange</code>事件得到通知。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onhashchange = checkMessage;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkMessage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="built_in">window</span>.location.hash;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，子窗口也可以改变父窗口的片段标识符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">parent.location.href= target + <span class="string">"#"</span> + hash;</span><br></pre></td></tr></table></figure>
<h2 id="a-href-http-window-name-window-name-a"><a class="header-anchor" href="#window-name">¶</a><a href="http://window.name" target="_blank" rel="noopener">window.name</a></h2>
<p>浏览器窗口有<code>window.name</code>属性。这个属性的最大特点是，只要当前的这个浏览器<code>tab</code>没有关闭，无论<code>tab</code>内的网页如何变动，这个<code>name</code>值都可以保持，并且<code>tab</code>内的每个网页都是可以接收和设置<code>window.name</code>这个值的。</p>
<blockquote>
<ul>
<li>F5刷新多少次都可以，这是无所谓的。</li>
<li>中间跳转过多少个页面，这也是无所谓的。</li>
<li>承载过的这些页面是不是同一个域名，这都是无所谓的。</li>
</ul>
</blockquote>
<p>上述的<code>tab</code>，改成<code>iframe</code>同样可行。<br>
父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入<code>window.name</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在子窗口中设置其window.name</span></span><br><span class="line"><span class="built_in">window</span>.name = data;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接着，子窗口跳回一个与主窗口同域的网址。</span></span><br><span class="line">location = <span class="string">'http://parent.url.com/xxx.html'</span>;</span><br></pre></td></tr></table></figure>
<p>然后，主窗口就可以读取子窗口的<code>window.name</code>了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主窗口中</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="built_in">document</span>.getElementById(<span class="string">'myFrame'</span>).contentWindow.name;</span><br></pre></td></tr></table></figure>
<p>这种方法的优点是，<code>window.name</code>容量很大，可以放置非常长的字符串；缺点是必须监听子窗口<code>window.name</code>属性的变化，影响网页性能。</p>
<h2 id="window-post-message"><a class="header-anchor" href="#window-postmessage">¶</a>window.postMessage</h2>
<blockquote>
<p>在HTML5中，为了实现跨源通信，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。<br>
这个API为<code>window</code>对象新增了一个<code>window.postMessage</code>方法，允许跨窗口通信，不论这两个窗口是否同源。</p>
</blockquote>
<p>其语法为：</p>
<blockquote>
<p>otherWindow.postMessage(message, targetOrigin, [transfer]);</p>
</blockquote>
<ul>
<li>
<p>otherWindow<br>
其他窗口的一个引用，比如<code>iframe</code>的<code>contentWindow</code>属性、执行<code>window.open</code>返回的窗口对象、或者是命名过或数值索引的<code>window.frames</code>。</p>
</li>
<li>
<p>message<br>
将要发送到其他<code>window</code>的数据。该参数可传入一个<code>Object</code>.</p>
</li>
<li>
<p>targetOrigin<br>
通过窗口的<code>origin</code>属性来指定哪些窗口能接收到消息事件，其值可以是字符串<code>*</code>（表示无限制）或者<code>一个URI</code>。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配<code>targetOrigin</code>提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用<code>postMessage</code>传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的<code>origin</code>属性完全一致，来防止密码被恶意的第三方截获。如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的<code>targetOrigin</code>，而不是<code>*</code>。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。</p>
</li>
<li>
<p>transfer 可选<br>
是一串和<code>message</code>同时传递的<code>Transferable</code>对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</p>
</li>
</ul>
<p>举例来说，父窗口<code>http://a.com</code>向子窗口<code>http://b.com</code>发消息，调用<code>postMessage</code>方法就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父窗口中</span></span><br><span class="line"><span class="keyword">var</span> popup = <span class="built_in">window</span>.open(<span class="string">'http://b.com'</span>, <span class="string">'title'</span>);</span><br><span class="line">popup.postMessage(<span class="string">'Hello World!'</span>, <span class="string">'http://b.com'</span>);</span><br></pre></td></tr></table></figure>
<p>子窗口向父窗口发送消息的写法类似。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子窗口中</span></span><br><span class="line"><span class="built_in">window</span>.opener.postMessage(<span class="string">'I get!'</span>, <span class="string">'http://a.com'</span>);</span><br></pre></td></tr></table></figure>
<p>父窗口和子窗口都可以通过message事件，监听对方的消息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.data);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p><code>message</code>事件的事件对象<code>event</code>，提供以下三个属性。</p>
<blockquote>
<ul>
<li>event.source：对发送消息的窗口对象的引用；可以使用此来在具有不同<code>origin</code>的两个窗口之间建立双向通信。</li>
<li>event.origin：调用<code>postMessage</code>时消息发送方窗口的<code>origin</code>。这个字符串由<code>协议</code>、<code>://</code>、<code>域名</code>、<code>:端口号</code>拼接而成。这个<code>origin</code>不能保证是该窗口的<code>当前或未来origin</code>，因为<code>postMessage</code>被调用后可能被导航到不同的位置。</li>
<li>event.data：从其他<code>window</code>中传递过来的消息内容对象。</li>
</ul>
</blockquote>
<p>子窗口可以通过<code>event.source</code>属性引用父窗口，然后发送消息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子窗口中</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, receiveMessage);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.source.postMessage(<span class="string">'Nice to see you!'</span>, <span class="string">'*'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>event.origin</code>属性可以过滤不是发给本窗口的消息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, receiveMessage);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.origin !== <span class="string">'http://aaa.com'</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (event.data === <span class="string">'Hello World'</span>) &#123;</span><br><span class="line">      event.source.postMessage(<span class="string">'Hello'</span>, event.origin);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：任何窗口可以在任何其他窗口访问此方法，在任何时间，无论文档在窗口中的位置，向其发送消息。 因此，用于接收消息的任何事件监听器<code>必须</code>首先使用<code>origin</code>和<code>source</code>属性来检查消息的发送者的身份。<strong>无法检查origin和source属性会导致跨站点脚本攻击。</strong></p>
<p>因为有了<code>window.postMessage</code>，读写其他窗口的<code>LocalStorage</code>也成为了可能。</p>
<p>下面是一个例子，主窗口写入iframe子窗口的<code>localStorage</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子窗口中</span></span><br><span class="line"><span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.origin !== <span class="string">'http://aaa.com'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> payload = <span class="built_in">JSON</span>.parse(e.data);</span><br><span class="line">  localStorage.setItem(payload.key, <span class="built_in">JSON</span>.stringify(payload.data));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，子窗口将父窗口发来的消息，写入自己的<code>localStorage</code>。</p>
<p>父窗口发送消息的代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> win = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'iframe'</span>)[<span class="number">0</span>].contentWindow;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'Jack'</span> &#125;;</span><br><span class="line">win.postMessage(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">key</span>: <span class="string">'storage'</span>, <span class="attr">data</span>: obj&#125;), <span class="string">'http://bbb.com'</span>);</span><br></pre></td></tr></table></figure>
<p>加强版的子窗口接收消息的代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.origin !== <span class="string">'http://aaa.com'</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">var</span> payload = <span class="built_in">JSON</span>.parse(e.data);</span><br><span class="line">  <span class="keyword">switch</span> (payload.method) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'set'</span>:</span><br><span class="line">      localStorage.setItem(payload.key, <span class="built_in">JSON</span>.stringify(payload.data));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'get'</span>:</span><br><span class="line">      <span class="keyword">var</span> parent = <span class="built_in">window</span>.parent;</span><br><span class="line">      <span class="keyword">var</span> data = localStorage.getItem(payload.key);</span><br><span class="line">      parent.postMessage(data, <span class="string">'http://aaa.com'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'remove'</span>:</span><br><span class="line">      localStorage.removeItem(payload.key);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>加强版的父窗口发送消息代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> win = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'iframe'</span>)[<span class="number">0</span>].contentWindow;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'Jack'</span> &#125;;</span><br><span class="line"><span class="comment">// 存入对象</span></span><br><span class="line">win.postMessage(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">key</span>: <span class="string">'storage'</span>, <span class="attr">method</span>: <span class="string">'set'</span>, <span class="attr">data</span>: obj&#125;), <span class="string">'http://bbb.com'</span>);</span><br><span class="line"><span class="comment">// 读取对象</span></span><br><span class="line">win.postMessage(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">key</span>: <span class="string">'storage'</span>, <span class="attr">method</span>: <span class="string">'get'</span>&#125;), <span class="string">'http://bbb.com'</span>);</span><br><span class="line"><span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.origin != <span class="string">'http://bbb.com'</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// "Jack"</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(e.data).name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="ajax">AJAX</h1>
<p>同源策略规定，AJAX请求只能发给同源的网址，否则就报错。<br>
规避这个限制有以下几种方法：</p>
<blockquote>
<ul>
<li>使用Flash插件发送HTTP请求</li>
<li>架设服务器代理</li>
<li>JSONP</li>
<li>WebSocket</li>
<li>CORS</li>
</ul>
</blockquote>
<h2 id="shi-yong-flash-cha-jian-fa-song-http-qing-qiu"><a class="header-anchor" href="#使用flash插件发送http请求">¶</a>使用Flash插件发送HTTP请求</h2>
<p>这种方式可以绕过浏览器的安全限制，但必须安装Flash，并且跟Flash交互。不过Flash用起来麻烦，而且现在用得也越来越少了。</p>
<h2 id="jia-she-fu-wu-qi-dai-li"><a class="header-anchor" href="#架设服务器代理">¶</a>架设服务器代理</h2>
<p>在同源域名下架设一个代理服务器来转发，JavaScript负责把请求发送到代理服务器：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">'/proxy?url=http://www.sina.com.cn'</span><br></pre></td></tr></table></figure>
<p>代理服务器再把结果返回，这样就遵守了浏览器的同源策略。这种方式麻烦之处在于需要服务器端额外做开发。</p>
<h2 id="jsonp"><a class="header-anchor" href="#jsonp">¶</a>JSONP</h2>
<p>JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。</p>
<p>它的基本思想是，网页通过添加一个<code>&lt;script&gt;</code>标签，向服务器请求JSON数据，这种做法不受同源策略限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。它有个限制，<code>只能</code>用<code>GET</code>请求，并且要求返回JavaScript。（因为<code>&lt;script&gt;</code>标签只能使用<code>GET</code>加载资源）</p>
<p>JSONP通常以函数调用的形式返回。例如，调用某一接口，返回JavaScript内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo(&#123;<span class="attr">test</span>: <span class="string">"hello"</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>因此我们需要首先在页面中准备好回调函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    alert(data.test);</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用另一函数<code>getData()</code>触发：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPrice</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.src = <span class="string">'http://api.a.com/?callback=foo'</span>; <span class="comment">// 注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。一般参数名由API接口确定，常用为callback。</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>&lt;script&gt;</code>标签请求的脚本，直接作为代码运行。这时，只要浏览器定义了<code>foo</code>函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用<code>JSON.parse</code>的步骤。</p>
<h2 id="web-socket"><a class="header-anchor" href="#websocket">¶</a>WebSocket</h2>
<p>WebSocket是一种通信协议，使用<code>ws://</code>（非加密）和<code>wss://</code>（加密）作为协议前缀。该协议不实行同源策略，只要服务器支持，就可以通过它进行跨源通信。</p>
<p>下面是一个例子，浏览器发出的WebSocket请求的头信息（摘自<a href="https://en.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">维基百科</a>）。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/chat</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span>: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span>: chat, superchat</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span>: 13</span><br><span class="line"><span class="attribute">Origin</span>: http://example.com</span><br></pre></td></tr></table></figure>
<p>上面代码中，有一个字段是<code>Origin</code>，表示该请求的请求源（origin），即发自哪个域名。</p>
<p>正是因为有了<code>Origin</code>这个字段，所以WebSocket才没有实行同源策略。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span>: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span>: chat</span><br></pre></td></tr></table></figure>
<h2 id="cors"><a class="header-anchor" href="#cors">¶</a>CORS</h2>
<p>CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源，是跨源AJAX请求的根本解决方法。相比JSONP只能发<code>GET</code>请求，CORS允许任何类型的请求。</p>
<p><code>Origin</code>表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如<code>sina.com</code>）发起请求后，浏览器收到响应后，首先检查<code>Access-Control-Allow-Origin</code>是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。</p>
<p>详细的介绍，可以参考<a href="/2019/04/03/cors/">此文</a></p>
<h1 id="can-kao">参考</h1>
<p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">浏览器同源政策及其规避方法 - 阮一峰</a><br>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">浏览器的同源策略 - MDN</a><br>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="noopener">window.postMessage - MDN</a><br>
<a href="https://newsn.net/say/window-name-msg.html" target="_blank" rel="noopener">window.name 跨域隐式传递消息原理解析 - 苏南大叔</a><br>
<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499861493e7c35be5e0864769a2c06afb4754acc6000" target="_blank" rel="noopener">AJAX - 廖雪峰</a></p>
]]></content>
      <tags>
        <tag>同源策略</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
