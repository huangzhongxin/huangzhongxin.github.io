<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode题解|279. Perfect Squares</title>
    <url>/2019/04/14/6ece669a4e3a/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode.com/problems/perfect-squares/">279. Perfect Squares</a></p>
</blockquote>
<h1 id="概述"><a class="header-anchor" href="#概述"></a>概述</h1>
<p>本题目要求将一个给定的数<code>n</code>拆分为若干个平方数的和，求最小拆分数。</p>
<span id="more"></span>
<h1 id="思路"><a class="header-anchor" href="#思路"></a>思路</h1>
<p>这个题目可以用动态规划来做。</p>
<p>dp[i]代表组成i的最少平方数的个数，这个值最大就是它本身（看作都由1组成）。<br>
而组成这个数的最小值要么就是本身，要么就是前面某一个数+一个平方数（所以看作值加上1）<br>
所以状态转移方程为：<code>dp[i] = min(dp[i - j * j] + 1, dp[i])</code>（其中 j &lt; sqrt(i）)<br>
有转移方程后代码就很好写了。</p>
<p>这个题目还有另外一个解法，是<a href="https://zh.wikipedia.org/wiki/%E5%9B%9B%E5%B9%B3%E6%96%B9%E5%92%8C%E5%AE%9A%E7%90%86">四平方和定理</a>（好吧，我没听过，读者有兴趣可以自己研究下）</p>
<h1 id="实现"><a class="header-anchor" href="#实现"></a>实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numSquares = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        dp[i] = n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> sqrt = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">sqrt</span>(i));</span><br><span class="line">        <span class="keyword">if</span>(sqrt * sqrt == i)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= sqrt; j++)&#123;</span><br><span class="line">            dp[i] = <span class="title class_">Math</span>.<span class="title function_">min</span>(dp[i], dp[i - j * j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|1017. Convert to Base -2</title>
    <url>/2019/04/13/a15c32f3b841/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode.com/problems/convert-to-base-2/">1017. Convert to Base -2</a></p>
</blockquote>
<h1 id="概述-v2"><a class="header-anchor" href="#概述-v2"></a>概述</h1>
<p>这个题目要求很简单，就是实现一个十进制到负二进制的转换。</p>
<span id="more"></span>
<h1 id="思路-v2"><a class="header-anchor" href="#思路-v2"></a>思路</h1>
<p>在实现前，先回顾下进制转换的方法：<strong>除k取余法</strong></p>
<p>以十进制下的<code>N = 5</code>转为二进制为例：<br>
第一步：5整除2，商为2，余1；<br>
第二步：2整除2，商为1，余0；<br>
第三步：1整除2，商为0，余1；<br>
由于到第三步时商已经等于0，故算法结束。所以，5<sub>10</sub>=101<sub>2</sub></p>
<p>进一步，我们可以使用<code>位运算</code>来取余数或做除法。</p>
<blockquote>
<p>设X对Y求余，Y等于2<sup>N</sup>，公式为：X &amp; (2<sup>N</sup> - 1) 或 X&amp;(~Y)。</p>
</blockquote>
<p>因此，在求余数的时候，我们只要使用<code>N &amp; 1</code>即可。完整的二进制转换代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">N</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> base2 = <span class="keyword">function</span>(<span class="params">N</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> remainders = [];</span><br><span class="line">    <span class="keyword">while</span>(N != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> x = N &amp; <span class="number">1</span>;</span><br><span class="line">        remainders.<span class="title function_">push</span>(x);</span><br><span class="line">        N = N &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> remainders.<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>前面举的例子都是二进制的，那负二进制呢？类似的，我们在转换为负二进制时，只需要将除数改为<code>-2</code>即可。</p>
<h1 id="实现-v2"><a class="header-anchor" href="#实现-v2"></a>实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">N</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> baseNeg2 = <span class="keyword">function</span>(<span class="params">N</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> remainders = [];</span><br><span class="line">    <span class="keyword">while</span>(N != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> x = N &amp; <span class="number">1</span>;</span><br><span class="line">        remainders.<span class="title function_">push</span>(x);</span><br><span class="line">        N = -(N &gt;&gt; <span class="number">1</span>); <span class="comment">// 注意这里多了个负号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> remainders.<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|143. Reorder List</title>
    <url>/2019/04/13/6a9db7dd2bc2/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode.com/problems/reorder-list/">143. Reorder List</a></p>
</blockquote>
<h1 id="概述-v3"><a class="header-anchor" href="#概述-v3"></a>概述</h1>
<p>给定一个单链表<code>L</code>: L<sub>0</sub>→L<sub>1</sub>→…→L<sub>n-1</sub>→L<sub>n</sub>，将其重排为：L<sub>0</sub>→L<sub>n</sub>→L<sub>1</sub>→L<sub>n-1</sub>→L<sub>2</sub>→L<sub>n-2</sub>→…，即将<code>L</code>头尾交替重排序。</p>
<span id="more"></span>
<h1 id="思路-v3"><a class="header-anchor" href="#思路-v3"></a>思路</h1>
<p>整体四里路为：先将<code>L</code>一分为二，然后将后半段链表逆序，再依次插入前半段节点中。</p>
<p>在找链表的中间节点时，使用<code>快慢指针</code>就可以快速找到。</p>
<p>逆序时，将当前节点的后继节点进行位置交换，举例来说，给定链表<code>l</code>:head→b→c→d。首先，将<code>b</code>的后继，改为原后继<code>c</code>的后继<code>d</code>，即：head→b→d，然后将<code>c</code>指向<code>b</code>，<code>head</code>指向<code>c</code>，即：head→c→b→d</p>
<h1 id="实现-v3"><a class="header-anchor" href="#实现-v3"></a>实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify head in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reorderList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span> || head.<span class="property">next</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> fast = head,</span><br><span class="line">        slow = head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到中间节点</span></span><br><span class="line">    <span class="keyword">while</span>(fast.<span class="property">next</span> != <span class="literal">null</span> &amp;&amp; fast.<span class="property">next</span>.<span class="property">next</span> != <span class="literal">null</span>)&#123;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">        fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> middle = slow,</span><br><span class="line">        cur = slow.<span class="property">next</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 反转后半段链表</span></span><br><span class="line">    <span class="keyword">while</span>(cur.<span class="property">next</span> != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> tmp = cur.<span class="property">next</span>;</span><br><span class="line">        cur.<span class="property">next</span> = tmp.<span class="property">next</span>;</span><br><span class="line">        tmp.<span class="property">next</span> = middle.<span class="property">next</span>;</span><br><span class="line">        middle.<span class="property">next</span> = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拼接</span></span><br><span class="line">    <span class="keyword">var</span> p1 = head,</span><br><span class="line">        p2 = slow.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1 != slow)&#123;</span><br><span class="line">        slow.<span class="property">next</span> = p2.<span class="property">next</span>;</span><br><span class="line">        p2.<span class="property">next</span> = p1.<span class="property">next</span>;</span><br><span class="line">        p1.<span class="property">next</span> = p2;</span><br><span class="line">        p1 = p2.<span class="property">next</span>;</span><br><span class="line">        p2 = slow.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|26. 删除排序数组中的重复项</title>
    <url>/2019/09/08/3bc9566ce6dd/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/description/">26. 删除排序数组中的重复项</a></p>
</blockquote>
<h1 id="概述-v4"><a class="header-anchor" href="#概述-v4"></a>概述</h1>
<p>题目给定一个排序数组，需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<span id="more"></span>
<h1 id="思路-v4"><a class="header-anchor" href="#思路-v4"></a>思路</h1>
<p>使用双指针<code>p1</code>、<code>p2</code>，其中<code>p1</code>是慢指针、<code>p2</code>是快指针。<br>
如果<code>nums[p1] === nums[p2]</code>，我们就增加<code>p2</code>跳过重复项<br>
如果<code>nums[p1] !== nums[p2]</code>，说明已经跳过了所有重复项，所以我们需要把<code>nums[p2]</code>的值复制到<code>nums[p1 + 1]</code>中，并把<code>p1</code>往后移动。<br>
直到<code>p2 === nums.length</code>时，算法结束。<br>
因为<code>p1</code>指向的是不重复项的最后一个，因此，最终的数组长度就是<code>p1 + 1</code>。</p>
<h1 id="实现-v4"><a class="header-anchor" href="#实现-v4"></a>实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="property">length</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="property">length</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> p1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> p2 = <span class="number">0</span>; p2 &lt; nums.<span class="property">length</span>; p2++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[p1] !== nums[p2]) &#123;</span><br><span class="line">            p1++</span><br><span class="line">            nums[p1] = nums[p2]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1 + <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|27. 移除元素</title>
    <url>/2019/09/08/7ce90f7081ae/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode-cn.com/problems/remove-element/description/">27. 移除元素</a></p>
</blockquote>
<h1 id="概述-v5"><a class="header-anchor" href="#概述-v5"></a>概述</h1>
<p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p>
<span id="more"></span>
<h1 id="思路-v5"><a class="header-anchor" href="#思路-v5"></a>思路</h1>
<p>解法与<a href="http://localhost:4000/2019/09/08/LeetCode%E9%A2%98%E8%A7%A3-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/">LeetCode题解|26. 删除排序数组中的重复项</a>类似。</p>
<p>使用双指针<code>p1</code>、<code>p2</code>，其中<code>p1</code>是慢指针、<code>p2</code>是快指针。<br>
如果<code>val === nums[p2]</code>，我们就增加<code>p2</code>跳过这个目标值<br>
如果<code>val !== nums[p2]</code>，说明已经跳过了所有目标值，所以我们需要把<code>nums[p2]</code>的值复制到<code>nums[p1]</code>中，并把<code>p1</code>往后移动。<br>
直到<code>p2 === nums.length</code>时，算法结束。</p>
<h1 id="实现-v5"><a class="header-anchor" href="#实现-v5"></a>实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElement = <span class="keyword">function</span>(<span class="params">nums, val</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> p2 = <span class="number">0</span>; p2 &lt; nums.<span class="property">length</span>; p2++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val !== nums[p2]) &#123;</span><br><span class="line">            nums[p1] = nums[p2]</span><br><span class="line">            p1++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|28. 实现strStr()</title>
    <url>/2019/09/08/4cf06c17e5f0/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode-cn.com/problems/implement-strstr/description/">28. 实现strStr()</a></p>
</blockquote>
<h1 id="概述-v6"><a class="header-anchor" href="#概述-v6"></a>概述</h1>
<p>给定一个<code>haystack</code>字符串和一个<code>needle</code>字符串，在<code>haystack</code>字符串中找出<code>needle</code>字符串出现的第一个位置 (从0开始)。如果不存在，则返回<code>-1</code>。</p>
<span id="more"></span>
<h1 id="思路-v6"><a class="header-anchor" href="#思路-v6"></a>思路</h1>
<p>字符串匹配，有这么几种方法：<a href="https://baike.baidu.com/item/BF%E7%AE%97%E6%B3%95">BF算法</a>、<a href="https://blog.csdn.net/xlxxcc/article/details/64125265">RK算法</a>、<a href="http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html">BM算法</a>、<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">KMP算法</a></p>
<p>本文使用了最简单的BF算法，击败了90.34%的JavaScript提交记录。</p>
<h1 id="实现-v6"><a class="header-anchor" href="#实现-v6"></a>实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">haystack</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">needle</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> strStr = <span class="keyword">function</span>(<span class="params">haystack, needle</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (needle === <span class="string">&#x27;&#x27;</span> || needle === haystack) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> needleLen = needle.<span class="property">length</span></span><br><span class="line">    <span class="keyword">const</span> hayLen = haystack.<span class="property">length</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= hayLen - needleLen; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack.<span class="title function_">slice</span>(i, needleLen + i) === needle) &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|380. Insert Delete GetRandom O(1)</title>
    <url>/2019/04/13/528b97ca9c4f/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode.com/problems/insert-delete-getrandom-o1/">380. Insert Delete GetRandom O(1)</a></p>
</blockquote>
<h1 id="概述-v7"><a class="header-anchor" href="#概述-v7"></a>概述</h1>
<p>这个题目要求设计一个数据结构，使得能够在<code>O(1)</code>时间内完成插入、删除、随机获取。</p>
<span id="more"></span>
<h1 id="思路-v7"><a class="header-anchor" href="#思路-v7"></a>思路</h1>
<p>看到这个要求，很自然就想到了数组。但是单纯数组并不能满足题目中要求的如果存在值才可删除/不可插入，为此，可以引入一个<code>Map</code>，用于保存数组中值的位置情况。</p>
<p>插入时，先在<code>map</code>中查找下是否存在<code>val</code>，若存在，则按题目要求，返回<code>false</code>，否则在数组尾部插入该值，并且在<code>map</code>中记录其位置。</p>
<p>删除时，同样是去<code>map</code>中查找下是否存在<code>val</code>，若不存在，也是按题目要求，返回<code>false</code>，否则的话，将数组最后一个元素<code>last</code>放到<code>val</code>的位置上，同时更新<code>last</code>在<code>map</code>中的索引，最后将数组最后一个元素删除掉。</p>
<h1 id="实现-v7"><a class="header-anchor" href="#实现-v7"></a>实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize your data structure here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">RandomizedSet</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">set</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">map</span> = &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts a value to the set. Returns true if the set did not already contain the specified element. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">RandomizedSet</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">insert</span> = <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(val <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">map</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">set</span>.<span class="title function_">push</span>(val);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">map</span>[val] = <span class="variable language_">this</span>.<span class="property">set</span>.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes a value from the set. Returns true if the set contained the specified element. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">RandomizedSet</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!(val <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">map</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> last = <span class="variable language_">this</span>.<span class="property">set</span>.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="property">map</span>[val];</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">map</span>[val];</span><br><span class="line">    <span class="keyword">if</span>(val !== last)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">set</span>[index] = last;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">map</span>[last] = index;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get a random element from the set.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">RandomizedSet</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getRandom</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> rand = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="variable language_">this</span>.<span class="property">set</span>.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">set</span>[rand]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new RandomizedSet()</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.insert(val)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.remove(val)</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.getRandom()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|3. Longest Substring Without Repeating Characters</title>
    <url>/2019/04/13/e0a786f5abe7/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">3. Longest Substring Without Repeating Characters</a></p>
</blockquote>
<h1 id="概述-v8"><a class="header-anchor" href="#概述-v8"></a>概述</h1>
<p>这个题目给定一个字符串<code>s</code>，找出其中不含有重复字符的<code>最长子串</code>的长度。</p>
<span id="more"></span>
<h1 id="思路-v8"><a class="header-anchor" href="#思路-v8"></a>思路</h1>
<p>该题目可使用 <a href="https://www.zhihu.com/question/314669016">滑动窗口</a> 来做。</p>
<p>具体来说，使用两个指针<code>left</code>、<code>right</code>来确定出一个子串的范围，如果<code>s[right]</code>已经在<code>s[left...right-1]</code>中出现过，则将<code>left</code>向右挪，反之则将<code>right</code>向右挪，直到<code>right</code>到达<code>s</code>结尾。</p>
<p>通过这样对<code>s</code>进行一次扫描，即可得到最长子串。</p>
<h1 id="实现-v8"><a class="header-anchor" href="#实现-v8"></a>实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span>,</span><br><span class="line">        right = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt;= s.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(maxLength &lt; right - left)&#123;</span><br><span class="line">            maxLength = right - left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="title function_">substring</span>(left, right).<span class="title function_">indexOf</span>(s[right]) != -<span class="number">1</span>)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|687. Longest Univalue Path</title>
    <url>/2019/04/13/71e5292a45b8/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode.com/problems/longest-univalue-path/">687. Longest Univalue Path</a></p>
</blockquote>
<h1 id="概述-v9"><a class="header-anchor" href="#概述-v9"></a>概述</h1>
<p>给定一棵二叉树，找出树中有相同值的最长路径长度。</p>
<span id="more"></span>
<h1 id="思路-v9"><a class="header-anchor" href="#思路-v9"></a>思路</h1>
<p>使用<code>DFS</code>，找出每个节点的左右子树左右两边的最长路径值<code>lr</code>，如果当前节点与左(右)子树的节点值相等，则将当前节点的左(右)值定为左(右)子树<code>lr</code>中的最大值+1。</p>
<h1 id="实现-v9"><a class="header-anchor" href="#实现-v9"></a>实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestUnivaluePath = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> dfs = <span class="keyword">function</span>(<span class="params">node</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span> || (node.<span class="property">left</span> == <span class="literal">null</span> &amp;&amp; node.<span class="property">right</span> == <span class="literal">null</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">left</span>: <span class="number">0</span>, <span class="attr">right</span>: <span class="number">0</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> &#123; <span class="attr">left</span>: ll, <span class="attr">right</span>: lr &#125; = <span class="title function_">dfs</span>(node.<span class="property">left</span>);</span><br><span class="line">        <span class="keyword">const</span> &#123; <span class="attr">left</span>: rl, <span class="attr">right</span>: rr &#125; = <span class="title function_">dfs</span>(node.<span class="property">right</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">0</span>,</span><br><span class="line">            right = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">left</span> != <span class="literal">null</span> &amp;&amp; node.<span class="property">val</span> == node.<span class="property">left</span>.<span class="property">val</span>)&#123;</span><br><span class="line">            left = <span class="title class_">Math</span>.<span class="title function_">max</span>(ll, lr) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">right</span> != <span class="literal">null</span> &amp;&amp; node.<span class="property">val</span> == node.<span class="property">right</span>.<span class="property">val</span>)&#123;</span><br><span class="line">            right = <span class="title class_">Math</span>.<span class="title function_">max</span>(rl, rr) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxLength = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLength, left + right);</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">left</span>: left, <span class="attr">right</span>: right &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">dfs</span>(root);</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|652. Find Duplicate Subtrees</title>
    <url>/2019/04/14/7c284718bf2a/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode.com/problems/find-duplicate-subtrees/">652. Find Duplicate Subtrees</a></p>
</blockquote>
<h1 id="概述-v10"><a class="header-anchor" href="#概述-v10"></a>概述</h1>
<p>本题给定一棵二叉树，要求找出所有的重复子树。</p>
<span id="more"></span>
<h1 id="思路-v10"><a class="header-anchor" href="#思路-v10"></a>思路</h1>
<p>对这棵树进行<code>前序遍历</code>，如果某一子树的前序遍历序列已经出现过，说明这棵子树是重复出现的，将其加入结果集即可。</p>
<h1 id="实现-v10"><a class="header-anchor" href="#实现-v10"></a>实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findDuplicateSubtrees = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> map = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">preorder</span> = (<span class="params">node</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> vs = <span class="title function_">preorder</span>(node.<span class="property">left</span>) + <span class="title function_">preorder</span>(node.<span class="property">right</span>) + node.<span class="property">val</span>;</span><br><span class="line">        <span class="keyword">if</span>(map[vs])&#123;</span><br><span class="line">            <span class="keyword">if</span>(map[vs] == <span class="number">1</span>)&#123;</span><br><span class="line">                result.<span class="title function_">push</span>(node);</span><br><span class="line">            &#125;</span><br><span class="line">            map[vs] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            map[vs] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">preorder</span>(root);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|775. Global and Local Inversions</title>
    <url>/2019/04/16/745f322d3641/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode.com/problems/global-and-local-inversions/">775. Global and Local Inversions</a></p>
</blockquote>
<h1 id="概述-v11"><a class="header-anchor" href="#概述-v11"></a>概述</h1>
<p>题目给定一个长度为<code>N</code>的数组<code>A</code>，为<code>[0, 1, ..., N - 1]</code>的一种排列。<code>全局倒置</code>指的是 <code>i,j</code> 满足 <code>0 &lt;= i &lt; j &lt; N 并且 A[i] &gt; A[j]</code> ，<code>局部倒置</code>指的是<code>i</code>满足 <code>0 &lt;= i &lt; N 并且 A[i] &gt; A[i+1]</code> 。问该数组的全局倒置是否等于局部倒置。</p>
<span id="more"></span>
<h1 id="思路-v11"><a class="header-anchor" href="#思路-v11"></a>思路</h1>
<p>这个问题暴力求解也很好办，按照题目要求扫描下数组即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">A</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isIdealPermutation = <span class="keyword">function</span>(<span class="params">A</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> local = <span class="number">0</span>,</span><br><span class="line">        <span class="variable language_">global</span> = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; A.<span class="property">length</span> - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt; A[i + <span class="number">1</span>])&#123;</span><br><span class="line">            local++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; A.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; A.<span class="property">length</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &gt; A[j])&#123;</span><br><span class="line">                <span class="variable language_">global</span>++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">global</span> === local;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这段代码的时间复杂度为 O(n<sup>2</sup>)，只能beat 30%，有点慢。考虑下优化。</p>
<p>题目的两个条件可以总结为：</p>
<blockquote>
<p>当<code>0 &lt;= i &lt; i + k &lt; N 并且 A[i] &gt; A[i + k]</code>时，则存在<code>倒置</code>。若<code>k = 1</code>，则为<code>local</code>，若<code>k ≥ 1</code>，则为<code>global</code>。</p>
</blockquote>
<p>也就是说，<code>如果存在k &gt; 1，使得A[i] &gt; A[i + k]成立，则 global !== local</code>。</p>
<p>最原始的数组，为<code>[0, 1, 2, ..., i-1, i, i+1, ..., N-1]</code>，即<code>A[i] = i</code>。<br>
假设<code>存在k &gt; 1，使得A[i] &gt; A[i + k]成立</code>，<br>
则 <code>A[i] != i 且 A[i] &gt; i + 1 或 A[i] &lt; i - 1</code>，即<code>|A[i]-i| &gt; 1</code>。</p>
<p>因此，只要遍历一遍数组即可得到答案。</p>
<h1 id="实现-v11"><a class="header-anchor" href="#实现-v11"></a>实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">A</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isIdealPermutation = <span class="keyword">function</span>(<span class="params">A</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; A.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Math</span>.<span class="title function_">abs</span>(A[i] - i) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|971. Flip Binary Tree To Match Preorder Traversal</title>
    <url>/2019/04/13/bb539336b964/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal/">971. Flip Binary Tree To Match Preorder Traversal</a></p>
</blockquote>
<h1 id="概述-v12"><a class="header-anchor" href="#概述-v12"></a>概述</h1>
<p>这个题目给定了一棵有<code>N</code>个节点的二叉树以及一个序列<code>v</code>，问如何翻转最少的节点（交换左右子树），使得前序遍历结果和给定的序列一致。</p>
<span id="more"></span>
<h1 id="思路-v12"><a class="header-anchor" href="#思路-v12"></a>思路</h1>
<p>使用<code>DFS</code>前序遍历这棵树，并且使用一个指针<code>i</code>，记录当前节点<code>node</code>应该和<code>v</code>中的哪个值相等，<code>DFS</code>时，可分为以下三种情况：</p>
<ol>
<li><code>node === null</code>，说明我们已经遍历完了，返回<code>true</code></li>
<li><code>node.val !== v[i]</code>，说明该节点值不是预期的，返回<code>false</code></li>
<li><code>node.left.!== null &amp;&amp; node.left.val !== v[i]</code>，说明左儿子存在但是其值并不是预期的，此时，我们应该翻转<code>node</code>节点，但是我们并不需要真的去修改指针，只要先去遍历右子树，再去遍历左子树，即可达到翻转并且前序遍历的目的。</li>
</ol>
<h1 id="实现-v12"><a class="header-anchor" href="#实现-v12"></a>实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">voyage</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> flipMatchVoyage = <span class="keyword">function</span>(<span class="params">root, voyage</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> dfs = <span class="keyword">function</span>(<span class="params">node</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">val</span> != voyage[i++])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">left</span> != <span class="literal">null</span> &amp;&amp; node.<span class="property">left</span>.<span class="property">val</span> != voyage[i])&#123;</span><br><span class="line">            result.<span class="title function_">push</span>(node.<span class="property">val</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">dfs</span>(node.<span class="property">right</span>) &amp;&amp; <span class="title function_">dfs</span>(node.<span class="property">left</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">dfs</span>(node.<span class="property">left</span>) &amp;&amp; <span class="title function_">dfs</span>(node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">dfs</span>(root) ? result : [-<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|86. Partition List</title>
    <url>/2019/04/14/b7d9d71d848a/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode.com/problems/partition-list/">86. Partition List</a></p>
</blockquote>
<h1 id="概述-v13"><a class="header-anchor" href="#概述-v13"></a>概述</h1>
<p>这个题目给定一个单链表<code>L</code>以及一个整数<code>x</code>，使得所有小于<code>x</code>的节点在大于等于<code>x</code>的节点之前，同时要保证顺序和原链表一致。</p>
<span id="more"></span>
<h1 id="思路-v13"><a class="header-anchor" href="#思路-v13"></a>思路</h1>
<p>这个题目只要创建两个链表，遍历一遍原链表<code>L</code>，将所有节点按照要求，分别插入到两个新链表中，就完成了分隔，紧接着在将两段链表连接起来，即可得到答案。</p>
<h1 id="实现-v13"><a class="header-anchor" href="#实现-v13"></a>实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> partition = <span class="keyword">function</span>(<span class="params">head, x</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> smaller = p1 = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="literal">null</span>),</span><br><span class="line">        larger = p2 = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.<span class="property">val</span> &lt; x)&#123;</span><br><span class="line">            smaller.<span class="property">next</span> = head;</span><br><span class="line">            smaller = smaller.<span class="property">next</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            larger.<span class="property">next</span> = head;</span><br><span class="line">            larger = larger.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    larger.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    smaller.<span class="property">next</span> = p2.<span class="property">next</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> p1.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解|988. Smallest String Starting From Leaf</title>
    <url>/2019/04/16/bcb887aacc56/</url>
    <content><![CDATA[<blockquote>
<p>题目链接：<a href="https://leetcode.com/problems/smallest-string-starting-from-leaf/">988. Smallest String Starting From Leaf</a></p>
</blockquote>
<h1 id="概述-v14"><a class="header-anchor" href="#概述-v14"></a>概述</h1>
<p>题目给定一棵二叉树，每个节点值为<code>0</code>到<code>25</code>的值，分别对应<code>a</code>到<code>z</code>，求树中字典序最小的字符串。</p>
<span id="more"></span>
<h1 id="思路-v14"><a class="header-anchor" href="#思路-v14"></a>思路</h1>
<p>一开始想到的方法，就是去深度遍历，每个节点对应的字符串为<code>min(左子树的字符串 + 当前节点值, 右子树的字符串 + 当前节点值)</code>，</p>
<p>实现代码大致如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> smallestFromLeaf = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">dfs</span> = (<span class="params">node</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(node === <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> leftStr = <span class="title function_">dfs</span>(node.<span class="property">left</span>);</span><br><span class="line">        <span class="keyword">let</span> rightStr = <span class="title function_">dfs</span>(node.<span class="property">right</span>);</span><br><span class="line">        <span class="keyword">let</span> ch = <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">97</span> + node.<span class="property">val</span>);</span><br><span class="line">        <span class="keyword">var</span> ret = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(leftStr == <span class="string">&#x27;&#x27;</span> &amp;&amp; rightStr == <span class="string">&#x27;&#x27;</span>)&#123;</span><br><span class="line">            ret = ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(leftStr == <span class="string">&#x27;&#x27;</span> || rightStr == <span class="string">&#x27;&#x27;</span>)&#123;</span><br><span class="line">            ret = (leftStr != <span class="string">&#x27;&#x27;</span> ? leftStr : rightStr) + ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ret = leftStr + ch &lt; rightStr + ch ? leftStr + ch : rightStr + ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">dfs</span>(root);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是！这段代码只能通过<code>66/67</code>的测试样例，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">25</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>这个无法通过。</p>
<p>在看了<a href="https://leetcode.com/problems/smallest-string-starting-from-leaf/discuss/231102/C%2B%2B-3-lines">评论区</a>大神的说明后，明白了。</p>
<p>考虑 <code>ab</code> 和 <code>abab</code>以及节点值<code>z</code>，显然，<code>ab &lt; abab</code>，<code>abz &gt; ababz</code>。<br>
本测试样例的树如下：<br>
<img src="67.jpg" alt=""><br>
上述代码执行过程如下：<br>
<img src="67-1.jpg" alt=""><br>
错误发生在第二层的节点<code>b</code>处。</p>
<p>如果只以子树的字符串为依据，由于不知道加上父亲节点之后，构成的字典序是否仍是较小的那个，所以在这边发生了错误。</p>
<p>想到这，也好修正了，只需要传入父亲节点的值，即可。</p>
<h1 id="实现-v14"><a class="header-anchor" href="#实现-v14"></a>实现</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> smallestFromLeaf = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">dfs</span> = (<span class="params">node, s</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(node === <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#123;&#x27;</span>;  <span class="comment">// &#123; 的 ascii 码大于 z</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        s = <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">97</span> + node.<span class="property">val</span>) + s;</span><br><span class="line">        <span class="keyword">let</span> leftStr = <span class="title function_">dfs</span>(node.<span class="property">left</span>, s);</span><br><span class="line">        <span class="keyword">let</span> rightStr = <span class="title function_">dfs</span>(node.<span class="property">right</span>, s);</span><br><span class="line">        <span class="keyword">var</span> ret = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(leftStr == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; rightStr == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">            ret = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ret = leftStr &lt; rightStr ? leftStr : rightStr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">dfs</span>(root, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/">题解合集</a></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解集合</title>
    <url>/2019/04/13/1d05c0282088/</url>
    <content><![CDATA[<p>每日来点LeetCode</p>
<span id="more"></span>
<table>
<thead>
<tr>
<th>#</th>
<th>Title</th>
<th>Solution</th>
<th>Difficulty</th>
<th>Tag</th>
</tr>
</thead>
<tbody>
<tr>
<td>380</td>
<td><a href="https://leetcode.com/problems/insert-delete-getrandom-o1/">Insert Delete GetRandom O(1)</a></td>
<td><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3-380-Insert-Delete-GetRandom-O-1/">js</a></td>
<td>Medium</td>
<td>Array</td>
</tr>
<tr>
<td>1017</td>
<td><a href="https://leetcode.com/problems/convert-to-base-2/">Convert to Base -2</a></td>
<td><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3-1017-Convert-to-Base-2/">js</a></td>
<td>Medium</td>
<td>Math</td>
</tr>
<tr>
<td>971</td>
<td><a href="https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal/">Flip Binary Tree To Match Preorder Traversal</a></td>
<td><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3-971-Flip-Binary-Tree-To-Match-Preorder-Traversal/">js</a></td>
<td>Medium</td>
<td>Tree</td>
</tr>
<tr>
<td>3</td>
<td><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">Longest Substring Without Repeating Characters</a></td>
<td><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3-3-Longest-Substring-Without-Repeating-Characters/">js</a></td>
<td>Medium</td>
<td>String</td>
</tr>
<tr>
<td>143</td>
<td><a href="https://leetcode.com/problems/reorder-list/">Reorder List</a></td>
<td><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3-143-Reorder-List/">js</a></td>
<td>Medium</td>
<td>Linked List</td>
</tr>
<tr>
<td>687</td>
<td><a href="https://leetcode.com/problems/longest-univalue-path/">Longest Univalue Path</a></td>
<td><a href="/2019/04/13/LeetCode%E9%A2%98%E8%A7%A3-687-Longest-Univalue-Path/">js</a></td>
<td>Easy</td>
<td>Tree</td>
</tr>
<tr>
<td>86</td>
<td><a href="https://leetcode.com/problems/partition-list/">Partition List</a></td>
<td><a href="/2019/04/14/LeetCode%E9%A2%98%E8%A7%A3-86-Partition-List/">js</a></td>
<td>Medium</td>
<td>Linked List</td>
</tr>
<tr>
<td>652</td>
<td><a href="https://leetcode.com/problems/find-duplicate-subtrees/">Find Duplicate Subtrees</a></td>
<td><a href="/2019/04/14/LeetCode%E9%A2%98%E8%A7%A3-652-Find-Duplicate-Subtrees/">js</a></td>
<td>Medium</td>
<td>Tree</td>
</tr>
<tr>
<td>279</td>
<td><a href="https://leetcode.com/problems/perfect-squares/">Perfect Squares</a></td>
<td><a href="/2019/04/14/LeetCode%E9%A2%98%E8%A7%A3-279-Perfect-Squares/">js</a></td>
<td>Medium</td>
<td>Math</td>
</tr>
<tr>
<td>988</td>
<td><a href="https://leetcode.com/problems/smallest-string-starting-from-leaf/">Smallest String Starting From Leaf</a></td>
<td><a href="/2019/04/16/LeetCode%E9%A2%98%E8%A7%A3-988-Smallest-String-Starting-From-Leaf/">js</a></td>
<td>Medium</td>
<td>Tree</td>
</tr>
<tr>
<td>775</td>
<td><a href="https://leetcode.com/problems/global-and-local-inversions/">Global and Local Inversions</a></td>
<td><a href="/2019/04/16/LeetCode%E9%A2%98%E8%A7%A3-775-Global-and-Local-Inversions/">js</a></td>
<td>Medium</td>
<td>Tree</td>
</tr>
<tr>
<td>26</td>
<td><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/description/">删除排序数组中的重复项</a></td>
<td><a href="/2019/09/08/LeetCode%E9%A2%98%E8%A7%A3-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/">js</a></td>
<td>Easy</td>
<td>Array</td>
</tr>
<tr>
<td>27</td>
<td><a href="https://leetcode-cn.com/problems/remove-element/description/">移除元素</a></td>
<td><a href="/2019/09/08/LeetCode%E9%A2%98%E8%A7%A3-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/">js</a></td>
<td>Easy</td>
<td>Array</td>
</tr>
<tr>
<td>28</td>
<td><a href="https://leetcode-cn.com/problems/implement-strstr/description/">实现strStr()</a></td>
<td><a href="/2019/09/08/LeetCode%E9%A2%98%E8%A7%A3-28-%E5%AE%9E%E7%8E%B0strStr/">js</a></td>
<td>Easy</td>
<td>String</td>
</tr>
</tbody>
</table>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>arts-week-1</title>
    <url>/2019/09/02/7b3aae1ae03e/</url>
    <content><![CDATA[<h1 id="Algorithm"><a class="header-anchor" href="#Algorithm"></a>Algorithm</h1>
<p>本周完成了LeetCode的三题简单题：</p>
<table>
<thead>
<tr>
<th>#</th>
<th>Title</th>
<th>Solution</th>
<th>Difficulty</th>
<th>Tag</th>
</tr>
</thead>
<tbody>
<tr>
<td>26</td>
<td><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/description/">删除排序数组中的重复项</a></td>
<td><a href="/2019/09/08/LeetCode%E9%A2%98%E8%A7%A3-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/">js</a></td>
<td>Easy</td>
<td>Array</td>
</tr>
<tr>
<td>27</td>
<td><a href="https://leetcode-cn.com/problems/remove-element/description/">移除元素</a></td>
<td><a href="/2019/09/08/LeetCode%E9%A2%98%E8%A7%A3-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/">js</a></td>
<td>Easy</td>
<td>Array</td>
</tr>
<tr>
<td>28</td>
<td><a href="https://leetcode-cn.com/problems/implement-strstr/description/">实现strStr()</a></td>
<td><a href="/2019/09/08/LeetCode%E9%A2%98%E8%A7%A3-28-%E5%AE%9E%E7%8E%B0strStr/">js</a></td>
<td>Easy</td>
<td>String</td>
</tr>
</tbody>
</table>
<h1 id="Review"><a class="header-anchor" href="#Review"></a>Review</h1>
<p>本周看了ES6 In Depth的第一篇：<a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/">Iterators and the for-of loop</a></p>
<p>本文主要对比了js中几种for循环各自的特点，着重介绍了迭代器<code>Iterators</code>和<code>for...of</code>。<br>
只要实现了<code>[Symbol.iterator]</code>及<code>next()</code>方法的对象，都可以使用<code>for...of</code>进行迭代。<br>
<code>[Symbol.iterator]</code>方法返回一个可迭代对象，而<code>next()</code>方法返回一个形如<code>&#123; done: false, value: 1 &#125;</code>的对象。<br>
在使用<code>for...of</code>循环时，首先会调用<code>[Symbol.iterator]</code>方法，得到一个可迭代对象，然后不断执行<code>next()</code>方法，直到<code>next().done === true</code>就会停止循环。</p>
<h1 id="Tip"><a class="header-anchor" href="#Tip"></a>Tip</h1>
<ol>
<li>javascript中的<code>for</code>、<code>for...in</code>、<code>for...of</code>、<code>while</code>、<code>do...while</code>均不能使用<code>return</code>语句，会报错<code>SyntaxError: Illegal return statement</code>。</li>
<li>git中，可以使用<code>git stash</code>将代码存到暂存区中，然后就可以放心的切换到其他分支了。使用<code>git stash pop</code>可以将暂存区中的代码恢复。参见：<a href="https://blog.csdn.net/qq_32452623/article/details/76100140">这篇文章</a></li>
</ol>
<h1 id="Share"><a class="header-anchor" href="#Share"></a>Share</h1>
<p>本周看了<a href="/2019/09/03/js%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8Dfor%E5%BE%AA%E7%8E%AF">js中的几种for循环</a>，了解了几种循环的区别。</p>
]]></content>
      <tags>
        <tag>arts</tag>
      </tags>
  </entry>
  <entry>
    <title>CORS</title>
    <url>/2019/04/03/9e7f864c7380/</url>
    <content><![CDATA[<p><strong>CORS</strong>是一个W3C标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）。它允许浏览器向跨域服务器，发出<code>XMLHttpRequest</code>请求，从而克服了AJAX只能同源使用的限制。<br>
本文介绍了CORS的内部机制。</p>
<span id="more"></span>
<h1 id="简介"><a class="header-anchor" href="#简介"></a>简介</h1>
<p>CORS需要浏览器和服务器同时支持。目前，主流浏览器都已基本提供对跨域资源共享的支持，移动端浏览器也几乎全部支持。<br>
<img src="support_browsers.png" alt="浏览器对CORS的支持情况"></p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<h1 id="什么情况下需要CORS？"><a class="header-anchor" href="#什么情况下需要CORS？"></a>什么情况下需要CORS？</h1>
<blockquote>
<ul>
<li>由<code>XMLHttpRequest</code>或<code>Fetch</code>发起的跨域 HTTP 请求。</li>
<li>Web 字体 (CSS 中通过<code>@font-face</code>使用跨域字体资源)</li>
<li>使用<code>drawImage</code>将<code>Images/video</code>画面绘制到<code>canvas</code></li>
</ul>
</blockquote>
<p>例如，当你引用了某个第三方CDN上的字体文件时：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* CSS */</span></span><br><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;FontAwesome&#x27;</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;http://cdn.com/fonts/fontawesome.ttf&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;truetype&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果该CDN服务商未正确设置<code>Access-Control-Allow-Origin</code>，那么浏览器无法加载字体资源。</p>
<h1 id="两种请求"><a class="header-anchor" href="#两种请求"></a>两种请求</h1>
<p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>若请求满足以下条件，则该请求属于简单请求：</p>
<blockquote>
<ol>
<li>请求方法是下列三种之一：
<ul>
<li>GET</li>
<li>POST</li>
<li>HEAD</li>
</ul>
</li>
<li>HTTP的头信息不得包含以下几种字段之外的字段：
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type： 仅限于<code>text/plain</code>、<code>multipart/form-data</code>、<code>application/x-www-form-urlencoded</code>三个值</li>
</ul>
</li>
</ol>
</blockquote>
<p>凡是不同时满足上面两个条件，就属于非简单请求。<br>
浏览器对这两种请求的处理，是不一样的。</p>
<h2 id="简单请求"><a class="header-anchor" href="#简单请求"></a>简单请求</h2>
<p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。<br>
我们首先发起一个跨域请求：<br>
<img src="request_cors_blocked.jpg" alt=""></p>
<p>可以看到，浏览器自动在请求头部加了一个<code>Origin</code>字段，同时服务器返回的状态码也为200，但是在控制台我们可以看到这样一个CORS的报错：<br>
<img src="request_cors_blocked_2.jpg" alt=""><br>
在服务器我们也能看到这样的记录：<br>
<img src="server_cors_record.jpg" alt=""><br>
这个也说明了，跨域请求可以正常发起，但是返回结果被浏览器拦截了。</p>
<p>我们对服务器稍加修改，给其响应头部加上如下字段：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>http://sender.com</span><br></pre></td></tr></table></figure>
<p>此时我们再发起请求，就可以看到结果如下：<br>
<img src="request_cors_ok.jpg" alt=""><br>
同时在控制台也没有了CORS的报错了。</p>
<p>总结一下，在发起一个简单请求时，浏览器如果发现这次请求是一个跨域AJAX请求时，就自动在头信息之中，添加一个<code>Origin</code>字段。<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>
<p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段或者这个字段的值中不包含这个<code>Origin</code>指定的源，就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200也有可能是其他，这个取决于服务器是否有做这方面的处理。比如，服务器对请求头中的<code>Origin</code>进行了判断后，可能给出诸如<code>403</code>等返回码如下：<br>
<img src="server_check_origin.jpg" alt=""><br>
服务器对<code>Origin</code>字段判断后，返回了<code>403</code>，同样的请求得到了不同的响应结果（对比上图）：<br>
<img src="request_cors_blocked_3.jpg" alt=""></p>
<h2 id="非简单请求"><a class="header-anchor" href="#非简单请求"></a>非简单请求</h2>
<p>对于非简单请求，浏览器并不会立即执行对应的请求代码，而是会先发送一个被称为<code>“预检”(Preflight)</code>的<code>OPTION</code>请求，用于询问要被跨域访问的服务器，是否允许当前域名下的页面发送跨域的请求。</p>
<p>比如，使用下面的代码发起一个请求：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;http://receiver.com/testNotSimpleReq.php&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;PUT&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;X-Custom-Header&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>
<p>这段代码中，HTTP请求的方法是<code>PUT</code>，并且发送一个自定义头信息<code>X-Custom-Header</code>。<br>
浏览器发现这是一个非简单请求，就会先自动发起一个“预检”请求，要求服务器确认可以这样请求：<br>
<img src="preflight_request.jpg" alt=""><br>
在请求头部中，关键字段是<code>Origin</code>，表示请求来自哪个源。<br>
除了<code>Origin</code>字段，&quot;预检&quot;请求的头信息包括两个特殊字段。</p>
<ol>
<li><code>Access-Control-Request-Method</code><br>
该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是<code>PUT</code>。</li>
<li><code>Access-Control-Request-Headers</code><br>
该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code>。</li>
</ol>
<p>在“预检”请求的响应头部中，出现了三个字段：</p>
<ol>
<li><code>Access-Control-Allow-Origin</code><br>
和前面一样，表示接受的域名</li>
<li><code>Access-Control-Allow-Methods</code><br>
逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次&quot;预检&quot;请求。</li>
<li><code>Access-Control-Allow-Headers</code><br>
如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在&quot;预检&quot;中请求的字段。</li>
</ol>
<p>如果请求方法或者请求中含有的自定义头部不在响应头部的<code>Access-Control-Allow-Methods</code>和<code>Access-Control-Allow-Headers</code>中，浏览器就不会真正发起该请求，同时在控制台报错如下：<br>
<img src="preflight_response_no_header.jpg" alt=""><br>
<img src="preflight_response_no_method.jpg" alt=""></p>
<p>如果顺利通过“预检”的话，浏览器则会真正发起请求：<br>
<img src="preflight_request_success.jpg" alt=""></p>
<h1 id="Cookies与CORS"><a class="header-anchor" href="#Cookies与CORS"></a>Cookies与CORS</h1>
<p>默认情况下，Cookie不包括在CORS请求之中。<br>
如果服务器允许请求中包含Cookies，则需要在响应头部中加入字段</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>
<p>如果服务器不要浏览器发送Cookie，删除该字段或者设置为<code>false</code>即可。<br>
另一方面，开发者必须在AJAX请求中打开withCredentials属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。</p>
<p>但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果要发送Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。<br>
同时，Cookie依然遵循同源策略，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且跨域的原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie。</p>
<h1 id="与JSONP的比较"><a class="header-anchor" href="#与JSONP的比较"></a>与JSONP的比较</h1>
<p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p>
<p>JSONP只支持<code>GET</code>请求，CORS支持<code>所有类型</code>的HTTP请求。<br>
JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>
<h1 id="参考"><a class="header-anchor" href="#参考"></a>参考</h1>
<p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解 - 阮一峰</a><br>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">HTTP访问控制（CORS） - MDN</a><br>
<a href="https://yq.aliyun.com/articles/69313">CORS——跨域请求那些事儿</a></p>
]]></content>
      <tags>
        <tag>CORS</tag>
        <tag>跨域</tag>
        <tag>同源策略</tag>
      </tags>
  </entry>
  <entry>
    <title>js中的几种for循环</title>
    <url>/2019/09/03/76f7a5851725/</url>
    <content><![CDATA[<p>在JS刚出来的时候，想要遍历一个数组，可以像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  conosole.<span class="title function_">log</span>(array[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="forEach"><a class="header-anchor" href="#forEach"></a>forEach</h1>
<p>在ES5之后，新加了一个<code>forEach</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>forEach</code>的写法比原来的<code>for</code>循环简洁，但是在其内部，却不能使用<code>break</code>和<code>return</code>结束循环以及<code>continue</code>跳过循环，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(item === <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">		<span class="comment">// 使用 break 及 continue 均会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// 1 3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="for…in"><a class="header-anchor" href="#for…in"></a>for…in</h1>
<p>ES5中，还有一个<code>for...in</code>循环，其用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> array) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(array[index])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，<code>for...in</code>有以下几个特点：</p>
<ol>
<li>枚举的索引<code>index</code>是字符型，不能直接进行数字运算，如：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123;</span><br><span class="line">  sum += index</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum) <span class="comment">// &#x27;0012&#x27;, 而不是 3</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>会将原型对象也一起枚举出来，如：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">objCustom</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;; </span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">arrCustom</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// arrCustom</span></span><br><span class="line"><span class="comment">// objCustom</span></span><br></pre></td></tr></table></figure>
<p>如果不想枚举出原型对象，可以配合使用<code>hasOwnProperty</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">objCustom</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;; </span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">arrCustom</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="title function_">hasOwnProperty</span>(i)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>循环出来的属性顺序如下：先遍历出整数属性（integer properties，按照升序），然后其他属性按照创建时候的顺序遍历出来。</li>
</ol>
<blockquote>
<p>整数属性满足 <code>String(Math.trunc(Number(prop)) === prop</code><br>
如<br>
“49” 是整数属性，因为 <code>String(Math.trunc(Number('49'))</code> 的结果还是 “49”。<br>
“+49” 不是整数属性，因为 <code>String(Math.trunc(Number('+49'))</code> 的结果是 “49”，不是 “+49”。<br>
“1.2” 不是整数属性，因为 <code>String(Math.trunc(Number('1.2'))</code> 的结果是 “1”，不是 “1.2”。</p>
</blockquote>
<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> codes = &#123;</span><br><span class="line">  <span class="string">&quot;49&quot;</span>: <span class="string">&quot;Germany&quot;</span>,</span><br><span class="line">  <span class="string">&quot;41&quot;</span>: <span class="string">&quot;Switzerland&quot;</span>,</span><br><span class="line">  <span class="string">&quot;44&quot;</span>: <span class="string">&quot;Great Britain&quot;</span>,</span><br><span class="line">  <span class="string">&quot;1&quot;</span>: <span class="string">&quot;USA&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> code <span class="keyword">in</span> codes) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(code)  <span class="comment">// 1, 41, 44, 49</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="for…of"><a class="header-anchor" href="#for…of"></a>for…of</h1>
<p>在ES6中，新加了一个<code>for...of</code>循环，其用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> array) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与前面几种方式比较，<code>for...of</code>是循环数组元素最简洁的方法，避免了<code>for...in</code>的几个不足，同时也能够使用<code>return</code>、<code>break</code>、<code>continue</code></p>
<p><code>for...of</code>能够使用的范围包括了数组、<code>Set</code>、<code>Map</code>、字符串、类数组对象（如<code>arguments</code>、<code>DOM NodeList</code>对象）、 <code>Generator</code>对象。</p>
<h2 id="数组"><a class="header-anchor" href="#数组"></a>数组</h2>
<p><code>for...of</code>能够直接使用在数组上，其遍历得到的是键值，而不像<code>for...in</code>一样得到的是键名：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index) <span class="comment">// 0 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value) <span class="comment">// a b c d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，<code>for...of</code>只会遍历数组的数字索引的属性，而<code>for...in</code>会遍历所有属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">arr.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index) <span class="comment">// &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value) <span class="comment">//  &quot;3&quot;, &quot;5&quot;, &quot;7&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Set、Map"><a class="header-anchor" href="#Set、Map"></a>Set、Map</h2>
<p>Set、Map在使用<code>for...of</code>进行遍历的时候，顺序是<strong>按照各个成员添加到数据结构中的顺序</strong>。另外，Set 遍历时，返回的是一个值，而 Map 遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> engines = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;Gecko&quot;</span>, <span class="string">&quot;Trident&quot;</span>, <span class="string">&quot;Webkit&quot;</span>, <span class="string">&quot;Webkit&quot;</span>])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">of</span> engines) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Gecko</span></span><br><span class="line"><span class="comment">// Trident</span></span><br><span class="line"><span class="comment">// Webkit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> es6 = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">es6.<span class="title function_">set</span>(<span class="string">&quot;edition&quot;</span>, <span class="number">6</span>)</span><br><span class="line">es6.<span class="title function_">set</span>(<span class="string">&quot;committee&quot;</span>, <span class="string">&quot;TC39&quot;</span>)</span><br><span class="line">es6.<span class="title function_">set</span>(<span class="string">&quot;standard&quot;</span>, <span class="string">&quot;ECMA-262&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [name, value] <span class="keyword">of</span> es6) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name + <span class="string">&quot;: &quot;</span> + value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// edition: 6</span></span><br><span class="line"><span class="comment">// committee: TC39</span></span><br><span class="line"><span class="comment">// standard: ECMA-262</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> pair <span class="keyword">of</span> es6) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pair)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&#x27;edition&#x27;, 6]</span></span><br><span class="line"><span class="comment">// [&#x27;committee&#x27;, TC39]</span></span><br><span class="line"><span class="comment">// [&#x27;standard&#x27;, ECMA-262]</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a class="header-anchor" href="#字符串"></a>字符串</h2>
<p>在使用<code>for...of</code>遍历字符串时，还能够正确的识别Unicode编码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> chr <span class="keyword">of</span> <span class="string">&quot;😺😲&quot;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(chr) <span class="comment">// 😺, 😲</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> chr <span class="keyword">in</span> <span class="string">&quot;😺😲&quot;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(chr) <span class="comment">// &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;   &lt;--- 将2个Unicode字符识别成了4个字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类数组对象"><a class="header-anchor" href="#类数组对象"></a>类数组对象</h2>
<p>类数组对象的遍历方法也和数组一样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DOM NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> paras = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> paras) &#123;</span><br><span class="line">  p.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printArgs</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="variable language_">arguments</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printArgs</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="普通对象"><a class="header-anchor" href="#普通对象"></a>普通对象</h2>
<p><code>for...of</code>并不能像<code>for...in</code>一样直接遍历普通对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> es6 = &#123;</span><br><span class="line">  <span class="attr">edition</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="attr">committee</span>: <span class="string">&quot;TC39&quot;</span>,</span><br><span class="line">  <span class="attr">standard</span>: <span class="string">&quot;ECMA-262&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">in</span> es6) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// edition</span></span><br><span class="line"><span class="comment">// committee</span></span><br><span class="line"><span class="comment">// standard</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">of</span> es6) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TypeError: es6 is not iterable</span></span><br></pre></td></tr></table></figure>
<p>解决方法有两种，一是使用<code>Object.entries</code>/<code>Object.keys</code>/<code>Object.values</code>方法由普通对象生成键值对/键名/键值数组，然后遍历这个数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> es6 = &#123;</span><br><span class="line">  <span class="attr">edition</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="attr">committee</span>: <span class="string">&quot;TC39&quot;</span>,</span><br><span class="line">  <span class="attr">standard</span>: <span class="string">&quot;ECMA-262&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(es6)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;edition&quot;, 6]</span></span><br><span class="line"><span class="comment">// [&quot;committee&quot;, &quot;TC39&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;standard&quot;, &quot;ECMA-262&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(es6)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e + <span class="string">&#x27;: &#x27;</span> + es6[e])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// edition: 6</span></span><br><span class="line"><span class="comment">// committee: TC39</span></span><br><span class="line"><span class="comment">// standard: ECMA-262</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">values</span>(es6)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// TC39</span></span><br><span class="line"><span class="comment">// ECMA-262</span></span><br></pre></td></tr></table></figure>
<p>另一种是使用<code>Generator</code>函数将对象包装一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">entries</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">entries</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, <span class="string">&#x27;-&gt;&#x27;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a -&gt; 1</span></span><br><span class="line"><span class="comment">// b -&gt; 2</span></span><br><span class="line"><span class="comment">// c -&gt; 3</span></span><br></pre></td></tr></table></figure>
<h1 id="参考-v2"><a class="header-anchor" href="#参考-v2"></a>参考</h1>
<ol>
<li><a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/">ES6 In Depth: Iterators and the for-of loop</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/iterator#for---of-%E5%BE%AA%E7%8E%AF">Iterator 和 for…of 循环</a></li>
<li><a href="http://javascript.info/object#the-for-in-loop">http://javascript.info/object#the-for-in-loop</a></li>
</ol>
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中的Scope Hoisting</title>
    <url>/2019/12/23/4dc3e68a94b3/</url>
    <content><![CDATA[<p>本文介绍了 webpack 中的 Scope Hoisting。</p>
<span id="more"></span>
<h1 id="现象"><a class="header-anchor" href="#现象"></a>现象</h1>
<p>在使用 webpack 构建后，如果查看其构建完成的 bundle 文件，会发现其中存在大量的闭包代码：<br>
源码：<br>
<img src="source-code.png" alt=""><br>
<img src="source-code2.png" alt=""><br>
构建后的代码：<br>
<img src="non-scope-hoisting.png" alt=""></p>
<p>可以看到，一个模块在经过 webpack 转换过后，会带上一层包裹，同时 <code>import</code> 会被转换成 <code>__webpack_require__</code> 调用；<code>export</code> 也会转换成调用 <code>__webpack_require__.d</code>（就是在模块上定义一个 getter 函数），并且加上注释 <code>/* harmony export (binding) */</code>。</p>
<p>由于大量的作用域包裹代码，会导致体积增大，并且模块越多越明显。同时，运行时创建的函数作用域变多，内存开销变大。</p>
<h1 id="进一步分析"><a class="header-anchor" href="#进一步分析"></a>进一步分析</h1>
<p>一个构建完成的文件格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">;(<span class="keyword">function</span> (<span class="params">modules</span>) &#123; <span class="comment">// 入口</span></span><br><span class="line">  <span class="comment">// 用来缓存模块</span></span><br><span class="line">  <span class="keyword">var</span> installedModules = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于加载模块的函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">__webpack_require__</span> (moduleId) &#123;</span><br><span class="line">    <span class="keyword">if</span> (installedModules[moduleId]) &#123;</span><br><span class="line">      <span class="keyword">return</span> installedModules[moduleId].<span class="property">exports</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个新模块，并加入到缓存中</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable language_">module</span> = (installedModules[moduleId] = &#123;</span><br><span class="line">      <span class="attr">i</span>: moduleId,</span><br><span class="line">      <span class="attr">l</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">exports</span>: &#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行模块初始化函数</span></span><br><span class="line">    modules[moduleId].<span class="title function_">call</span>(<span class="variable language_">module</span>.<span class="property">exports</span>, <span class="variable language_">module</span>, <span class="variable language_">module</span>.<span class="property">exports</span>, __webpack_require__)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将模块标记为已加载</span></span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">l</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回导出的模块</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">module</span>.<span class="property">exports</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载入口模块</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">__webpack_require__</span>((__webpack_require__.<span class="property">s</span> = <span class="number">0</span>))</span><br><span class="line">&#125;)([</span><br><span class="line">  <span class="comment">/* 0 */</span></span><br><span class="line">  <span class="keyword">function</span> (<span class="params"><span class="variable language_">module</span>, __webpack_exports__, __webpack_require__</span>) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="keyword">function</span> (<span class="params"><span class="variable language_">module</span>, __webpack_exports__, __webpack_require__</span>) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>可以看到，构建出来的是一个<code>IIFE</code>(匿名闭包函数)，<code>modules</code>是一个数组，每项都是一个模块初始化函数。</p>
<h1 id="Scope-Hoisting-原理"><a class="header-anchor" href="#Scope-Hoisting-原理"></a>Scope Hoisting 原理</h1>
<p>将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突。</p>
<p>可以简单的把 Scope Hoisting 理解为是把每个模块被 webpack 处理成的模块初始化函数整理到一个统一的包裹函数里，也就是把多个作用域用一个作用域取代，以减少内存消耗并减少包裹块代码，从每个模块有一个包裹函数变成只有一个包裹函数包裹所有的模块，但是有一个前提就是，当模块的引用次数<code>大于1</code>时，比如被引用了两次或以上，那么这个效果会无效，也就是被引用多次的模块在被 webpack 处理后，会被独立的包裹函数所包裹，因为如果一个模块引用次数大于1次，那么这个模块的代码会被内联多次，从而增加了打包出来的 js bundle 的体积。</p>
<h1 id="Scope-Hositing-使用"><a class="header-anchor" href="#Scope-Hositing-使用"></a>Scope Hositing 使用</h1>
<p>在 webpack 中，设置 <code>mode: 'production'</code> 之后，就默认添加了插件<code>webpack.optimize.ModuleConcatenationPlugin()</code>，开启了 Scope Hoisting。<br>
使用前后对比：<br>
使用前：<br>
<img src="non-scope-hoisting.png" alt=""><br>
使用后：<br>
<img src="after-scope-hoisting.png" alt=""></p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中的Tree Shaking</title>
    <url>/2019/12/16/beddfca3cfd2/</url>
    <content><![CDATA[<p>本文介绍了webpack中的Tree Shaking相关内容。</p>
<span id="more"></span>
<h1 id="什么是Tree-Shaking"><a class="header-anchor" href="#什么是Tree-Shaking"></a>什么是Tree Shaking</h1>
<p>1 个模块可能有多个方法，只要其中的某个方法使用到了，则整个文件都会被打到 <code>bundle</code> 里面去，tree shaking 就是<code>只把用到的方法</code>打入 bundle ，没用到的方法会在 <code>uglify</code> 阶段被擦除掉。</p>
<p>可以将应用想象成一棵树，其中，绿色表示实际用到的代码，是树上活的树叶；灰色表示未引用代码，是秋天树上枯萎的树叶。为了除去死去的树叶，你必须摇动这棵树，使它们落下。这就是 Tree Shaking。</p>
<h1 id="原理"><a class="header-anchor" href="#原理"></a>原理</h1>
<p>利用<code>ES6模块</code>的特点：</p>
<ol>
<li>只能作为模块顶层的语句出现</li>
<li>import 的模块名只能是字符串常量</li>
<li>import binding 是 immutable 的</li>
</ol>
<p>在分析的时候，Tree Shaking 会知道哪些代码没用到，会给这些没用到的代码加一个注释，并在 uglify 的时候进行删除。</p>
<p><strong>注意</strong>：由于使用到了<code>ES6模块</code>的特点，所以在使用<code>babel</code>的时候，需要将默认的<code>es6 模块</code>转为<code>es5 commonjs</code>禁止掉，即在<code>.babelrc</code>中，添加配置<code>modules: false</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;modules&quot;</span>: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;@babel/preset-react&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="怎么用"><a class="header-anchor" href="#怎么用"></a>怎么用</h1>
<p>webpack 默认支持，<code>production</code>模式下默认开启。</p>
<p>新建一个模块 treeshaking.js:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// treeshaking.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">a</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;func a&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">b</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;func b&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在另一模块中导入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">&#x27;/path/to/treeshaking.js&#x27;</span></span><br><span class="line"><span class="comment">// ... 余下代码中并不使用函数a</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>开启 Tree Shaking 前：<br>
<img src="before.png" alt=""></p>
<p>开启 Tree Shaking 后：<br>
<img src="after.png" alt=""></p>
<p>在 index.js 中使用函数 a，并开启 Tree Shaking 后：<br>
<img src="use-a.png" alt=""></p>
<h1 id="参考-v3"><a class="header-anchor" href="#参考-v3"></a>参考</h1>
<p><a href="https://webpack.docschina.org/guides/tree-shaking/">Tree Shaking - WebPack中文文档</a></p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中的一些常用配置【一】</title>
    <url>/2019/11/29/87bd5df83fd1/</url>
    <content><![CDATA[<p>本文介绍了webpack中4个插件的使用。</p>
<span id="more"></span>
<h1 id="自动清理构建目录"><a class="header-anchor" href="#自动清理构建目录"></a>自动清理构建目录</h1>
<p>每次webpack构建完之后，都会在输出目录生成构建好的文件。如果没有清理掉之前的构建文件的话，在多次构建之后，这个输出目录无用文件就会很多。而手动清理又比较麻烦。webpack中<a href="https://github.com/johnagan/clean-webpack-plugin"><code>clean-webpack-plugin</code></a>可以实现每次构建前，自动删除<code>output</code>指定的目录：<br>
使用前先安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i clean-webpack-plugin -D</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CleanWebpackPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exporte</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">index</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">        <span class="attr">search</span>: <span class="string">&#x27;./src/search.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name].[chunkhash:8].js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>()</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，在clean-webpack-plugin v3的版本中，只能够使用解构的方式引入</p>
</blockquote>
<h1 id="自动补齐CSS3前缀"><a class="header-anchor" href="#自动补齐CSS3前缀"></a>自动补齐CSS3前缀</h1>
<p>由于浏览器标准没有统一，我们需要去兼容许多问题，比如样式不一样。不同浏览器CSS样式可能需要不同的前缀，如 <code>-webkit</code>、<code>-moz</code> 等等，可以使用 <code>autoprefixer</code> 来自动补全前缀。</p>
<p><code>autoprefixer</code> 是一个后置处理器，根据的是 <a href="https://caniuse.com">Can I Use</a> 这个网站上给出的兼容情况进行补齐前缀。<br>
<code>autoprefixer</code> 一般是与 <a href="https://github.com/postcss/postcss-loader"><code>postcss-loader</code></a> 一起使用，所以使用前需要先安装两者：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i postcss-loader autoprefixer -D</span><br></pre></td></tr></table></figure>
<p>安装完毕之后，就可以配置下  <code>webpack.config.js</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exporte</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">index</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">        <span class="attr">search</span>: <span class="string">&#x27;./src/search.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name].[chunkhash:8].js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="attr">test</span>: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">                 <span class="attr">use</span>: <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">             &#125;,</span><br><span class="line">             &#123;</span><br><span class="line">                  <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                  <span class="attr">use</span>: [<span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;postcss-loader&#x27;</span>]</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">                  <span class="attr">use</span>: [<span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span>, <span class="string">&#x27;postcss-loader&#x27;</span>]</span><br><span class="line">              &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&#x27;[name].[contenthash:8].css&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后增加<code>postcss-loader</code>的配置文件<code>postcss.config.js</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// postcss.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="built_in">require</span>(<span class="string">&#x27;autoprefixer&#x27;</span>)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外还需要在<code>package.json</code>或<code>.broswerlistrc</code>中增加<code>autoprefixer</code>要兼容的浏览器版本：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">browserslist<span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;last 2 version&quot;</span><span class="punctuation">,</span> <span class="string">&quot;&gt;1%&quot;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<h1 id="静态资源内联"><a class="header-anchor" href="#静态资源内联"></a>静态资源内联</h1>
<p>静态资源内联，可以减少HTTP请求数；CSS内联也可以避免页面闪动；JS代码内联可以用于上报相关打点，以及完成页面框架的初始化工作。</p>
<p>使用<code>raw-loader</code>达到静态资源内联的目的。</p>
<h2 id="JS-HTML的内联"><a class="header-anchor" href="#JS-HTML的内联"></a>JS/HTML的内联</h2>
<p>在 html 页面中需要内联静态资源的地方，使用<code>raw-loader</code>的语法，将静态资源引入就可以：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// html</span><br><span class="line">$&#123;require(&#x27;raw-loader!/path/to/assert.html&#x27;).default&#125;</span><br><span class="line">// js</span><br><span class="line">$&#123;require(&#x27;raw-loader!babel-loader!/path/to/assert.js&#x27;).default&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：在 <code>raw-loader v0.5.1</code> 中，<code>require</code> 后不需要加 <code>.default</code></p>
<h2 id="CSS的内联"><a class="header-anchor" href="#CSS的内联"></a>CSS的内联</h2>
<p>在 <code>webpack.config.js</code> 的 module 使用 <code>style-loader</code> 插件即可。</p>
<h1 id="px-自动转换为-rem"><a class="header-anchor" href="#px-自动转换为-rem"></a>px 自动转换为 rem</h1>
<blockquote>
<p><code>rem</code>: font-size of root element<br>
-&gt; <a href="https://zhuanlan.zhihu.com/p/30413803">Rem布局的原理解析</a></p>
</blockquote>
<p>px转换为rem，可以使用 <code>px2rem-loader</code> 插件完成。使用时，需要指定两个参数：<code>remUnit</code> - rem的单位，即 1rem = remUnit px，<code>remPrecesion</code> - 转换成 rem 后保留的小数位数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exporte</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">index</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">        <span class="attr">search</span>: <span class="string">&#x27;./src/search.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name].[chunkhash:8].js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="attr">test</span>: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">                 <span class="attr">use</span>: <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">             &#125;,</span><br><span class="line">             &#123;</span><br><span class="line">                  <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                  <span class="attr">use</span>: [</span><br><span class="line">                      <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,</span><br><span class="line">                      <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">                      <span class="string">&#x27;less-loader&#x27;</span>,</span><br><span class="line">                      <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">                      &#123;</span><br><span class="line">                          <span class="attr">loader</span>: <span class="string">&#x27;px2rem-loader&#x27;</span>,</span><br><span class="line">                          <span class="attr">options</span>: &#123;</span><br><span class="line">                              <span class="attr">remUnit</span>: <span class="number">75</span>,</span><br><span class="line">                              <span class="attr">remPrecesion</span>: <span class="number">8</span></span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  ]</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">                  <span class="attr">use</span>: [</span><br><span class="line">                      <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,</span><br><span class="line">                      <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">                      <span class="string">&#x27;less-loader&#x27;</span>,</span><br><span class="line">                      <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">                      &#123;</span><br><span class="line">                          <span class="attr">loader</span>: <span class="string">&#x27;px2rem-loader&#x27;</span>,</span><br><span class="line">                          <span class="attr">options</span>: &#123;</span><br><span class="line">                              <span class="attr">remUnit</span>: <span class="number">75</span>,</span><br><span class="line">                              <span class="attr">remPrecesion</span>: <span class="number">8</span></span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  ]</span><br><span class="line">              &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&#x27;[name].[contenthash:8].css&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此外，为了动态计算根节点的 <code>font-size</code>，可以在CSS中加入：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>: &#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="built_in">calc</span>(<span class="number">100vw</span>/固定分辨率)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中的一些常用配置【二】</title>
    <url>/2019/12/03/c4584fcdf325/</url>
    <content><![CDATA[<p>本文继续介绍几个 webpack 中常见的配置。</p>
<span id="more"></span>
<h1 id="多页面打包"><a class="header-anchor" href="#多页面打包"></a>多页面打包</h1>
<p>在 webpack 中，我们通过设置 <a href="/2019/11/17/webpack%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/#entry"><code>entry</code> 字段</a>来指定页面入口。同时我们也可以使用 <a href="/2019/11/26/webpack%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8E%8B%E7%BC%A9/#html"><code>html-webpack-plugin</code> 插件</a>来设置每个入口的 html 页面。</p>
<p>但是如果是像上面链接中那样，手动设置每个页面，较为麻烦，需要手动去维护这两个字段。</p>
<p>在 webpack 中，我们可以使用 <a href="https://www.npmjs.com/package/glob"><code>glob</code></a> 读取文件，并根据指定的规则匹配到模块名，并动态设置 entry 及 html-webpack-plugin 插件的内容。</p>
<p>假设我们规定，所有页面的入口文件都为 <code>/src/模块名/index.js</code>，即 src 下的一级目录中的 index.js；同时使用的页面模板文件为 <code>/src/模块名/index.html</code> 。</p>
<p>首先，安装下 <code>glob</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i glob -D</span><br></pre></td></tr></table></figure>
<p>接着修改 webpack.config.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">&#x27;glob&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">setMPA</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> entry = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> htmlWebpackPlugins = []</span><br><span class="line">    <span class="keyword">const</span> entryFiles = glob.<span class="title function_">sync</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;./src/*/index.js&#x27;</span>)) <span class="comment">// 同步获取文件</span></span><br><span class="line"></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(entryFiles)</span><br><span class="line">        .<span class="title function_">map</span>(<span class="function"><span class="params">index</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> entryFile = entryFiles[index]</span><br><span class="line">            <span class="keyword">const</span> match = entryFile.<span class="title function_">match</span>(<span class="regexp">/src\/(.*)\/index\.js/</span>) <span class="comment">// 正则匹配模块名</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">const</span> pageName = match &amp;&amp; match[<span class="number">1</span>]</span><br><span class="line">            entry[pageName] = entryFile</span><br><span class="line">            </span><br><span class="line">            htmlWebpackPlugins.<span class="title function_">push</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">                    <span class="attr">inlineSource</span>: <span class="string">&#x27;.css$&#x27;</span>,</span><br><span class="line">                    <span class="attr">template</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">`src/<span class="subst">$&#123;pageName&#125;</span>/index.html`</span>), <span class="comment">// 设置页面模板</span></span><br><span class="line">                    <span class="attr">filename</span>: <span class="string">`<span class="subst">$&#123;pageName&#125;</span>.html`</span>, <span class="comment">// 输出的文件名</span></span><br><span class="line">                    <span class="attr">chunks</span>: [pageName], <span class="comment">// 使用到的chunk名，可以根据需要，将要用到的 js 文件名写在这</span></span><br><span class="line">                    <span class="attr">inject</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">minify</span>: &#123; <span class="comment">// 压缩 html</span></span><br><span class="line">                        <span class="attr">html5</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="attr">collapseWhitespace</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="attr">preserveLineBreaks</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="attr">minifyCSS</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="attr">minifyJS</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="attr">removeComments</span>: <span class="literal">false</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        entry,</span><br><span class="line">        htmlWebpackPlugins</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; entry, htmlWebpackPlugins &#125; = <span class="title function_">setMPA</span>()</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: entry,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name].[chunkhash:8].js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    ].<span class="title function_">concat</span>(htmlWebpackPlugins),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="source-map-的使用"><a class="header-anchor" href="#source-map-的使用"></a>source map 的使用</h1>
<blockquote>
<p>什么是 <code>source map</code>：参见 <a href="https://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html">阮一峰 - JavaScript Source Map 详解</a></p>
</blockquote>
<p>source map 有五个关键字：</p>
<ol>
<li>eval: 使用 <code>eval</code> 包裹代码</li>
<li>source map: 产生 .map 文件</li>
<li>cheap: 不包含列信息</li>
<li>inline: 将 .map 作为 DataURI 嵌入，不单独产生 .map 文件</li>
<li>module: 包含 loader 的 sourcemap</li>
</ol>
<p>在 webpack 中，可以通过设置 <code>devtool</code> 字段，来设置 source map 的类型。<br>
<code>devtool</code> 字段的取值为上述五个关键字的组合，具体取值可参考<a href="https://webpack.docschina.org/configuration/devtool/">官方文档</a>。</p>
<p>使用例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name].[chunkhash:8].js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&#x27;cheap-module-source- map&#x27;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="公共资源提取"><a class="header-anchor" href="#公共资源提取"></a>公共资源提取</h1>
<h2 id="基础库分离"><a class="header-anchor" href="#基础库分离"></a>基础库分离</h2>
<p>在 React 开发时，基本上每个页面都会用到 React / ReactDOM，在每次打包的时候，构建工具就会把 React / ReactDOM 打包到 bundle 里，导致构建速度较慢，因此，可以使用 <a href="https://www.npmjs.com/package/html-webpack-externals-plugin"><code>html-webpack-externals-plugin</code></a> 将 React / ReactDOM 基础库通过 CDN 的形式引入，而不打入 bundle 中。</p>
<p>使用方法（以 React 为例）：<br>
在webpack.config.js 中添加 html-webpack-externals-plugin 的配置。<strong>注意</strong>：html-webpack-externals-plugin 需要添加在 html-webpack-plugin 之后：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackExternalsPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-externals-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; entry, htmlWebpackPlugins &#125; = <span class="title function_">setMPA</span>()</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: entry,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name].[chunkhash:8].js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">        .<span class="title function_">concat</span>(htmlWebpackPlugins)</span><br><span class="line">        .<span class="title function_">concat</span>([</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HtmlWebpackExternalsPlugin</span>(&#123;  <span class="comment">// 添加在 htmlWebpackPlugin 之后</span></span><br><span class="line">                <span class="attr">externals</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">module</span>: <span class="string">&#x27;react&#x27;</span>,</span><br><span class="line">                        <span class="attr">entry</span>: <span class="string">&#x27;https://cdn.bootcss.com/react/16.10.2/umd/react.profiling.min.js&#x27;</span>,</span><br><span class="line">                        <span class="attr">global</span>: <span class="string">&#x27;React&#x27;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">module</span>: <span class="string">&#x27;react-dom&#x27;</span>,</span><br><span class="line">                        <span class="attr">entry</span>: <span class="string">&#x27;https://cdn.bootcss.com/react-dom/16.10.2/umd/react-dom.profiling.min.js&#x27;</span>,</span><br><span class="line">                        <span class="attr">global</span>: <span class="string">&#x27;ReactDOM&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;)</span><br><span class="line">        ]),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，这样子会导致页面<em>多次引入</em> React / ReactDOM，暂不知如何解决。<br>
提取前：<br>
<img src="external-before-size.png" alt=""><br>
<img src="external-before.png" alt=""><br>
提取后：<br>
<img src="external-after-size.png" alt=""><br>
<img src="external-after.png" alt=""></p>
<h2 id="使用-SplitChunksPlugin-进行公共脚本分离"><a class="header-anchor" href="#使用-SplitChunksPlugin-进行公共脚本分离"></a>使用 SplitChunksPlugin 进行公共脚本分离</h2>
<p><code>SplitChunksPlugin</code>是 webpack4 内置的插件，替代 CommonsChunkPlugin 插件，更多介绍请参考<a href="https://webpack.js.org/plugins/split-chunks-plugin/">官方文档</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">            <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span>, <span class="comment">// async: 异步引入的库进行分离（默认）；initial: 同步引入的库进行分离；all: 所以引入的库进行分离（推荐）</span></span><br><span class="line">            <span class="attr">minSize</span>: <span class="number">30000</span>, <span class="comment">// 分离的公共包体积的最小大小，单位：字节</span></span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">minChunks</span>: <span class="number">2</span>, <span class="comment">// 最小引用次数</span></span><br><span class="line">            <span class="attr">maxAsyncRequests</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="attr">maxInitialRequests</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">automaticNameDelimiter</span>: <span class="string">&#x27;~&#x27;</span>,</span><br><span class="line">            <span class="attr">automaticNameMaxLength</span>: <span class="number">30</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">                <span class="attr">vendors</span>: &#123;</span><br><span class="line">                    <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>,  <span class="comment">// 匹配出需要分离的包</span></span><br><span class="line">                    <span class="attr">priority</span>: -<span class="number">10</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">default</span>: &#123;</span><br><span class="line">                    <span class="attr">minChunks</span>: <span class="number">2</span>,</span><br><span class="line">                    <span class="attr">priority</span>: -<span class="number">20</span>,</span><br><span class="line">                    <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中的代码压缩</title>
    <url>/2019/11/26/f59e591a4a3f/</url>
    <content><![CDATA[<p>本文介绍了webpack中JS、HTML、CSS进行代码压缩的方式。</p>
<span id="more"></span>
<h1 id="JS"><a class="header-anchor" href="#JS"></a>JS</h1>
<p>设置 <code>mode</code>为 <code>production</code> 配置后，webpack v4+ <code>默认</code>会压缩你的代码。生产环境下默认使用 <a href="https://webpack.docschina.org/plugins/uglifyjs-webpack-plugin/"><code>UglifyJSPlugin</code></a>。</p>
<p>所以无需手动配置压缩选项。</p>
<h1 id="HTML"><a class="header-anchor" href="#HTML"></a>HTML</h1>
<p>压缩HTML可以使用插件<a href="https://webpack.docschina.org/plugins/html-webpack-plugin/"><code>html-webpack-plugin</code></a>，并配置<a href="https://github.com/jantimon/html-webpack-plugin#options">相关参数</a>进行使用，这里给出一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">index</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">search</span>: <span class="string">&#x27;./src/index2.jsx&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].[chunkhash:8].js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">        <span class="attr">use</span>: <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&#x27;img/[name].[hash:8].[ext]&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;[name].[contenthash:8].css&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;./src/index.html&#x27;</span>), <span class="comment">// 使用的模板</span></span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;idnex.html&#x27;</span>, <span class="comment">// 生成的文件名</span></span><br><span class="line">      <span class="attr">chunks</span>: [<span class="string">&#x27;index&#x27;</span>], <span class="comment">// 生成的html使用的chunk</span></span><br><span class="line">      <span class="attr">inject</span>: <span class="literal">true</span>, <span class="comment">// 设置为true时，使用到的chunk，css会自动注入到html中</span></span><br><span class="line">      <span class="attr">minify</span>: &#123;</span><br><span class="line">        <span class="attr">html5</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">minifyCSS</span>: <span class="literal">true</span>, <span class="comment">// 压缩内联CSS</span></span><br><span class="line">        <span class="attr">minifyJS</span>: <span class="literal">true</span>, <span class="comment">// 压缩内联JS</span></span><br><span class="line">        <span class="attr">removeComments</span>: <span class="literal">true</span>, <span class="comment">// 移除注释</span></span><br><span class="line">        <span class="attr">collapseWhitespace</span>: <span class="literal">true</span>, <span class="comment">// 删除空格、换行等空白符</span></span><br><span class="line">        <span class="attr">preserveLineBreaks</span>: <span class="literal">false</span>, <span class="comment">// 保留换行</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;./src/search.html&#x27;</span>), <span class="comment">// 使用的模板</span></span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;search.html&#x27;</span>, <span class="comment">// 生成的文件名</span></span><br><span class="line">      <span class="attr">chunks</span>: [<span class="string">&#x27;search&#x27;</span>], <span class="comment">// 生成的html使用的chunk</span></span><br><span class="line">      <span class="attr">inject</span>: <span class="literal">true</span>, <span class="comment">// 设置为true时，使用到的chunk，css会自动注入到html中</span></span><br><span class="line">      <span class="attr">minify</span>: &#123;</span><br><span class="line">        <span class="attr">html5</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">minifyCSS</span>: <span class="literal">true</span>, <span class="comment">// 压缩内联CSS</span></span><br><span class="line">        <span class="attr">minifyJS</span>: <span class="literal">true</span>, <span class="comment">// 压缩内联JS</span></span><br><span class="line">        <span class="attr">removeComments</span>: <span class="literal">true</span>, <span class="comment">// 移除注释</span></span><br><span class="line">        <span class="attr">collapseWhitespace</span>: <span class="literal">true</span>, <span class="comment">// 删除空格、换行等空白符</span></span><br><span class="line">        <span class="attr">preserveLineBreaks</span>: <span class="literal">false</span>, <span class="comment">// 保留换行</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>压缩前：<br>
<img src="html-before.png" alt=""><br>
<img src="html-before-code.png" alt=""><br>
压缩后：<br>
<img src="html-after.png" alt=""><br>
<img src="html-after-code.png" alt=""></p>
<h1 id="CSS"><a class="header-anchor" href="#CSS"></a>CSS</h1>
<p>压缩CSS代码，可通过<a href="https://github.com/NMFR/optimize-css-assets-webpack-plugin"><code>optimize-css-assets-webpack-plugin</code></a>插件完成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">OptimizeCssAssetsWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">index</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">search</span>: <span class="string">&#x27;./src/index2.jsx&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].[chunkhash:8].js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">        <span class="attr">use</span>: <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&#x27;img/[name].[hash:8].[ext]&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;[name].[contenthash:8].css&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;./src/index.html&#x27;</span>), <span class="comment">// 使用的模板</span></span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;index.html&#x27;</span>, <span class="comment">// 生成的文件名</span></span><br><span class="line">      <span class="attr">chunks</span>: [<span class="string">&#x27;index&#x27;</span>], <span class="comment">// 生成的html使用的chunk</span></span><br><span class="line">      <span class="attr">inject</span>: <span class="literal">true</span>, <span class="comment">// 设置为true时，使用到的chunk，css会自动注入到html中</span></span><br><span class="line">      <span class="attr">minify</span>: &#123;</span><br><span class="line">        <span class="attr">html5</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">minifyCSS</span>: <span class="literal">true</span>, <span class="comment">// 压缩内联CSS</span></span><br><span class="line">        <span class="attr">minifyJS</span>: <span class="literal">true</span>, <span class="comment">// 压缩内联JS</span></span><br><span class="line">        <span class="attr">removeComments</span>: <span class="literal">true</span>, <span class="comment">// 移除注释</span></span><br><span class="line">        <span class="attr">collapseWhitespace</span>: <span class="literal">true</span>, <span class="comment">// 删除空格、换行等空白符</span></span><br><span class="line">        <span class="attr">preserveLineBreaks</span>: <span class="literal">false</span>, <span class="comment">// 保留换行</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;./src/search.html&#x27;</span>), <span class="comment">// 使用的模板</span></span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;search.html&#x27;</span>, <span class="comment">// 生成的文件名</span></span><br><span class="line">      <span class="attr">chunks</span>: [<span class="string">&#x27;search&#x27;</span>], <span class="comment">// 生成的html使用的chunk</span></span><br><span class="line">      <span class="attr">inject</span>: <span class="literal">true</span>, <span class="comment">// 设置为true时，使用到的chunk，css会自动注入到html中</span></span><br><span class="line">      <span class="attr">minify</span>: &#123;</span><br><span class="line">        <span class="attr">html5</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">minifyCSS</span>: <span class="literal">true</span>, <span class="comment">// 压缩内联CSS</span></span><br><span class="line">        <span class="attr">minifyJS</span>: <span class="literal">true</span>, <span class="comment">// 压缩内联JS</span></span><br><span class="line">        <span class="attr">removeComments</span>: <span class="literal">true</span>, <span class="comment">// 移除注释</span></span><br><span class="line">        <span class="attr">collapseWhitespace</span>: <span class="literal">true</span>, <span class="comment">// 删除空格、换行等空白符</span></span><br><span class="line">        <span class="attr">preserveLineBreaks</span>: <span class="literal">false</span>, <span class="comment">// 保留换行</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">OptimizeCssAssetsWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">assetNameRegExp</span>: <span class="regexp">/\.css$/g</span>, <span class="comment">// 需要压缩的文件名的正则表达式</span></span><br><span class="line">      <span class="attr">cssProcessor</span>: <span class="built_in">require</span>(<span class="string">&#x27;cssnano&#x27;</span>) <span class="comment">// 使用的压缩处理器</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>压缩前：<br>
<img src="css-before.png" alt=""><br>
<img src="css-before-code.png" alt=""><br>
压缩后：<br>
<img src="css-after.png" alt=""><br>
<img src="css-after-code.png" alt=""></p>
<h1 id="总结"><a class="header-anchor" href="#总结"></a>总结</h1>
<p>webpack中对于代码压缩还是比较简单的，只要配置一些插件就能够实现了，因此上手难度并不大。</p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中的动态import</title>
    <url>/2019/12/29/e41f7eb06126/</url>
    <content><![CDATA[<p>本文介绍了 webpack 中的动态import。</p>
<span id="more"></span>
<h1 id="懒加载脚本"><a class="header-anchor" href="#懒加载脚本"></a>懒加载脚本</h1>
<p>在项目中，我们的某些代码块是在某些特殊的时候才会用到，如果我们把这些代码打包到一个 bundle 中，不仅会使 bundle 体积变大，也会让浏览器加载不必要的代码。如果使用脚本懒加载，就能够使得初始下载的代码更小，实现按需加载。</p>
<h1 id="懒加载的两种方式"><a class="header-anchor" href="#懒加载的两种方式"></a>懒加载的两种方式</h1>
<p>懒加载有两种方式，分别是：</p>
<ol>
<li>Common JS: <code>require.ensure</code>（已被<code>import()</code>替代），参考：<a href="https://webpack.docschina.org/api/module-methods/#require-ensure">webpack 模块方法 - require.ensure</a></li>
<li>ES6: 动态import</li>
</ol>
<h2 id="动态import"><a class="header-anchor" href="#动态import"></a>动态import</h2>
<blockquote>
<p><code>import('path/to/module') -&gt; Promise</code></p>
</blockquote>
<p>调用<code>import()</code>之处，被作为分离的模块起点，意思是，被请求的模块和它引用的所有子模块，会分离到一个单独的 chunk 中。</p>
<p>通过 webpack 构建之后，import() 会将模块抽离成为一个独立的文件，并在调用的地方，触发一个<code>jsonp</code>请求，加载这个模块。</p>
<p>调用 import()：<br>
<img src="code-module.png" alt=""><br>
<img src="code.png" alt=""></p>
<p>构建后的代码：<br>
<img src="compile-code.png" alt=""><br>
<img src="compile-module.png" alt=""></p>
<p>页面效果：<br>
<img src="html.png" alt=""></p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack构建体积优化</title>
    <url>/2020/01/14/db838f9ad264/</url>
    <content><![CDATA[<p>本文介绍了几种 webpack 构建体积优化的方式。</p>
<span id="more"></span>
<h1 id="图片压缩"><a class="header-anchor" href="#图片压缩"></a>图片压缩</h1>
<blockquote>
<p><a href="https://github.com/tcoopman/image-webpack-loader">Github - tcoopman/image-webpack-loader</a></p>
</blockquote>
<p>在 webpack 中，图片压缩使用的是 image-webpack-loader 。这个 loader 是基于 node 库 <code>imagemin</code> 实现的。</p>
<p><code>imagemin</code> 能够处理多种图片格式，能够使用第三方优化插件，如 <code>pngquant</code>、<code>tinypng</code>、<code>pngcrush</code>、<code>optiopng</code> 等。</p>
<h2 id="压缩原理"><a class="header-anchor" href="#压缩原理"></a>压缩原理</h2>
<p><code>pngquant</code>：通过将 png 图像转换为具有 alpha 通道的8位 png 格式，显著减小文件大小。<br>
<code>tinypng</code>：也是将 png 文件转化为8位 png 图片，同时剥离所有非必要的 metadata 信息。<br>
<code>pngcrush</code>：通过尝试不同的压缩级别和 png 过滤方法来降低 png idat 数据流的大小。<br>
<code>optiopng</code>：类似于 <code>pngcrush</code>，也是将 png 压缩为更小的尺寸。</p>
<h2 id="使用"><a class="header-anchor" href="#使用"></a>使用</h2>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i image-webpack-plugin -D</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="attr">rules</span>: [&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(gif|png|jpe?g|svg)$/i</span>,</span><br><span class="line">  <span class="attr">use</span>: [</span><br><span class="line">    <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;image-webpack-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">mozjpeg</span>: &#123;</span><br><span class="line">          <span class="attr">progressive</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">quality</span>: <span class="number">65</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// optipng.enabled: false will disable optipng</span></span><br><span class="line">        <span class="attr">optipng</span>: &#123;</span><br><span class="line">          <span class="attr">enabled</span>: <span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">pngquant</span>: &#123;</span><br><span class="line">          <span class="attr">quality</span>: [<span class="number">0.65</span>, <span class="number">0.90</span>],</span><br><span class="line">          <span class="attr">speed</span>: <span class="number">4</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">gifsicle</span>: &#123;</span><br><span class="line">          <span class="attr">interlaced</span>: <span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// the webp option will enable WEBP</span></span><br><span class="line">        <span class="attr">webp</span>: &#123;</span><br><span class="line">          <span class="attr">quality</span>: <span class="number">75</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>具体参数说明参见 ：<a href="https://github.com/tcoopman/image-webpack-loader#options">Options 说明</a></p>
<h1 id="Tree-Shking"><a class="header-anchor" href="#Tree-Shking"></a>Tree Shking</h1>
<p>Tree Shaking 可以去除代码中无用的 js 代码，具体用法可参考<a href="/2019/12/16/webpack%E4%B8%AD%E7%9A%84TreeShaking/">之前的文章</a></p>
<h1 id="去除无用-CSS"><a class="header-anchor" href="#去除无用-CSS"></a>去除无用 CSS</h1>
<p>Tree Shaking 可删除的是无用的 js 代码，但是对于 CSS 代码却无能为力。<br>
无用的 CSS 代码，可使用 <code>PurifyCSS</code> 或 <code>uncss</code> 删除。<br>
<code>PurifyCSS</code> 通过遍历代码，识别已经用到的 CSS class，进而删除无用 CSS 代码。<br>
<code>uncss</code> 使用 jsdom 加载 HTML，并使用 PostCSS 加载样式表，然后通过 <code>document.querySelector</code> 识别出在 HTML 中没出现的选择器。</p>
<p>由于 PurifyCSS 不再维护，所以在 webpack 中可以使用插件 <a href="https://github.com/FullHuman/purgecss-webpack-plugin"><code>purgecss-webpack-plugin</code></a> 实现删除无用 CSS 代码的目的。<br>
注意： purgecss-webpack-plugin 需要和 mini-css-extract-plugin 一同使用。</p>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i purgecss-webpack-plugin -D</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">&#x27;glob&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PurgecssPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;purgecss-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PATHS</span> = &#123;</span><br><span class="line">  <span class="attr">src</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,</span><br><span class="line">          <span class="string">&quot;css-loader&quot;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&quot;[name].css&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">PurgecssPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">paths</span>: glob.<span class="title function_">sync</span>(<span class="string">`<span class="subst">$&#123;PATHS.src&#125;</span>/**/*`</span>,  &#123; <span class="attr">nodir</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="动态-Polyfill"><a class="header-anchor" href="#动态-Polyfill"></a>动态 Polyfill</h1>
<blockquote>
<p>我们希望浏览器提供一些特性，但是没有，然后我们自己写一段代码来实现他，那这段代码就是 Polyfill。</p>
</blockquote>
<p>在 React 中，官方推荐使用 babel-polyfill，但是这个库存在一个问题，就是会把所有的 polyfill 都打包进去，存在体积较大的问题。</p>
<p><a href="https://polyfill.io">Polyfill.io</a> 提供了动态 polyfill 的功能，它会根据浏览器的UA不同，返回不一样的 polyfill，达到一个按需加载的作用。</p>
<p>使用方法也很简单，在 html 文件中引入即可：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://polyfill.io/v3/polyfill.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="http://polyfill.io">polyfill.io</a> 可以附加查询参数来定制 polyfill，具体可参照<a href="https://polyfill.io/v3/api/">官方文档</a>。</p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中的文件指纹:hash/chunkhash/contenthash</title>
    <url>/2019/11/23/ac9288002938/</url>
    <content><![CDATA[<p>本文介绍了webpack中的三种文件指纹的用法及其区别。</p>
<span id="more"></span>
<h1 id="什么是文件指纹"><a class="header-anchor" href="#什么是文件指纹"></a>什么是文件指纹</h1>
<p>所谓的文件指纹就是一个hash值（或hash值的一部分），我们可以通过文件指纹来实现前端资源的增量更新。具体而言，就是在资源名上添加一段hash值，通过浏览器的缓存策略，实现未改动的资源不重复下载。比如<a href="https://element.eleme.cn/#/zh-CN/component/quickstart">Element UI官网</a>中，就有使用到文件指纹：<br>
<img src="ele-demo.png" alt=""></p>
<h1 id="使用-v2"><a class="header-anchor" href="#使用-v2"></a>使用</h1>
<p>在webpack中，我们可以通过配置<code>output</code>的<code>filename</code>字段，来控制输出的文件名。因此，我们可以在这边加上<code>[hash]</code>等<a href="https://www.webpackjs.com/configuration/output/#output-filename">占位符</a>，来实现文件指纹。<br>
例如，我们配置<code>webpack.config.js</code>内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">vendor</span>: <span class="string">&#x27;./src/vendor.js&#x27;</span>,</span><br><span class="line">    <span class="attr">index</span>: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].[hash].js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行<code>npm run build</code>后就能得到如下输出：<br>
<img src="build-hash-1.png" alt=""><br>
可以看到，输出的文件名上已经多出了一串hash值。但是，我们也可以看到，这两个文件名上的hash是一样的，也就是说，每次构建出来，每个文件都是一个新构建的，不管其是否真正改动过。这样并不符合我们的预期：只更新我们有改动的文件，而未改动的不需要用户去下载。</p>
<p>为此，我们根据不同文件，使用webpack给我们提供的不同占位符：<code>[hash]</code>、<code>[chunkhash]</code>、<code>[contenthash]</code></p>
<h2 id="hash"><a class="header-anchor" href="#hash"></a>[hash]</h2>
<p>hash是根据整个项目的构建求出来的，如果使用了hash，那么每个模块都会有同样的hash值，不管这个模块是不是又改动过。因此不能达到增量更新的效果。</p>
<h2 id="chunkhash"><a class="header-anchor" href="#chunkhash"></a>[chunkhash]</h2>
<p>chunkhash是由chunk计算的得出的hash值，chunk指的是模块，这个hash值就是模块内容计算出来的hash值。</p>
<h3 id="用法"><a class="header-anchor" href="#用法"></a>用法</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">vendor</span>: <span class="string">&#x27;./src/vendor.js&#x27;</span>,</span><br><span class="line">    <span class="attr">index</span>: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].[chunkhash].js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行<code>npm run build</code>后就能得到如下输出：<br>
改变前：<br>
<img src="build-chunkhash-1.png" alt=""><br>
改变vendor.js后：<br>
<img src="build-chunkhash-2.png" alt=""><br>
可以看到vendor的hash已经改变了，而index得没有发生改变。</p>
<p><strong>注意</strong>：为了让hash值保持稳定，还应添加<a href="https://webpack.docschina.org/plugins/named-modules-plugin/"><code>NamedModulesPlugin</code></a>(开发环境)或<a href="https://webpack.docschina.org/plugins/hashed-module-ids-plugin/"><code>HashedModuleIdsPlugin</code></a>(生产环境)，这两个plugin能够让webpack使用相对路径而非模块id来命名模块。</p>
<p>如果我们将js中的css抽取成单独的文件后，并且也是用chunkhash，会出现这样一个问题：仅仅改动了js文件，css也跟着一起改了，这就导致了不必要的更新。<br>
<img src="build-chunkhash-3.png" alt=""></p>
<p>为此，我们在css等文件中，需要使用下面的contenthash这个占位符。</p>
<h2 id="contenthash"><a class="header-anchor" href="#contenthash"></a>[contenthash]</h2>
<p>contenthash用于求文件内容的hash值。这个hash值只与文件内容有关，而与chunk无关。<br>
首先，我们使用<a href="https://webpack.docschina.org/plugins/mini-css-extract-plugin/"><code>MiniCssExtractPlugin</code></a>将js中的css抽取出来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">index</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">vendor</span>: <span class="string">&#x27;./src/vendor.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].[chunkhash].js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">        <span class="attr">use</span>: <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;sass-loader&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="string">&#x27;file-loader&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;[name].[contenthash].css&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，loader上，我们使用了<code>MiniCssExtractPlugin.loader</code>而不是<code>style-loader</code>，因为<code>style-loader</code>的用处是将css放到<code>&lt;style&gt;</code>标签中，与<code>MiniCssExtractPlugin.loader</code>冲突了。</p>
<p>运行<code>npm run build</code>就能看到css的hash值已经与js无关了：<br>
<img src="build-contenthash-1.png" alt=""></p>
<h1 id="最后"><a class="header-anchor" href="#最后"></a>最后</h1>
<p>我们可以看到上面生成的hash都是比较长的，我们可以在占位符上指定我们要的长度，来生成我们想要的位数，如：<code>[hash:8]</code>、<code>[chunkhash:8]</code>、<code>[contenthash:8]</code><br>
<img src="build-hash-2.png" alt=""></p>
<h1 id="参考-v4"><a class="header-anchor" href="#参考-v4"></a>参考</h1>
<p><a href="https://juejin.im/post/5a1bcdadf265da430e4ee137">webpack稳定moduleid和chunkid以实现持久化缓存的梳理</a></p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中的文件监听及热更新</title>
    <url>/2019/11/18/cbec5e3d409d/</url>
    <content><![CDATA[<p>本文介绍了webpack中开启文件监听的两种方法以及热更新的原理</p>
<span id="more"></span>
<h1 id="文件监听"><a class="header-anchor" href="#文件监听"></a>文件监听</h1>
<p>webpack中，为了避免每次更新代码后都需要手动构建，可以开启文件监听选项。开启文件监听后，webpack会调用Node.js里面的文件读取API fs这个模块来判断文件内容是否变化，并且在文件变化的时候自动构建。<br>
开启文件监听的方法有两种：</p>
<ol>
<li>命令行</li>
<li>webpack.config.js中进行配置</li>
</ol>
<h2 id="命令行"><a class="header-anchor" href="#命令行"></a>命令行</h2>
<p>在启动<code>webpack</code>命令的时候，带上<code>--watch</code>参数即可，即：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">webpack --watch</span><br></pre></td></tr></table></figure>
<h2 id="配置文件"><a class="header-anchor" href="#配置文件"></a>配置文件</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 是否开启文件监听，默认false，即不开启</span></span><br><span class="line">    <span class="attr">watch</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 只有设置了 watch === true，watchOptions才有用</span></span><br><span class="line">    <span class="attr">watchOptions</span>: &#123;</span><br><span class="line">        <span class="comment">// 不监听的文件或文件夹，支持正则，默认为空</span></span><br><span class="line">        <span class="attr">ignored</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        <span class="comment">// 监听到改变后的延时，默认300ms</span></span><br><span class="line">        <span class="attr">aggregateTimeout</span>: <span class="number">300</span>,</span><br><span class="line">        <span class="comment">// 轮询间隔，默认1000ms</span></span><br><span class="line">        <span class="attr">poll</span>: <span class="number">1000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="热更新"><a class="header-anchor" href="#热更新"></a>热更新</h1>
<h2 id="使用-v3"><a class="header-anchor" href="#使用-v3"></a>使用</h2>
<p>热更新需要使用到插件<code>webpack-dev-server</code>(WDS)，WDS使用时需要配合插件<code>HotModuleReplacementPlugin</code>一起使用（这个插件会在配置<code>hot: true</code>自动添加，可以不手动添加）<br>
首先，先安装WDS：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i webpack-dev-server -D</span><br></pre></td></tr></table></figure>
<p>使用时，在<code>webpack.config.js</code>中配置下devServer：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">contentBase</span>: <span class="string">&#x27;./dist&#x27;</span>, <span class="comment">// WDS的基础目录</span></span><br><span class="line">        <span class="attr">hot</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后使用命令<code>webpack-dev-server --open</code>启动即可</p>
<blockquote>
<p>–open：在构建结束后自动打开浏览器</p>
</blockquote>
<h2 id="原理-v2"><a class="header-anchor" href="#原理-v2"></a>原理</h2>
<p><img src="%E5%8E%9F%E7%90%86.png" alt=""></p>
<ul>
<li>webpack compiler: 将JS构建为Bundle</li>
<li>HMR Server: 将热更新的文件输出给HMR Runtime</li>
<li>Bundle Server: 提供文件在浏览器访问</li>
<li>HMR Runtime: 被注入到bundle.js中，更新文件变化</li>
<li>bundle.js: 构建输出的文件</li>
</ul>
<p>热更新中最核心的是HMR Server和HMR Runtime：<br>
<code>HMR Server</code>是服务端，用来将变化的 js 模块通过 websocket 的消息通知给浏览器端。<br>
<code>HMR Runtime</code>是浏览器端，用于接受 HMR Server 传递的模块数据，浏览器端可以看到 .hot-update.json 的文件。</p>
<p>热更新分为两个阶段：</p>
<ol>
<li>
<p>启动阶段：<br>
启动阶段就是在文件系统中，将初始代码通过<code>Webpack Compiler</code>打包，并将打包好的代码，传输给<code>Bundle Server</code>。Bundle Server其实就是一个服务器，通过Bundle Server，浏览器就能访问到打包好的文件。这个过程即图上的 1 -&gt; 2 -&gt; A -&gt; B</p>
</li>
<li>
<p>更新阶段：<br>
如果文件系统中的代码发生了改变，代码还是会经过<code>Webpack Compiler</code>打包，打包好了会把代码发送给<code>HMR Server</code>，HMR Server中能够对比得到具体是哪些文件发生了改变。接着HMR Server就会通知<code>HMR Runtime</code>，HMR Runtime就会更新代码，最终就可以不需要刷新浏览器就看到最新的代码。即图上的 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack构建情况分析</title>
    <url>/2020/01/09/46b6c5f5cf58/</url>
    <content><![CDATA[<p>本文介绍了如何分析 webpack 的构建情况，为后续的优化提供了基础。</p>
<span id="more"></span>
<h1 id="使用-webpack-内置的-stats"><a class="header-anchor" href="#使用-webpack-内置的-stats"></a>使用 webpack 内置的 stats</h1>
<p>启动 webpack 时使用以下带参的命令，生成一个json文件：<br>
<code>webpack --profile --json &gt; stats.json</code></p>
<p><code>--profile</code>：记录构建过程中的耗时信息<br>
<code>--json</code>：以JSON的格式输出构建结果</p>
<p>该文件的结构可参考<a href="https://webpack.docschina.org/api/stats/">官网文档</a></p>
<p>得到<code>stats.json</code>后，可使用官方工具 <a href="http://webpack.github.io/analyse/">Webpack Analyse</a> 对这个文件进行分析。<br>
在该工具中，能够得到类似的依赖图：<br>
<img src="%E4%BE%9D%E8%B5%96%E5%9B%BE.png" alt=""></p>
<p>由于<code>stats.json</code>的粒度较粗，比较难看出构建的问题所在。为此，我们可以使用以下两个方法，来具体分析构建的速度与体积。</p>
<h1 id="构建速度分析"><a class="header-anchor" href="#构建速度分析"></a>构建速度分析</h1>
<p>在 webpack 中，可以使用插件<a href="https://www.npmjs.com/package/speed-measure-webpack-plugin"><code>speed-measure-webpack-plugin</code></a>进行构建速度分析。</p>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i speed-measure-webpack-plugin -D</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">SpeedMeasureWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;speed-measure-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> smp = <span class="keyword">new</span> <span class="title class_">SpeedMeasureWebpackPlugin</span>()</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = smp.<span class="title function_">wrap</span>(&#123;</span><br><span class="line">  <span class="comment">// 原来的配置</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在导出的配置外面包裹上<code>smp.wrap</code>之后，再次运行构建，就能看到以下输出：<br>
<img src="smp.png" alt=""></p>
<p><code>SpeedMeasureWebpackPlugin</code>会将各个模块及插件的耗时情况用不同颜色标出，比如，绿色表示构建快，黄色表示构建速度一般，红色表示构建慢。</p>
<p>得到了各模块的耗时情况，就可以根据具体的情况进行优化。<br>
比如图中的<code>ExtractTextPlugin</code>耗时将近两分钟，我们就可以看下其中实现的代码，找出其中耗时的部分，fork 一份代码下来，根据自己的实际使用情况进行优化。<br>
再比如图中的<code>sass-loader</code>耗时24秒，我们就能试试如果用 less 是否能够更快一些。</p>
<h1 id="构建体积分析"><a class="header-anchor" href="#构建体积分析"></a>构建体积分析</h1>
<p>在 webpack 中，可以使用插件<a href="https://www.npmjs.com/package/webpack-bundle-analyzer"><code>webpack-bundle-analyzer</code></a>进行构建速度分析。</p>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i webpack-bundle-analyzer -D</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">BundleAnalyzerPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack-bundle-analyzer&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ... 其他配置</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BundleAnalyzerPlugin</span>(),</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构建之后，会自动打开<a href="http://127.0.0.1:8888/">http://127.0.0.1:8888/</a>，显示各个模块的体积大小：<br>
<img src="BundleAnalyzerPlugin.png" alt=""></p>
<p>从图上可以看出，react占据了绝大部分的体积。所以我们在优化的时候，可以考虑将react等库抽离出来，使用CDN等方式导入，以减小体积占用。</p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack构建速度优化</title>
    <url>/2020/01/11/7a0715d769ee/</url>
    <content><![CDATA[<p>本文介绍了几种优化 webpack 构建速度的方式。</p>
<span id="more"></span>
<h1 id="多进程"><a class="header-anchor" href="#多进程"></a>多进程</h1>
<p>优化构建速度，可以通过多进程/多线程同时构建的方式来进行优化，目前主要有 <code>Happypack</code> / <code>thread-loader</code> / <code>parallel-webpack</code> 这几个解决方案。本文主要介绍了前两种方案。</p>
<p>优化前的构建速度：<br>
<img src="before.png" alt=""></p>
<h2 id="使用-Happypack"><a class="header-anchor" href="#使用-Happypack"></a>使用 Happypack</h2>
<blockquote>
<p><a href="https://github.com/amireh/happypack">Github - amireh/happypack</a></p>
</blockquote>
<h3 id="原理-v3"><a class="header-anchor" href="#原理-v3"></a>原理</h3>
<p>happypack 会创建一个线程池，线程池会将构建任务里面的模块分配到不同线程上，各线程会去处理这个模块及其依赖。处理完成后，会将处理完成的资源传输给 happypack 的主进程，然后完成整个构建任务。参见下图：<br>
<img src="HappyPack_Workflow.png" alt=""></p>
<h3 id="安装及使用"><a class="header-anchor" href="#安装及使用"></a>安装及使用</h3>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i happypack -D</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HappyPack</span> = <span class="built_in">require</span>(<span class="string">&#x27;happypack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">        <span class="attr">use</span>: <span class="string">&#x27;happypack/loader&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HappyPack</span>(&#123;</span><br><span class="line">      <span class="attr">loaders</span>: [<span class="string">&#x27;babel-loader&#x27;</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用后构建速度：<br>
<img src="happypack.png" alt=""><br>
可以看到，happypack 开启了三个线程进行构建，大幅度地缩减了构建时间。</p>
<h2 id="thread-loader"><a class="header-anchor" href="#thread-loader"></a>thread-loader</h2>
<blockquote>
<p><a href="https://github.com/webpack-contrib/thread-loader">Github - webpack-contrib/thread-loader</a></p>
</blockquote>
<h3 id="原理-v4"><a class="header-anchor" href="#原理-v4"></a>原理</h3>
<p>thread-loader 的原理与 happypack 类似，也是创建一个线程池，线程池会将构建任务里面的模块分配到不同线程上，各线程会去处理这个模块及其依赖。处理完成后，会将处理完成的资源传输给主进程，然后完成整个构建任务。</p>
<h3 id="安装及使用-v2"><a class="header-anchor" href="#安装及使用-v2"></a>安装及使用</h3>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i thread-loader -D</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HappyPack</span> = <span class="built_in">require</span>(<span class="string">&#x27;happypack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          <span class="string">&#x27;thread-loader&#x27;</span>, <span class="comment">// 默认开启 (cpu个数 - 1) 个线程</span></span><br><span class="line">          <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用后构建速度：<br>
<img src="thread-loader.png" alt=""><br>
可以看到，thread-loader 使用后也大幅度地缩减了构建时间。</p>
<h2 id="多进程并行压缩"><a class="header-anchor" href="#多进程并行压缩"></a>多进程并行压缩</h2>
<p>并行压缩代码，有两种方式：</p>
<ol>
<li>使用 parallel-uglify-plugin 插件</li>
<li>使用 terser-webpack-plugin 开启 parallel 参数</li>
</ol>
<h3 id="使用-parallel-uglify-plugin-插件"><a class="header-anchor" href="#使用-parallel-uglify-plugin-插件"></a>使用 parallel-uglify-plugin 插件</h3>
<blockquote>
<p><a href="https://github.com/gdborton/webpack-parallel-uglify-plugin">Github - gdborton/webpack-parallel-uglify-plugin</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ParallelUglifyPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;webpack-parallel-uglify-plugin&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ParallelUglifyPlugin</span>()</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-terser-webpack-plugin-开启-parallel-参数"><a class="header-anchor" href="#使用-terser-webpack-plugin-开启-parallel-参数"></a>使用 terser-webpack-plugin 开启 parallel 参数</h3>
<blockquote>
<p><a href="https://github.com/webpack-contrib/terser-webpack-plugin">Github - webpack-contrib/terser-webpack-plugin</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TerserPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;terser-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">minimize</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">minimizer</span>: [</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">TerserPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">parallel</span>: <span class="literal">true</span>, <span class="comment">// 布尔值或开启的线程数，默认值为 (cpu个数 - 1)</span></span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="缓存"><a class="header-anchor" href="#缓存"></a>缓存</h1>
<p>缓存对于首次构建并没有什么帮助，但是，可以充分利用缓存，提升二次构建的速度。<br>
开启缓存有三种方式：</p>
<ol>
<li>babel-loader 开启缓存 – bebal 转换 js 的时候的缓存</li>
<li>terser-webpack-plugin 开启缓存 – 代码压缩阶段的缓存</li>
<li>使用 hard-source-webpack-plugin – 模块转换阶段的缓存</li>
</ol>
<p>缓存的存储位置位于 <code>./node-modules/.cache</code> 。</p>
<h2 id="babel-loader-缓存"><a class="header-anchor" href="#babel-loader-缓存"></a>babel-loader 缓存</h2>
<p>设置 <code>babel-loader</code> 的 <code>cacheDirectory</code> 选项为 <code>true</code>，即可开启缓存：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">cacheDirectory</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次构建：<br>
<img src="babel-loader-first.png" alt=""><br>
第二次构建：<br>
<img src="babel-loader-second.png" alt=""></p>
<p>可以看到，开启缓存后，有小幅度优化。</p>
<h2 id="terser-webpack-plugin-缓存"><a class="header-anchor" href="#terser-webpack-plugin-缓存"></a>terser-webpack-plugin 缓存</h2>
<p>设置 <code>TerserPlugin</code> 的 <code>cache</code> 选项为 <code>true</code>，即可开启缓存：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">optimization</span>: &#123;</span><br><span class="line">  <span class="attr">minimize</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">minimizer</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">TerserPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">cache</span>: <span class="literal">true</span>, <span class="comment">// 开启缓存</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>第一次构建：<br>
<img src="terser-first.png" alt=""><br>
第二次构建：<br>
<img src="terser-second.png" alt=""></p>
<p>可以看到，开启缓存后，优化效果明显。</p>
<h2 id="hard-source-webpack-plugin-缓存"><a class="header-anchor" href="#hard-source-webpack-plugin-缓存"></a>hard-source-webpack-plugin 缓存</h2>
<p>添加插件 <code>hard-source-webpack-plugin</code> 即可开启缓存：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">HardSourceWebpackPlugin</span>()</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>第一次构建：<br>
<img src="hard-source-first.png" alt=""><br>
第二次构建：<br>
<img src="hard-source-second.png" alt=""></p>
<p>可以看到，开启缓存后，优化效果明显。</p>
<h1 id="预编译资源模块"><a class="header-anchor" href="#预编译资源模块"></a>预编译资源模块</h1>
<ol>
<li>在 <code>npm run build</code> 构建之前，先把一些基础包和业务包打包成一个文件</li>
<li>使用 <code>DllPlugin</code> 进行分包</li>
<li><code>DllPlugin</code> 把基础包打包成一个文件，然后全局暴露一个变量，需要在 html 引入进来</li>
<li><code>DllPlugin</code> 中的 <code>options[name]</code> 要和 <code>output[library]</code> 对应起来，不然会报一个引用错误</li>
<li>通过引入 <code>add-asset-html-webpack-plugin</code> 把已经打包的 js，通过 html 引入。注意不要和 <code>SpeedMeasurePlugin</code> 同时使用，会出错</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.dll.js -- 打包成 dll</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">library</span>: [<span class="string">&#x27;react&#x27;</span>, <span class="string">&#x27;react-dom&#x27;</span>] <span class="comment">// 要打包的库</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name].dll.js&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;build/library&#x27;</span>),</span><br><span class="line">        <span class="attr">library</span>: <span class="string">&#x27;[name]&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> webpack.<span class="title class_">DllPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;[name]&#x27;</span>,</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;./build/library/[name].manifest.json&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js -- 使用 dll</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AddAssetHtmlPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;add-asset-html-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">DllReferencePlugin</span>(&#123; <span class="comment">// 通过引用 .dll.js 中打包生成的 manifest,json 文件，来引用打包的库文件</span></span><br><span class="line">      <span class="attr">manifest</span>: <span class="built_in">require</span>(<span class="string">&#x27;./build/library/library.manifest.json&#x27;</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">AddAssetHtmlPlugin</span>(&#123; <span class="comment">// 把 .dll.js 文件添加到 html 中。注意！AddAssetHtmlPlugin 必须在 HtmlWebpackPlugin 后使用</span></span><br><span class="line">      <span class="attr">filepath</span>: path.<span class="title function_">resolve</span>(<span class="string">&#x27;./build/library/*.dll.js&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用前：<br>
<img src="dll-before.png" alt=""><br>
使用后：<br>
<img src="dll-after.png" alt=""><br>
<img src="dll-build.png" alt=""><br>
<img src="dll-html.png" alt=""></p>
<p>可以看到，构建体积明显小了很多。</p>
<h1 id="缩小构建目标"><a class="header-anchor" href="#缩小构建目标"></a>缩小构建目标</h1>
<p>可以通过减少构建的模块，来使构建速度得到一定的优化，比如 <code>babel-loader</code> 不解析 <code>node_modules</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">        <span class="attr">use</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">exclude</span>: <span class="string">&#x27;node_modules&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="减少文件搜索范围"><a class="header-anchor" href="#减少文件搜索范围"></a>减少文件搜索范围</h1>
<p>webpack 在解析文件时，会逐层往上找，比如 <code>require('react')</code> ，会先搜索当前目录下是否存在 <code>react.js/.json</code> 等文件，没找到的话，再到 <code>node_modules</code> 及上层目录中找，较为耗时。</p>
<p>因此，可以指定搜索范围来减少这种不必要的搜索。主要有以下4点：</p>
<ol>
<li>优化 <code>resolve.modules</code> 配置：指定模块查找位置</li>
<li>优化 <code>resolve.mainFileds</code> 配置：模块入口文件字段</li>
<li>优化 <code>resolve.extensions</code> 配置：缺少扩展名时，尝试补齐的文件类型</li>
<li>使用 <code>alias</code>：模块位置</li>
</ol>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;react&#x27;</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./node_modules/react/umd/react.production.min.js&#x27;</span>),</span><br><span class="line">      <span class="string">&#x27;react-dom&#x27;</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./node_modules/react-dom/umd/react-dom.production.min.js&#x27;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">modules</span>: [path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>), <span class="string">&#x27;node_modules&#x27;</span>],</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.jsx&#x27;</span>],</span><br><span class="line">    <span class="attr">mainFields</span>: [<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack的几个核心概念</title>
    <url>/2019/11/17/b4d52620527b/</url>
    <content><![CDATA[<h1 id="什么是webpack"><a class="header-anchor" href="#什么是webpack"></a>什么是webpack</h1>
<p><code>webpack</code>本质上是一个打包工具，它会根据代码的内容解析模块依赖，帮助我们把多个模块的代码打包。下面是<a href="https://www.webpackjs.com/">webpack官网</a>给的一个说明图。<br>
<img src="./webpack%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/introduction.png" alt="webpack-introduction"><br>
如上图，webpack 会把项目中使用到的多个代码模块（可以是不同文件类型），打包构建成项目运行仅需要的几个静态文件（如.js、.css等）。</p>
<span id="more"></span>
<h1 id="webpack-安装"><a class="header-anchor" href="#webpack-安装"></a>webpack 安装</h1>
<p>webpack支持使用<code>npm</code>或者<code>yarn</code>方式进行安装，当然也可以作为一个全局的命令来使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install webpack webpack-cli -g </span><br><span class="line"></span><br><span class="line"># 或者yarn global add webpack webpack-cli</span><br></pre></td></tr></table></figure>
<h1 id="webpack的几个核心概念"><a class="header-anchor" href="#webpack的几个核心概念"></a>webpack的几个核心概念</h1>
<p>webpack的配置文件通常为<code>webpack.config.js</code>，放置于项目的根目录中。此外，也能够使用<code>webpack --config</code>来指定使用的配置文件。<br>
一个简单的配置文件如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="title function_">requore</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,  <span class="comment">// 指定入口文件</span></span><br><span class="line">    <span class="attr">output</span>: &#123;  <span class="comment">// 指定输出文件</span></span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;/dist&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,  <span class="comment">// 指定构建环境</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: []  <span class="comment">// 配置loaders</span></span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="attr">plugins</span>: []  <span class="comment">// 配置plugins</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="entry"><a class="header-anchor" href="#entry"></a>entry</h2>
<blockquote>
<p><code>entry</code> 用于指定打包入口。目前入口文件只支持<code>js</code>，其它的如<code>html</code>和<code>css</code>都不支持。</p>
</blockquote>
<p>webpack会把<code>js</code>、<code>css</code>、<code>图片</code>等等当成一个个模块，各模块间会存在一系列的依赖关系，在webpack里面，会根据<code>entry</code>指定的文件，找到依赖，<code>entry</code>文件的依赖也可能会以来其他模块，这样就会生成一棵<code>依赖树</code>。webpack会遍历这课依赖树，遍历完了才会生成打包资源。</p>
<p>entry可以指定单入口与多入口。</p>
<h3 id="单入口"><a class="header-anchor" href="#单入口"></a>单入口</h3>
<p>单入口适用于单页应用，其使用一个字符串来给定入口文件的地址，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">entry: &#x27;./src/index.js&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="多入口"><a class="header-anchor" href="#多入口"></a>多入口</h3>
<p>多入口适用于多页应用，其使用一个对象来给定入口文件的地址，该对象为键值对的形式，键为入口模块的名字，值为文件地址如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    app: &#x27;./src/app.js&#x27;,</span><br><span class="line">    search: &#x27;./src/search.js&#x27;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="output"><a class="header-anchor" href="#output"></a>output</h2>
<blockquote>
<p><code>output</code> 指定编译后的文件如何输出到磁盘，注意，即使可以存在多个<code>entry</code>起点，但只能指定一个<code>output</code>配置。</p>
</blockquote>
<p><code>output</code>的值必须为一个对象，并且包含以下两个属性：</p>
<ol>
<li><code>filename</code> 用于输出文件的文件名。</li>
<li><code>path</code> 用于指定目标输出文件的<strong>绝对</strong>路径。</li>
</ol>
<p>示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: &#x27;bundle.js&#x27;,</span><br><span class="line">    path: path.resolve(__dirname, &#x27;dist&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">// 此配置将生成一个单独的 bundle.js 文件输出到项目的 /dist 目录中。</span><br></pre></td></tr></table></figure>
<p>以上示例是针对单入口的配置。如果是多入口，可以使用<a href="https://www.webpackjs.com/configuration/output/#output-filename">占位符</a><code>[name]</code>来确保每个文件具有唯一的名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    app: &#x27;./src/app.js&#x27;,</span><br><span class="line">    search: &#x27;./src/search.js&#x27;</span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">    filename: &#x27;[name].js&#x27;,</span><br><span class="line">    path: path.resolve(__dirname, &#x27;dist&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">// 此配置将生成两个文件 ./dist/app.js, ./dist/search.js。</span><br></pre></td></tr></table></figure>
<h2 id="loaders"><a class="header-anchor" href="#loaders"></a>loaders</h2>
<blockquote>
<p>webpack原生只支持js和json，通过<code>loaders</code>去支持其他文件类型，如css，并把他们转化为有效模块，并可以添加到依赖图中。</p>
</blockquote>
<p><code>loader</code>本身是一个函数，接受源文件为参数，返回转换后的结果。</p>
<h3 id="常见的loader"><a class="header-anchor" href="#常见的loader"></a>常见的loader</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>用处</th>
</tr>
</thead>
<tbody>
<tr>
<td>babel-loader</td>
<td>转换ES6/ES7等JS新特性语法</td>
</tr>
<tr>
<td>css-loader</td>
<td>支持.css的解析和加载</td>
</tr>
<tr>
<td>less-loader</td>
<td>将less转换为css</td>
</tr>
<tr>
<td>ts-loader</td>
<td>将TS转换为JS</td>
</tr>
</tbody>
</table>
<h3 id="用法-v2"><a class="header-anchor" href="#用法-v2"></a>用法</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [ // 将需要的loader放在module对象的rules数组中</span><br><span class="line">         &#x27;bable-loader&#x27;, // 可以直接使用loader名称</span><br><span class="line">        &#123; test: /\.txt$/, use: &#x27;raw-loader&#x27; &#125;, // test - 指定匹配规则，use - 指定使用的loader名称</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="plugins"><a class="header-anchor" href="#plugins"></a>plugins</h2>
<blockquote>
<p><code>plugin</code>用于bundle文件的优化，资源管理和环境变量的引入，作用于整个构建过程</p>
</blockquote>
<h3 id="常见的plugin"><a class="header-anchor" href="#常见的plugin"></a>常见的plugin</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>用处</th>
</tr>
</thead>
<tbody>
<tr>
<td>cleanWebpackPlugin</td>
<td>清理构建目录</td>
</tr>
<tr>
<td>miniCssExtractPlugin</td>
<td>将CSS从bundle里提取成一个独立的css文件</td>
</tr>
<tr>
<td>htmlWebpackPlugin</td>
<td>创建html文件</td>
</tr>
<tr>
<td>uglifyjsWebpackPlugin</td>
<td>压缩js</td>
</tr>
</tbody>
</table>
<h3 id="用法-v3"><a class="header-anchor" href="#用法-v3"></a>用法</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins: [ // 将使用的plugin放到plugins数组中</span><br><span class="line">    new HtmlWebpackPlugin(&#123; template: &#x27;./src/index.html&#x27; &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="mode"><a class="header-anchor" href="#mode"></a>mode</h2>
<blockquote>
<p><code>mode</code>用于指定当前构建环境，可取值为：development / production / none</p>
</blockquote>
<p>设置<code>mode</code>可以使用webpack的一些内置函数。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>development</td>
<td>设置<code>process.env.NODE_ENV</code>的值为<code>development</code>，开启<code>NamedChunksPlugin</code>和<code>NamedModulesPlugin</code></td>
</tr>
<tr>
<td>production</td>
<td>设置<code>process.env.NODE_ENV</code>的值为<code>production</code>，开启<code>FlagDependencyUsagePlugin</code>，<code>FlagIncludedChunksPlugin</code>，<code>ModuleConcatenationPlugin</code>，<code>NoEmitOnErrorPlugin</code>，<code>OccurrenceOrderPlugin</code>，<code>SideEffectsFlagPlugin</code>，<code>TerserPlugin</code></td>
</tr>
<tr>
<td>none</td>
<td>不开启任何优化选项</td>
</tr>
</tbody>
</table>
<h1 id="关于path-resolve-…paths"><a class="header-anchor" href="#关于path-resolve-…paths"></a>关于path.resolve([…paths])</h1>
<blockquote>
<p>将路径或路径片段处理成绝对路径。</p>
</blockquote>
<p>path 从右到左依次处理，直到构造出绝对路径。 例如，指定的路径片段是：/foo、/bar、baz，则调用 <code>path.resolve('/foo', '/bar', 'baz')</code> 会返回 <code>/bar/baz</code>。<br>
如果处理完全部 path 片段后还未产生绝对路径，则加上当前工作目录。<br>
生成的路径会进行规范化，并且删除末尾的斜杠，除非路径是根目录。<br>
空字符串的 path 片段会被忽略。<br>
如果没有指定 path，则返回当前工作目录的绝对路径。<br>
Node.js 中，<code>__dirname</code>总是指向被执行 js 文件的绝对路径，所以当在 /d1/d2/myscript.js 文件中写了 <code>__dirname</code>， 它的值就是 /d1/d2 。</p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>使用webpack解析一些常见资源</title>
    <url>/2019/11/17/91cd32cdd6b4/</url>
    <content><![CDATA[<p>本文介绍了如何使用webpack解析ES6、JSX、CSS等资源</p>
<span id="more"></span>
<h1 id="解析ES6"><a class="header-anchor" href="#解析ES6"></a>解析ES6</h1>
<p>解析es6需要使用到<code>babel</code>，同时需要使用<code>babel-loader</code><br>
首先，先配置<code>babel</code>配置文件<code>.babelrc</code>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;@babel/preset-env&quot;</span>  <span class="comment">// 增加ES6的babel preset配置</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>.babelrc</code>文件中的<code>plugins</code>字段，可以理解为一个plugin对应一个功能，<br>
而<code>presets</code>则是多个plugin的集合</p>
</blockquote>
<p>接着需要在<code>webpack.config.js</code>中增加相关loader的配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                <span class="attr">use</span>: <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后安装相关依赖：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i @babel/core @babel/preset-env babel-loader -D</span><br></pre></td></tr></table></figure>
<p>安装完毕重新编译下即可。</p>
<h1 id="解析React-JSX"><a class="header-anchor" href="#解析React-JSX"></a>解析React JSX</h1>
<p>首先，先配置<code>babel</code>配置文件<code>.babelrc</code>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;@babel/preset-env&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;@babel/preset-react&quot;</span> <span class="comment">// 增加react jsx的babel preset配置</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>接着在<code>webpack.config.js</code>中修改<code>babel-loader</code>的校验规则：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.jsx?$/</span>,  <span class="comment">// js、jsx文件</span></span><br><span class="line">                <span class="attr">use</span>: <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后安装相关依赖：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i @babel/preset-react -D</span><br></pre></td></tr></table></figure>
<p>安装完毕即可使用react的jsx相关语法。</p>
<h1 id="解析CSS"><a class="header-anchor" href="#解析CSS"></a>解析CSS</h1>
<p>解析CSS需要用到两个loader：</p>
<ol>
<li><code>css-loader</code>加载css文件，并转换为commonJS对象</li>
<li><code>style-loader</code>将样式通过<code>&lt;style&gt;</code>标签插入到head中</li>
</ol>
<p>在<code>webpack.config.js</code>中修改loader配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，loaders链式调用，<code>从右到左</code>，所以先写style-loader，再写css-loader</p>
</blockquote>
<p>然后安装相关依赖：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i style-loader css-loader -D</span><br></pre></td></tr></table></figure>
<h1 id="解析Less、Sass"><a class="header-anchor" href="#解析Less、Sass"></a>解析Less、Sass</h1>
<p>Less和Sass的解析步骤与CSS类似，只需要多一步将Less/Sass转换为CSS即可。<br>
配置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>, <span class="comment">// sass和scss文件</span></span><br><span class="line">                <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;sass-loader&#x27;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<code>less-loader</code>需要一同安装<code>less</code>；<code>sass-loader</code>需要一同安装<code>node-sass</code></p>
<h1 id="解析图片、字体等"><a class="header-anchor" href="#解析图片、字体等"></a>解析图片、字体等</h1>
<p>解析图片、字体等文件，可使用<code>file-loader</code>或<code>url-loader</code>。<br>
<code>url-loader</code>底层也是调用的<code>file-loader</code>。<br>
在使用上，<code>url-loader</code>可以将小资源以Base64的方式编码到文件中，减少文件数，使用方法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|ttf)$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [&#123;</span><br><span class="line">                    <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">                    <span class="attr">options</span>: &#123;</span><br><span class="line">                        <span class="attr">limit</span>: <span class="number">10240</span> <span class="comment">// = 10KB</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>可视化 - 数学基础</title>
    <url>/2022/05/27/40482e3237dd/</url>
    <content><![CDATA[<p>本文介绍了可视化中涉及到的一些数学基础知识。</p>
<span id="more"></span>
<h1 id="概述-v15"><a class="header-anchor" href="#概述-v15"></a>概述</h1>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器的同源策略</title>
    <url>/2019/03/24/ebef6b46e9ad/</url>
    <content><![CDATA[<p>浏览器的<strong>同源策略</strong>是一个用于隔离潜在恶意文件的重要安全机制，其限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。<br>
本文介绍了同源策略的几个方面，以及如何避免。</p>
<span id="more"></span>
<h1 id="概述-v16"><a class="header-anchor" href="#概述-v16"></a>概述</h1>
<h2 id="什么是同源"><a class="header-anchor" href="#什么是同源"></a>什么是同源</h2>
<p>所谓的“同源”， 指的是“三个相同”，即：</p>
<blockquote>
<ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同</li>
</ul>
</blockquote>
<p>举例来说，<code>https://www.a.com/bbb/ccc.html</code>这个网址，协议为<code>https://</code>，域名为<code>www.a.com</code>，端口为<code>80</code>（默认的80端口可省略）。以下几个网址与之的同源情况为：</p>
<blockquote>
<ul>
<li><a href="https://www.a.com/xxx/yyy.html">https://www.a.com/xxx/yyy.html</a> -&gt; 同源</li>
<li><a href="http://www.a.com/bbb/ccc.html">http://www.a.com/bbb/ccc.html</a> -&gt; 不同源，协议不同</li>
<li><a href="https://m.a.com/bbb/ccc.com">https://m.a.com/bbb/ccc.com</a> -&gt; 不同源，域名不同</li>
<li><a href="https://www.a.com:8080/bbb/ccc.html">https://www.a.com:8080/bbb/ccc.html</a> -&gt; 不同源，端口不同</li>
</ul>
</blockquote>
<h2 id="同源的目的"><a class="header-anchor" href="#同源的目的"></a>同源的目的</h2>
<p>同源策略的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>
<h2 id="同源的限制范围"><a class="header-anchor" href="#同源的限制范围"></a>同源的限制范围</h2>
<p>目前，如果非同源，共有三种行为受到限制。</p>
<blockquote>
<ul>
<li>Cookie、LocalStorage 和 IndexDB 无法读取。</li>
<li>DOM 无法获得。</li>
<li>AJAX 请求不能发送。</li>
</ul>
</blockquote>
<p>以下将分别介绍如何避免这三个限制</p>
<h1 id="Cookies"><a class="header-anchor" href="#Cookies"></a>Cookies</h1>
<blockquote>
<p>服务器写入浏览器的一小段信息，只有同源的网页才能共享。</p>
</blockquote>
<p>但是，如果两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置<code>document.domain</code>共享 Cookie。</p>
<p>举例来说，A网页是<code>https://www.a.com/bbb/ccc.html</code>，B网页是<code>https://m.a.com/xxx/yyy.html</code>，那么，只要设置相同的<code>document.domain</code>，这两个网页就可以共享Cookies了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为两个页面设置相同的 document.domain</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&#x27;a.com&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>现在，A网页内通过脚本设置一个Cookies</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookies</span> = <span class="string">&quot;test1=hello&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookies</span> = <span class="string">&quot;test2=world&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>B网页就可以读取到这个Cookies了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> allCookies = <span class="variable language_">document</span>.<span class="property">cookies</span>; <span class="comment">// test1=hello;test2=world</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：<code>document.domain</code>不能随意设置，只能把<code>document.domain</code>设置成自身或更高一级的父域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.a.com/bbb/ccc.html页面下</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&quot;b.com&quot;</span>;</span><br><span class="line"><span class="comment">// Uncaught DOMException: Failed to set the &#x27;domain&#x27; property on &#x27;Document&#x27;: &#x27;b.com&#x27; is not a suffix of &#x27;www.a.com&#x27;.</span></span><br></pre></td></tr></table></figure>
<p>此外，这种方法只适用于Cookie和iframe窗口，LocalStorage和IndexDB无法通过这种方法来规避同源策略，而要使用下文介绍的PostMessage API。</p>
<p>另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如<code>.a.com</code>。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>key=value; domain=.a.com; path=/</span><br></pre></td></tr></table></figure>
<p>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。</p>
<p>PS：如果两个网址，协议不同或端口不同，其Cookies可共享，即：Cookie共享跟协议、端口无关</p>
<h1 id="跨域文档通信"><a class="header-anchor" href="#跨域文档通信"></a>跨域文档通信</h1>
<blockquote>
<p>如果两个网页不同源，就无法拿到对方的<code>DOM</code>，也无法进行通信。典型的例子是<code>iframe</code>窗口和<code>window.open</code>方法打开的窗口，它们与父窗口无法通信。</p>
</blockquote>
<p>比如，父窗口运行下面的命令，如果<code>iframe</code>窗口不是同源，就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myIFrame&quot;</span>).<span class="property">contentWindow</span>.<span class="property">document</span></span><br><span class="line"><span class="comment">// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame.</span></span><br></pre></td></tr></table></figure>
<p>上面命令中，父窗口想获取子窗口的DOM，因为跨源导致报错。</p>
<p>反之亦然，子窗口获取主窗口的DOM也会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">parent</span>.<span class="property">document</span>.<span class="property">body</span></span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的<code>document.domain</code>属性，就可以规避同源策略，拿到<code>DOM</code>。</p>
<p>对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。</p>
<blockquote>
<ul>
<li>片段识别符（fragment identifier）</li>
<li><a href="http://window.name">window.name</a></li>
<li>window.postMessage</li>
</ul>
</blockquote>
<h2 id="片段识别符（fragment-identifier）"><a class="header-anchor" href="#片段识别符（fragment-identifier）"></a>片段识别符（fragment identifier）</h2>
<blockquote>
<p>片段标识符（fragment identifier）指的是，URL的<code>#</code>号后面的部分，比如<code>https://www.a.com/bbb/ccc.html#fragment</code>的<code>#fragment</code>。如果只是改变片段标识符，页面不会重新刷新。</p>
</blockquote>
<p>父窗口可以把信息，写入子窗口的片段标识符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> src = originURL + <span class="string">&#x27;#&#x27;</span> + data;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myIFrame&#x27;</span>).<span class="property">src</span> = src;</span><br></pre></td></tr></table></figure>
<p>子窗口通过监听<code>hashchange</code>事件得到通知。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onhashchange</span> = checkMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，子窗口也可以改变父窗口的片段标识符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">parent.<span class="property">location</span>.<span class="property">href</span>= target + <span class="string">&quot;#&quot;</span> + hash;</span><br></pre></td></tr></table></figure>
<h2 id="window-name"><a class="header-anchor" href="#window-name"></a><a href="http://window.name">window.name</a></h2>
<p>浏览器窗口有<code>window.name</code>属性。这个属性的最大特点是，只要当前的这个浏览器<code>tab</code>没有关闭，无论<code>tab</code>内的网页如何变动，这个<code>name</code>值都可以保持，并且<code>tab</code>内的每个网页都是可以接收和设置<code>window.name</code>这个值的。</p>
<blockquote>
<ul>
<li>F5刷新多少次都可以，这是无所谓的。</li>
<li>中间跳转过多少个页面，这也是无所谓的。</li>
<li>承载过的这些页面是不是同一个域名，这都是无所谓的。</li>
</ul>
</blockquote>
<p>上述的<code>tab</code>，改成<code>iframe</code>同样可行。<br>
父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入<code>window.name</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在子窗口中设置其window.name</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = data;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接着，子窗口跳回一个与主窗口同域的网址。</span></span><br><span class="line">location = <span class="string">&#x27;http://parent.url.com/xxx.html&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>然后，主窗口就可以读取子窗口的<code>window.name</code>了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主窗口中</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myFrame&#x27;</span>).<span class="property">contentWindow</span>.<span class="property">name</span>;</span><br></pre></td></tr></table></figure>
<p>这种方法的优点是，<code>window.name</code>容量很大，可以放置非常长的字符串；缺点是必须监听子窗口<code>window.name</code>属性的变化，影响网页性能。</p>
<h2 id="window-postMessage"><a class="header-anchor" href="#window-postMessage"></a>window.postMessage</h2>
<blockquote>
<p>在HTML5中，为了实现跨源通信，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。<br>
这个API为<code>window</code>对象新增了一个<code>window.postMessage</code>方法，允许跨窗口通信，不论这两个窗口是否同源。</p>
</blockquote>
<p>其语法为：</p>
<blockquote>
<p>otherWindow.postMessage(message, targetOrigin, [transfer]);</p>
</blockquote>
<ul>
<li>
<p>otherWindow<br>
其他窗口的一个引用，比如<code>iframe</code>的<code>contentWindow</code>属性、执行<code>window.open</code>返回的窗口对象、或者是命名过或数值索引的<code>window.frames</code>。</p>
</li>
<li>
<p>message<br>
将要发送到其他<code>window</code>的数据。该参数可传入一个<code>Object</code>.</p>
</li>
<li>
<p>targetOrigin<br>
通过窗口的<code>origin</code>属性来指定哪些窗口能接收到消息事件，其值可以是字符串<code>*</code>（表示无限制）或者<code>一个URI</code>。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配<code>targetOrigin</code>提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用<code>postMessage</code>传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的<code>origin</code>属性完全一致，来防止密码被恶意的第三方截获。如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的<code>targetOrigin</code>，而不是<code>*</code>。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。</p>
</li>
<li>
<p>transfer 可选<br>
是一串和<code>message</code>同时传递的<code>Transferable</code>对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</p>
</li>
</ul>
<p>举例来说，父窗口<code>http://a.com</code>向子窗口<code>http://b.com</code>发消息，调用<code>postMessage</code>方法就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父窗口中</span></span><br><span class="line"><span class="keyword">var</span> popup = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;http://b.com&#x27;</span>, <span class="string">&#x27;title&#x27;</span>);</span><br><span class="line">popup.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello World!&#x27;</span>, <span class="string">&#x27;http://b.com&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>子窗口向父窗口发送消息的写法类似。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子窗口中</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">opener</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;I get!&#x27;</span>, <span class="string">&#x27;http://a.com&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>父窗口和子窗口都可以通过message事件，监听对方的消息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p><code>message</code>事件的事件对象<code>event</code>，提供以下三个属性。</p>
<blockquote>
<ul>
<li>event.source：对发送消息的窗口对象的引用；可以使用此来在具有不同<code>origin</code>的两个窗口之间建立双向通信。</li>
<li>event.origin：调用<code>postMessage</code>时消息发送方窗口的<code>origin</code>。这个字符串由<code>协议</code>、<code>://</code>、<code>域名</code>、<code>:端口号</code>拼接而成。这个<code>origin</code>不能保证是该窗口的<code>当前或未来origin</code>，因为<code>postMessage</code>被调用后可能被导航到不同的位置。</li>
<li>event.data：从其他<code>window</code>中传递过来的消息内容对象。</li>
</ul>
</blockquote>
<p>子窗口可以通过<code>event.source</code>属性引用父窗口，然后发送消息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子窗口中</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, receiveMessage);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">receiveMessage</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="property">source</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;Nice to see you!&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>event.origin</code>属性可以过滤不是发给本窗口的消息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, receiveMessage);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">receiveMessage</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">origin</span> !== <span class="string">&#x27;http://aaa.com&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">data</span> === <span class="string">&#x27;Hello World&#x27;</span>) &#123;</span><br><span class="line">      event.<span class="property">source</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello&#x27;</span>, event.<span class="property">origin</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：任何窗口可以在任何其他窗口访问此方法，在任何时间，无论文档在窗口中的位置，向其发送消息。 因此，用于接收消息的任何事件监听器<code>必须</code>首先使用<code>origin</code>和<code>source</code>属性来检查消息的发送者的身份。<strong>无法检查origin和source属性会导致跨站点脚本攻击。</strong></p>
<p>因为有了<code>window.postMessage</code>，读写其他窗口的<code>LocalStorage</code>也成为了可能。</p>
<p>下面是一个例子，主窗口写入iframe子窗口的<code>localStorage</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子窗口中</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">origin</span> !== <span class="string">&#x27;http://aaa.com&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> payload = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(e.<span class="property">data</span>);</span><br><span class="line">  <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(payload.<span class="property">key</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(payload.<span class="property">data</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，子窗口将父窗口发来的消息，写入自己的<code>localStorage</code>。</p>
<p>父窗口发送消息的代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> win = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;iframe&#x27;</span>)[<span class="number">0</span>].<span class="property">contentWindow</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span> &#125;;</span><br><span class="line">win.<span class="title function_">postMessage</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">key</span>: <span class="string">&#x27;storage&#x27;</span>, <span class="attr">data</span>: obj&#125;), <span class="string">&#x27;http://bbb.com&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>加强版的子窗口接收消息的代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">origin</span> !== <span class="string">&#x27;http://aaa.com&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">var</span> payload = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(e.<span class="property">data</span>);</span><br><span class="line">  <span class="keyword">switch</span> (payload.<span class="property">method</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;set&#x27;</span>:</span><br><span class="line">      <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(payload.<span class="property">key</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(payload.<span class="property">data</span>));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;get&#x27;</span>:</span><br><span class="line">      <span class="keyword">var</span> parent = <span class="variable language_">window</span>.<span class="property">parent</span>;</span><br><span class="line">      <span class="keyword">var</span> data = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(payload.<span class="property">key</span>);</span><br><span class="line">      parent.<span class="title function_">postMessage</span>(data, <span class="string">&#x27;http://aaa.com&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;remove&#x27;</span>:</span><br><span class="line">      <span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(payload.<span class="property">key</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>加强版的父窗口发送消息代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> win = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;iframe&#x27;</span>)[<span class="number">0</span>].<span class="property">contentWindow</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">// 存入对象</span></span><br><span class="line">win.<span class="title function_">postMessage</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">key</span>: <span class="string">&#x27;storage&#x27;</span>, <span class="attr">method</span>: <span class="string">&#x27;set&#x27;</span>, <span class="attr">data</span>: obj&#125;), <span class="string">&#x27;http://bbb.com&#x27;</span>);</span><br><span class="line"><span class="comment">// 读取对象</span></span><br><span class="line">win.<span class="title function_">postMessage</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">key</span>: <span class="string">&#x27;storage&#x27;</span>, <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>&#125;), <span class="string">&#x27;http://bbb.com&#x27;</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">origin</span> != <span class="string">&#x27;http://bbb.com&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// &quot;Jack&quot;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(e.<span class="property">data</span>).<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="AJAX"><a class="header-anchor" href="#AJAX"></a>AJAX</h1>
<p>同源策略规定，AJAX请求只能发给同源的网址，否则就报错。<br>
规避这个限制有以下几种方法：</p>
<blockquote>
<ul>
<li>使用Flash插件发送HTTP请求</li>
<li>架设服务器代理</li>
<li>JSONP</li>
<li>WebSocket</li>
<li>CORS</li>
</ul>
</blockquote>
<h2 id="使用Flash插件发送HTTP请求"><a class="header-anchor" href="#使用Flash插件发送HTTP请求"></a>使用Flash插件发送HTTP请求</h2>
<p>这种方式可以绕过浏览器的安全限制，但必须安装Flash，并且跟Flash交互。不过Flash用起来麻烦，而且现在用得也越来越少了。</p>
<h2 id="架设服务器代理"><a class="header-anchor" href="#架设服务器代理"></a>架设服务器代理</h2>
<p>在同源域名下架设一个代理服务器来转发，JavaScript负责把请求发送到代理服务器：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">&#x27;/proxy?url=http://www.sina.com.cn&#x27;</span><br></pre></td></tr></table></figure>
<p>代理服务器再把结果返回，这样就遵守了浏览器的同源策略。这种方式麻烦之处在于需要服务器端额外做开发。</p>
<h2 id="JSONP"><a class="header-anchor" href="#JSONP"></a>JSONP</h2>
<p>JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。</p>
<p>它的基本思想是，网页通过添加一个<code>&lt;script&gt;</code>标签，向服务器请求JSON数据，这种做法不受同源策略限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。它有个限制，<code>只能</code>用<code>GET</code>请求，并且要求返回JavaScript。（因为<code>&lt;script&gt;</code>标签只能使用<code>GET</code>加载资源）</p>
<p>JSONP通常以函数调用的形式返回。例如，调用某一接口，返回JavaScript内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">foo</span>(&#123;<span class="attr">test</span>: <span class="string">&quot;hello&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>因此我们需要首先在页面中准备好回调函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(data.<span class="property">test</span>);</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用另一函数<code>getData()</code>触发：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getPrice</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    script.<span class="property">src</span> = <span class="string">&#x27;http://api.a.com/?callback=foo&#x27;</span>; <span class="comment">// 注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。一般参数名由API接口确定，常用为callback。</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>&lt;script&gt;</code>标签请求的脚本，直接作为代码运行。这时，只要浏览器定义了<code>foo</code>函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用<code>JSON.parse</code>的步骤。</p>
<h2 id="WebSocket"><a class="header-anchor" href="#WebSocket"></a>WebSocket</h2>
<p>WebSocket是一种通信协议，使用<code>ws://</code>（非加密）和<code>wss://</code>（加密）作为协议前缀。该协议不实行同源策略，只要服务器支持，就可以通过它进行跨源通信。</p>
<p>下面是一个例子，浏览器发出的WebSocket请求的头信息（摘自<a href="https://en.wikipedia.org/wiki/WebSocket">维基百科</a>）。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/chat</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>server.example.com</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span><span class="punctuation">: </span>x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span><span class="punctuation">: </span>chat, superchat</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span><span class="punctuation">: </span>13</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://example.com</span><br></pre></td></tr></table></figure>
<p>上面代码中，有一个字段是<code>Origin</code>，表示该请求的请求源（origin），即发自哪个域名。</p>
<p>正是因为有了<code>Origin</code>这个字段，所以WebSocket才没有实行同源策略。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span><span class="punctuation">: </span>HSmrc0sMlYUkAGmm5OPpG2HaGWk=</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span><span class="punctuation">: </span>chat</span><br></pre></td></tr></table></figure>
<h2 id="CORS"><a class="header-anchor" href="#CORS"></a>CORS</h2>
<p>CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源，是跨源AJAX请求的根本解决方法。相比JSONP只能发<code>GET</code>请求，CORS允许任何类型的请求。</p>
<p><code>Origin</code>表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如<code>sina.com</code>）发起请求后，浏览器收到响应后，首先检查<code>Access-Control-Allow-Origin</code>是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。</p>
<p>详细的介绍，可以参考<a href="/2019/04/03/cors/">此文</a></p>
<h1 id="参考-v5"><a class="header-anchor" href="#参考-v5"></a>参考</h1>
<p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">浏览器同源政策及其规避方法 - 阮一峰</a><br>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">浏览器的同源策略 - MDN</a><br>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage">window.postMessage - MDN</a><br>
<a href="https://newsn.net/say/window-name-msg.html">window.name 跨域隐式传递消息原理解析 - 苏南大叔</a><br>
<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499861493e7c35be5e0864769a2c06afb4754acc6000">AJAX - 廖雪峰</a></p>
]]></content>
      <tags>
        <tag>同源策略</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>可视化 - 图形基础</title>
    <url>/2022/02/12/12b509e6174f/</url>
    <content><![CDATA[<p>本文介绍了浏览器渲染引擎的4种绘制图形系统的基础知识。</p>
<span id="more"></span>
<h1 id="概述-v17"><a class="header-anchor" href="#概述-v17"></a>概述</h1>
<p>简单来说，可视化就是将数据信息组织起来，以图形的方式呈现出来。现代浏览器中负责绘制图形的部分是渲染引擎。其绘制方式大体可分为4种：</p>
<ol>
<li>传统的<strong>HTML + CSS</strong>。</li>
<li>使用<strong>SVG</strong>。SVG与HTML+CSS的方式差别不大，但是SVG可以弥补HTML在矢量图形绘制方面的能力不足。</li>
<li>使用<strong>Canvas2D</strong>。Canvas2D是浏览器Canvas API的一种上下文，可以使用其绘制出基础的几何图形。</li>
<li>使用<strong>WebGL</strong>。WebGL也是浏览器Canvas API提供的一种上下文，是 OpenGL ES 在Web的实现，通过它，我们可以使用 GPU 进行各种2D、3D图形的渲染。</li>
</ol>
<h1 id="传统的HTML-CSS"><a class="header-anchor" href="#传统的HTML-CSS"></a>传统的HTML + CSS</h1>
<p>在可视化的项目中，直接使用HTML与CSS的相对较少，但是可视化并不是不能使用HTML+CSS，相反，因为现代浏览器的HTML、CSS表现能力强大，一些常见的图表完全可以使用其实现，如柱状图、饼图等。</p>
<p>一些简单的可视化图表，用 CSS 来实现很有好处，既能简化开发，又不需要引入额外的库，可以节省资源，提高网页打开的速度。</p>
<h2 id="实现柱状图"><a class="header-anchor" href="#实现柱状图"></a>实现柱状图</h2>
<p>用 CSS 实现柱状图的方式有很多种，总结起来就是使用 线性渐变（<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient()">linear-gradient</a>）配合布局，实现出不同柱子的颜色。这边简单展示下对应代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bargraph&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bargraph</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">5</span>, <span class="number">20%</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bargraph</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 通过transparent实现柱子空白部分的展示，并通过调整不同色块的比例，进行高度调整 */</span></span><br><span class="line"><span class="selector-class">.bargraph</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123;</span><br><span class="line"> <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom, transparent <span class="number">75%</span>, <span class="number">#37c</span> <span class="number">0</span>, <span class="number">#37c</span> <span class="number">85%</span>, <span class="number">#3c7</span> <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bargraph</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line"> <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom, transparent <span class="number">74%</span>, <span class="number">#37c</span> <span class="number">0</span>, <span class="number">#37c</span> <span class="number">89%</span>, <span class="number">#3c7</span> <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bargraph</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span><br><span class="line"> <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom, transparent <span class="number">60%</span>, <span class="number">#37c</span> <span class="number">0</span>, <span class="number">#37c</span> <span class="number">83%</span>, <span class="number">#3c7</span> <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bargraph</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>) &#123;</span><br><span class="line"> <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom, transparent <span class="number">55%</span>, <span class="number">#37c</span> <span class="number">0</span>, <span class="number">#37c</span> <span class="number">75%</span>, <span class="number">#3c7</span> <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bargraph</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">5</span>) &#123;</span><br><span class="line"> <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom, transparent <span class="number">32%</span>, <span class="number">#37c</span> <span class="number">0</span>, <span class="number">#37c</span> <span class="number">63%</span>, <span class="number">#3c7</span> <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>展示效果如下：<br>
<img src="bargraph_css.png" alt=""></p>
<h2 id="实现饼图"><a class="header-anchor" href="#实现饼图"></a>实现饼图</h2>
<p>CSS实现饼图的方法也很简单，使用圆锥渐变（<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/conic-gradient()">conic-gradient</a>）即可，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;piegraph&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.piegraph</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">250px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">250px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="comment">/* 通过定义不同颜色的起始、结束角度，实现饼图效果 */</span></span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">conic-gradient</span>(<span class="number">#37c</span> <span class="number">30deg</span>, <span class="number">#3c7</span> <span class="number">30deg</span>, <span class="number">#3c7</span> <span class="number">65deg</span>, orange <span class="number">65deg</span>, orange <span class="number">110deg</span>, <span class="number">#f73</span> <span class="number">110deg</span>, <span class="number">#f73</span> <span class="number">200deg</span>, <span class="number">#ccc</span> <span class="number">200deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>展示效果如下：<br>
<img src="piegraph_css.png" alt=""></p>
<h2 id="用-HTML-CSS-实现可视化的缺点"><a class="header-anchor" href="#用-HTML-CSS-实现可视化的缺点"></a>用 HTML+CSS 实现可视化的缺点</h2>
<ol>
<li>因为HTML元素一般是矩形，虽然可以通过CSS进行绘制其他形状或不规则的图像，但是总体上还是非常麻烦的。</li>
<li>我们可以看出，通过CSS实现的图表中，大量的数据混杂在了CSS代码中，这导致我们很难看出某个数值与图形的关系，一旦图表或者数据发生改动时，需要开发人员进行重新计算或者对应，加大了维护成本。</li>
<li>另外，因为浏览器在渲染HTML+CSS时，需要进行HTML/CSS解析，生成DOM树等结构，然后进行绘制，当图形发生改变时，可能需要从头开始解析、渲染，这些性能开销是非常大的。</li>
</ol>
<h1 id="SVG"><a class="header-anchor" href="#SVG"></a>SVG</h1>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG">SVG</a>(Scalable Vector Graphics，可缩放矢量图)，是一种基于XML语法的图像格式。在浏览器中，可以像操作普通HTML元素一样，利用DOM API操作SVG元素，并且CSS也可以在SVG上生效。</p>
<p>对比HTML+CSS，在绘制图表时，SVG与其差别不大，只不过是将HTML标签换成SVG标签，使用了一些SVG支持的特殊属性。比如上述的柱状图，使用SVG实现如下：</p>
<figure class="highlight svg"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">width</span>=<span class="string">&quot;120px&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">height</span>=<span class="string">&quot;240px&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">viewBox</span>=<span class="string">&quot;0 0 60 100&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">g</span> <span class="attr">transform</span>=<span class="string">&quot;translate(0, 100) scale(1, -1)&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">g</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;1&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;10&quot;</span> <span class="attr">height</span>=<span class="string">&quot;25&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#37c&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;13&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;10&quot;</span> <span class="attr">height</span>=<span class="string">&quot;26&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#37c&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;25&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;10&quot;</span> <span class="attr">height</span>=<span class="string">&quot;40&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#37c&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;37&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;10&quot;</span> <span class="attr">height</span>=<span class="string">&quot;45&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#37c&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;49&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;10&quot;</span> <span class="attr">height</span>=<span class="string">&quot;68&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#37c&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">g</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;1&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;10&quot;</span> <span class="attr">height</span>=<span class="string">&quot;15&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#3c7&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;13&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;10&quot;</span> <span class="attr">height</span>=<span class="string">&quot;11&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#3c7&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;25&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;10&quot;</span> <span class="attr">height</span>=<span class="string">&quot;17&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#3c7&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;37&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;10&quot;</span> <span class="attr">height</span>=<span class="string">&quot;25&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#3c7&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;49&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;10&quot;</span> <span class="attr">height</span>=<span class="string">&quot;37&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#3c7&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>详细的SVG教程，可以查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial">MDN的官方文档</a>。</p>
<h2 id="SVG与HTML-CSS的对比"><a class="header-anchor" href="#SVG与HTML-CSS的对比"></a>SVG与HTML/CSS的对比</h2>
<p>对比HTML+CSS，SVG在在绘制复杂图像，如不规则图像等具有比较明显的优点，除了上述代码中的<code>rect</code>外，SVG还支持诸如圆弧、椭圆、多边形、贝塞尔曲线等。但是，同HTML一样。在浏览器中，SVG一样需要经过解析、渲染树生成等步骤。而且，一个SVG元素一般只表示在展示复杂图形时，生成的SVG元素就会很多，这样一来，对渲染的性能就会有很大影响，因此，SVG只适用于元素较少的场景。</p>
<h1 id="Canvas2D"><a class="header-anchor" href="#Canvas2D"></a>Canvas2D</h1>
<p>在使用 Canvas 进行绘制时，大致需要以下操作：</p>
<ol>
<li>在HTML内使用 <code>Canvas</code> 元素创建一个空白的画布。</li>
<li>在JS代码中获取该画布，并获取其渲染上下文。</li>
<li>使用上下文，设置各种属性，并调用绘图指令进行输出即可。</li>
</ol>
<p>这里，通过绘制一个正方形进行简单介绍。</p>
<h2 id="绘制"><a class="header-anchor" href="#绘制"></a>绘制</h2>
<h3 id="Canvas元素"><a class="header-anchor" href="#Canvas元素"></a>Canvas元素</h3>
<p>对于浏览器而言，Canvas也是一个HTML元素，直接使用 <code>canvas</code> 标签插入到HTML内即可</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">width</span>=<span class="string">&quot;512&quot;</span> <span class="attr">height</span>=<span class="string">&quot;512&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里有一点需要注意的是，Canvas元素上的<code>width</code>与<code>height</code>属性与CSS样式里的属性不完全相同。CSS中的宽高影响的是Canvas在页面上的显示大小（下文称为<strong>样式宽高</strong>），Canvas元素上的<code>width</code>与<code>height</code>属性影响的是Canvas中的坐标系（下文称为<strong>画布宽高</strong>）。如果未设置画布宽高，则默认为<code>300*150</code>。如果未设置样式宽高，则样式宽高默认等于画布宽高。</p>
<p>在上述这段代码中，这个Canvas的样式宽高就是 <code>512px * 512px</code>。</p>
<p>如果我们通过CSS设置了其宽高，比如我们设置为<code>256px</code>，那么画布宽高就是样式宽高的两倍了：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">canvas</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">256px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">256px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为画布宽高决定了可视区域的坐标范围，所以 Canvas 将画布宽高和样式宽高分开的做法，能更方便地适配不同的显示设备。</p>
<p>比如，我们要在画布宽高为 <code>500*500</code> 的 Canvas 画布上，绘制一个居中显示的 <code>100*100</code> 宽高的正方形。我们只要将它的坐标设置在  x = 200, y = 200 处即可。这样，不论这个 Canvas 以多大的尺寸显示在各种设备上，我们的代码都不需要修改。否则，如果 Canvas 的坐标范围（画布宽高）跟着样式宽高变化，那么当屏幕尺寸改变的时候，我们就要重新计算需要绘制的图形的所有坐标。</p>
<p>这里顺便说下，Canvas2D的坐标系是<code>左手系</code>，即x轴为水平向右，y轴垂直向下，与我们一般的xy坐标系的y坐标是相反的。另外，其坐标范围是 <code>(0, 0)</code> 到 <code>(canvas.width, canvas.height)</code> 这样的一个平面区域。</p>
<h3 id="获取上下文"><a class="header-anchor" href="#获取上下文"></a>获取上下文</h3>
<p>JS中获取Canvas2D上下文，需要先获取到这个Canvas元素，然后通过其 <code>getContext</code> 方法获取2d上下文：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;canvas&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> context = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="绘制-v2"><a class="header-anchor" href="#绘制-v2"></a>绘制</h3>
<p>在拿到的 <code>context</code> 对象上会有许多API，大致可以分成两类：一类是设置状态的 API，可以设置或改变当前的绘图状态，比如，改变要绘制图形的颜色、线宽、坐标变换等等；另一类是绘制指令 API，用来绘制不同形状的几何图形。</p>
<p>我们将通过上面所获取到的<code>context</code>在画布中心绘制一个红色正方形。</p>
<p>因为将正方形填充成红色，这一步通过调用 <code>context.fillStyle</code> 指令就可以完成。<br>
然后，我们要调用一个 <code>beginPath</code> 的指令，告诉 Canvas 我们现在绘制的路径。<br>
接着，才是调用 <code>rect</code> 指令完成绘图。因为 <code>rect</code> 指令前两个参数<code>x</code> <code>y</code>表示的是矩形的左上角坐标，所以为了在画布中心绘制，还需要将坐标进行调整。我们可以通过改变<code>x</code> <code>y</code>的值进行调整，也可以通过<code>translate</code>指令对画布进行整体平移，在平移后记得进行恢复。</p>
<p>Canvas 上下文还提供了 <code>save</code> 和 <code>restore</code> 方法，可以暂存和恢复画布某个时刻的状态。其中，<code>save</code> 指令不仅可以保存当前的 <code>translate</code> 状态，还可以保存其他的信息，比如，<code>fillStyle</code> 等颜色信息。 而 <code>restore</code> 指令则可以将状态指令恢复成 <code>save</code> 指令前的设置。</p>
<p>最后，我们还要调用 <code>fill</code> 指令，将绘制的内容真正输出到画布中。这样我们就完整了绘制，绘制的效果和代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> rectWidth = <span class="number">100</span></span><br><span class="line"><span class="keyword">const</span> rectHeight = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">context.<span class="title function_">save</span>() <span class="comment">// 暂存状态</span></span><br><span class="line">context.<span class="property">fillStyle</span> = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">context.<span class="title function_">beginPath</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平移</span></span><br><span class="line">context.<span class="title function_">translate</span>(-<span class="number">0.5</span> * rectWidth, -<span class="number">0.5</span> * rectHeight)</span><br><span class="line"></span><br><span class="line">context.<span class="title function_">rect</span>(<span class="number">0.5</span> * canvas.<span class="property">width</span>, <span class="number">0.5</span> * canvas.<span class="property">height</span>, rectWidth, rectHeight)</span><br><span class="line">context.<span class="title function_">fill</span>()</span><br><span class="line"></span><br><span class="line">context.<span class="title function_">restore</span>() <span class="comment">// 恢复状态</span></span><br></pre></td></tr></table></figure>
<p>详细的Canvas教程，可以查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial">MDN的官方文档</a>。</p>
<h2 id="Canvas2D与SVG的对比"><a class="header-anchor" href="#Canvas2D与SVG的对比"></a>Canvas2D与SVG的对比</h2>
<p>在实现效果上，SVG与Canvas差别不大，在使用上的不同点可以分成两方面，一是<strong>写法上的不同</strong>，二是<strong>用户交互实现上的不同</strong>。</p>
<h3 id="写法上的不同"><a class="header-anchor" href="#写法上的不同"></a>写法上的不同</h3>
<p>前文有说到，SVG是一种<strong>声明式</strong>绘图系统，而Canvas是一种<strong>指令式</strong>绘图系统。具体而言，SVG 首先通过创建标签来表示图形元素，<code>circle</code> 表示圆，<code>g</code> 表示分组，<code>text</code> 表示文字等等。接着，SVG 通过元素的 <code>setAttribute</code> 给图形元素赋属性值，这个和操作 HTML 元素是一样的。而 Canvas 先是通过上下文执行绘图指令来绘制图形，画圆是调用 <code>context.arc</code> 指令，然后再调用 <code>context.fill</code> 绘制，画文字是调用 <code>context.fillText</code> 指令。另外，Canvas 还通过上下文设置状态属性，<code>context.fillStyle</code> 设置填充颜色，<code>context.font</code> 设置元素的字体。我们设置的这些状态，在绘图指令执行时才会生效。</p>
<h3 id="用户交互实现上的不同"><a class="header-anchor" href="#用户交互实现上的不同"></a>用户交互实现上的不同</h3>
<p>因为SVG中，一个图形对应一个svg元素，同时SVG也支持CSS样式，所以当我们需要在SVG上增加一些鼠标事件的时候是很方便的。比如，我们需要在鼠标hover某个元素的时候，将这个元素的背景色进行高亮，并且获取这个元素的一些信息，那么我们就可以用如下代码实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">&quot;circle&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;100&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;40&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;black&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;2&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;orange&quot;</span> <span class="attr">data-title</span>=<span class="string">&quot;circle&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> circle = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;circle&#x27;</span>)</span><br><span class="line">circle.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseover&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; target &#125; = e</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="title function_">getAttribute</span>(<span class="string">&#x27;data-title&#x27;</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#circle</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  fill: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们实现的方式跟普通的HTML/CSS的方式完全一样的。</p>
<p>反观Canvas，因为Canvas在HTML是一个独立的canvas元素，所有绘制内容都是在内部使用指令完成的，对于浏览器而言，这些绘制内容都是一个个的像素点，当我们要实现类似于hover或者点击事件的时候，我们就得自己去判断这个鼠标位置跟绘制图形的位置关系。对于如圆形这种简单图形而言，这个判断还算简单，我们只要判断鼠标与每个圆的圆心距离关系即可。但是对于一些不规则图形，这个判断就会变得比较复杂，在后续的文章中，我们将单独介绍。</p>
<h1 id="WebGL"><a class="header-anchor" href="#WebGL"></a>WebGL</h1>
<p>在了解<code>WebGL</code>之前，需要先了解下一些图形系统绘制的原理。</p>
<h2 id="图形系统绘制原理"><a class="header-anchor" href="#图形系统绘制原理"></a>图形系统绘制原理</h2>
<p>一个通用计算机图形系统主要包括 6 个部分，分别是输入设备、中央处理单元、图形处理单元、存储器、帧缓存和输出设备。绘制过程示意如下图：<br>
<img src="render_process.png" alt=""><br>
另外还有几个概念需要先清楚下：</p>
<ul>
<li><strong>光栅（Raster）</strong>：几乎所有的现代图形系统都是基于光栅来绘制图形的，光栅就是指构成图像的像素阵列。</li>
<li><strong>像素（Pixel）</strong>：一个像素对应图像上的一个点，它通常保存图像上的某个具体位置的颜色等信息。</li>
<li><strong>帧缓存（Frame Buffer）</strong>：在绘图过程中，像素信息被存放于帧缓存中，帧缓存是一块内存地址。</li>
<li><strong>CPU（Central Processing Unit）</strong>：中央处理单元，负责逻辑计算。</li>
<li><strong>GPU（Graphics Processing Unit）</strong>：图形处理单元，负责图形计算。</li>
</ul>
<p>清楚了这几个概念后，可以用文字描述下绘制过程：</p>
<p>首先，输入的数据经过 <code>CPU</code> 处理，成为具有特定结构的几何信息。然后，这些信息会被送到 <code>GPU</code> 中进行处理。在 <code>GPU</code> 中要经过两个步骤生成<code>光栅</code>信息。这些<code>光栅</code>信息会输出到<code>帧缓存</code>中，最后渲染到屏幕上。</p>
<p>这个绘制过程是现代计算机中任意一种图形系统处理图形的通用过程。它主要做了两件事，一是对给定的数据结合绘图的场景要素（例如相机、光源、遮挡物体等等）进行计算，最终将图形变为屏幕空间的 2D 坐标。二是为屏幕空间的每个像素点进行着色，把最终完成的图形输出到显示设备上。这整个过程是一步一步进行的，前一步的输出就是后一步的输入，所以我们也把这个过程叫做<code>渲染管线（RenderPipelines）</code>。</p>
<p>同时，我们需要知道GPU与CPU的区别。CPU与GPU都是处理单元，但是其结构不同。对于CPU而言，数据是有序进入CPU进行处理，并被依次输出；而GPU则可以同时处理大批量的数据。</p>
<p>好了，了解完这些原理，接下来我们回到WebGL上。</p>
<h2 id="WebGL如何绘制一个三角形"><a class="header-anchor" href="#WebGL如何绘制一个三角形"></a>WebGL如何绘制一个三角形</h2>
<p>在使用 WebGL 进行绘制时，大致需要以下步骤：</p>
<ol>
<li>创建 WebGL 上下文</li>
<li>创建 WebGL 程序（WebGL Program）</li>
<li>将数据存入缓冲区</li>
<li>将缓冲区数据读取到 GPU</li>
<li>GPU 执行 WebGL 程序，输出结果</li>
</ol>
<p>这里，通过绘制一个三角形进行简单介绍。</p>
<h3 id="创建-WebGL-上下文"><a class="header-anchor" href="#创建-WebGL-上下文"></a>创建 WebGL 上下文</h3>
<p>建 WebGL 上下文这一步和 Canvas2D 的使用几乎一样，我们只要调用 canvas 元素的 getContext 即可，区别是将参数从<code>2d</code>换成<code>webgl</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;canvas&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> gl = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;webgl&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>不过，有了 <code>WebGL</code> 上下文对象之后，我们并不能像使用 <code>Canvas2D</code> 的上下文那样，调用几个绘图指令就把图形画出来，还需要做很多工作。</p>
<h3 id="创建-WebGL-程序"><a class="header-anchor" href="#创建-WebGL-程序"></a>创建 WebGL 程序</h3>
<p>接下来，我们要创建一个 WebGL 程序。这里的 WebGL 程序是一个 <code>WebGLProgram</code> 对象，它是给 GPU 最终运行着色器的程序，而不是我们正在写的三角形的 JavaScript 程序。</p>
<p>首先，要创建这个 WebGL 程序，我们需要编写两个<strong>着色器</strong>（Shader）。着色器是用 <code>GLSL</code> 这种编程语言（类似于C语言）编写的代码片段，在这里，我们暂时只需要理解绘制三角形的这两个着色器的作用就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vertex = <span class="string">`</span></span><br><span class="line"><span class="string">  attribute vec2 position;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  void main() &#123;</span></span><br><span class="line"><span class="string">    gl_Position = vec4(position, 1.0, 1.0);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fragment = <span class="string">`</span></span><br><span class="line"><span class="string">  precision mediump float;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  void main()</span></span><br><span class="line"><span class="string">  &#123;</span></span><br><span class="line"><span class="string">    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);</span></span><br><span class="line"><span class="string">  &#125;    </span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>
<p>为什么是两个着色器？这就要求我们先理解另外两个概念：<code>顶点</code>和<code>图元</code>。在绘制的时候，WebGL是以顶点和图元来描述图形的几何信息的。<code>顶点</code>就是几何图形的顶点，比如，三角形有三个顶点，矩形有四个顶点。<code>图元</code>是WebGL能够处理的最小图形单元，由WebGL的绘图模式决定，有<strong>点、线、三角形三种</strong>。</p>
<p>因此，在绘图过程中，顶点和图元是必不可少的，也因此，在WebGL的绘制过程中，一般需要定义两个着色器，一个叫<code>顶点着色器</code>（Vertex Shader）负责处理图形的顶点信息，另一个叫<code>片元着色器</code>（Fragment Shader）负责处理图形的像素信息。</p>
<p>具体点来说，我们可以把<strong>顶点着色器理解为处理顶点的 GPU 程序代码。它可以改变顶点的信息</strong>（如顶点的坐标、法线方向、材质等等），从而改变我们绘制出来的图形的形状或者大小等等。</p>
<p>顶点处理完成之后，WebGL 就会根据顶点和绘图模式指定的图元，计算出需要着色的像素点，然后对它们执行片元着色器程序。简单来说，就是对指定图元中的像素点着色。</p>
<p>WebGL 从顶点着色器和图元提取像素点给片元着色器执行代码的过程，就是我们前面说的生成光栅信息的过程，我们也叫它光栅化过程。所以，<strong>片元着色器的作用，就是处理光栅化后的像素信息</strong>。</p>
<p>举个例子,我们可以将图元设为线段，那么片元着色器就会处理顶点之间的线段上的像素点信息，这样画出来的图形就是空心的。而如果我们把图元设为三角形，那么片元着色器就会处理三角形内部的所有像素点，这样画出来的图形就是实心的。</p>
<p>这边有两点需要注意的。一是图元是 WebGL 可以直接处理的图形单元，所以<strong>其他非图元的图形最终必须要转换为图元</strong>才可以被 WebGL 处理。举个例子，如果我们要绘制实心的四边形，我们就需要将四边形拆分成两个三角形，再交给 WebGL 分别绘制出来。二是<strong>无论有多少个像素点，片元着色器都可以同时处理</strong>，这也是片元着色器一大特点。</p>
<p>介绍完两种着色器，我们继续回到代码。</p>
<p>我们上面定义了顶点着色器和片元着色器两个代码段，接着，我们需要将这两个代码段创建成<code>shader</code>对象，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vertexShader = gl.<span class="title function_">createShader</span>(gl.<span class="property">VERTEX_SHADER</span>)</span><br><span class="line">gl.<span class="title function_">shaderSource</span>(vertexShader, vertex)</span><br><span class="line">gl.<span class="title function_">compileShader</span>(vertexShader)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fragmentShader = gl.<span class="title function_">createShader</span>(gl.<span class="property">FRAGMENT_SHADER</span>)</span><br><span class="line">gl.<span class="title function_">shaderSource</span>(fragmentShader, fragment)</span><br><span class="line">gl.<span class="title function_">compileShader</span>(fragmentShader)</span><br></pre></td></tr></table></figure>
<p>接着，我们创建一个 <code>WebGLProgram</code> 对象，并将这两个 <code>shader</code> 关联到这个 WebGL 程序上。WebGLProgram 对象的创建过程主要是添加 vertexShader 和 fragmentShader，然后将这个 WebGLProgram 对象链接到 WebGL 上下文对象上。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> program = gl.<span class="title function_">createProgram</span>()</span><br><span class="line">gl.<span class="title function_">attachShader</span>(program, vertexShader)</span><br><span class="line">gl.<span class="title function_">attachShader</span>(program, fragmentShader)</span><br><span class="line">gl.<span class="title function_">linkProgram</span>(program)</span><br></pre></td></tr></table></figure>
<p>最后，我们要通过 <code>useProgram</code> 选择启用这个 WebGLProgram 对象。这样，当我们绘制图形时，GPU 就会执行我们通过 WebGLProgram 设定的 两个 <code>shader</code> 程序了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gl.<span class="title function_">useProgram</span>(program)</span><br></pre></td></tr></table></figure>
<p>到此为止，我们已经完成了 WebGL 程序的创建。</p>
<h3 id="将数据存入缓冲区"><a class="header-anchor" href="#将数据存入缓冲区"></a>将数据存入缓冲区</h3>
<p>与<code>Canvas</code>的坐标系不同，<code>WebGL</code>的坐标系是<code>右手系</code>，并且其坐标范围恒为<code>x∈[-1, 1], y∈[-1,1]</code>这样一个区域。</p>
<p>这里我们绘制一个三个顶点分别为(-1, -1)、(0, 1)、(1, -1)的三角形。</p>
<p><strong>首先，我们要定义这个三角形的三个顶点</strong>。WebGL 使用的数据需要用类型数组定义，默认格式是 <code>Float32Array</code> 这种类型化数组，其使用起来跟普通的<code>Array</code>差不多，具体可以看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">MDN的官方文档</a>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> points = <span class="keyword">new</span> <span class="title class_">Float32Array</span>([</span><br><span class="line">  -<span class="number">1</span>, -<span class="number">1</span>,</span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>, -<span class="number">1</span>,</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p><strong>接着，我们要将定义好的数据写入 WebGL 的缓冲区</strong>。这个过程我们可以简单总结为三步，分别是:</p>
<ol>
<li>创建一个缓存对象</li>
<li>将它绑定为当前操作对象</li>
<li>再把当前的数据写入缓存对象。</li>
</ol>
<p>这三个步骤主要是利用 <code>createBuffer</code>、<code>bindBuffer</code>、<code>bufferData</code> 方法来实现的，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bufferId = gl.<span class="title function_">createBuffer</span>()</span><br><span class="line">gl.<span class="title function_">bindBuffer</span>(gl.<span class="property">ARRAY_BUFFER</span>, bufferId)</span><br><span class="line">gl.<span class="title function_">bufferData</span>(gl.<span class="property">ARRAY_BUFFER</span>, points, gl.<span class="property">STATIC_DRAW</span>)</span><br></pre></td></tr></table></figure>
<h3 id="将缓冲区数据读取到-GPU"><a class="header-anchor" href="#将缓冲区数据读取到-GPU"></a>将缓冲区数据读取到 GPU</h3>
<p>经过以上步骤，我们已经把数据写到缓冲区了，接下来我们要将数据绑定到上面定义的顶点着色器的<code>position</code>变量，使得<code>shader</code>能够读取到我们定义的数据。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vPosition = gl.<span class="title function_">getAttribLocation</span>(program, <span class="string">&#x27;position&#x27;</span>) <span class="comment">// 获取顶点着色器中的position变量的地址</span></span><br><span class="line">gl.<span class="title function_">vertexAttribPointer</span>(vPosition, <span class="number">2</span>, gl.<span class="property">FLOAT</span>, <span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span>) <span class="comment">// 给变量设置长度和类型</span></span><br><span class="line">gl.<span class="title function_">enableVertexAttribArray</span>(vPosition) <span class="comment">// 激活这个变量</span></span><br></pre></td></tr></table></figure>
<h3 id="执行着色器程序完成绘制"><a class="header-anchor" href="#执行着色器程序完成绘制"></a>执行着色器程序完成绘制</h3>
<p>现在，我们已经有了 WebGL 程序，也将数据写到缓冲区，并且着色器也能拿到缓冲区里的数据了。那么，现在我们就可以进行绘制了这里我们选择 <code>gl.TRIANGLES</code> 表示以三角形为图元绘制，再传入绘制的顶点偏移量和顶点数量，WebGL 就会将对应的 <code>buffer</code> 数组传给顶点着色器，并且开始绘制。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gl.<span class="title function_">drawArrays</span>(gl.<span class="property">TRIANGLES</span>, <span class="number">0</span>, points.<span class="property">length</span> / <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>最终绘制结果如下：<br>
<img src="webgl_result.png" alt=""></p>
<h2 id="片元着色器"><a class="header-anchor" href="#片元着色器"></a>片元着色器</h2>
<p>回顾下上面的片元着色器代码：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>第1行中，我们全局声明了片元着色器中浮点数类型的精度。<br>
第4行中，<code>gl_FragColor</code> 是 WebGL 片元着色器的一个内置变量，表示当前像素点颜色，它是一个用 <code>RGBA</code> 色值表示的四维向量数据。上面的代码中，我们赋值为<code>vec4(1.0, 0.0, 0.0, 1.0)</code>，所以最后绘制出来的三角形是红色的，如果我们赋值为<code>vec4(0.0, 0.0, 1.0, 1.0)</code>，那么最终绘制出来的就是一个蓝色三角形。</p>
<p>可以看到，我们只改变了一个颜色，最终所有像素点的颜色都跟着变成了蓝色，这也说明了GPU是<strong>同时</strong>对<strong>所有像素点</strong>都执行了这段着色器代码的。</p>
<h2 id="顶点着色器"><a class="header-anchor" href="#顶点着色器"></a>顶点着色器</h2>
<p>看完片元着色器，我们在接着看下顶点着色器：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">attribute</span> <span class="type">vec2</span> position;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(position, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第1行中，我们使用<code>attribute</code>声明了一个<code>vec2</code>类型的二维向量<code>position</code>。<br>
<code>attribute</code>是一种<code>存储限定符</code>(类似于js中的<code>var/let/const</code>)，此外，还存在 <code>uniform</code>, <code>varying</code> 这两种存储限定符，这边简要介绍下：</p>
<ul>
<li><code>attribute</code>: 只能出现在顶点着色器中，被用来从外部（如JS程序）向 WebGL 内部中传递顶点信息（比如坐标、颜色）</li>
<li><code>uniform</code>: 可以出现在顶点着色器和片元着色器中，可以理解为只读的全局变量，也是用于外部程序向 WebGL 内部传递信息</li>
<li><code>varying</code>: 可以出现在顶点着色器和片元着色器中，可以理解为可变的全局变量，是顶点着色器向片元着色器传递信息的渠道</li>
</ul>
<p>第4行中，<code>gl_Position</code> 是 WebGL 顶点着色器的一个内置变量，表示当前顶点坐标的位置，是一个<strong>四维向量</strong>数据，注意，WebGL 中的坐标虽然是三维坐标，但是在表示坐标时，WebGL 使用的是<strong>齐次坐标</strong>进行表示，针对(x, y, z, w)这样一个齐次坐标，等同于(x/w, y/w, z/w)这样一个三维坐标。</p>
<p>这边介绍下<code>varying</code>的用法。</p>
<p>我们修改上面的顶点着色器代码为下面这样：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">attribute</span> <span class="type">vec2</span> position;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec3</span> color;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">gl_PointSize</span> = <span class="number">1.0</span>;</span><br><span class="line">  color = <span class="type">vec3</span>(<span class="number">0.5</span> + position * <span class="number">0.5</span>, <span class="number">0.0</span>);</span><br><span class="line">  <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(position * <span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边我们声明了一个<code>color</code>的变量，并且通过顶点坐标映射了一个颜色<br>
（<code>vec3(0.5 + position * 0.5, 0.0)</code>），这样子，顶点(-1, -1)对应的颜色就是(0, 0, 0)，也就是黑色，顶点(0, 1)对应的颜色就是(0.5, 1, 0)、顶点(1, -1)对应的颜色就是(1, 0, 0)。</p>
<p>然后，我们也对片元着色器进行修改：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec3</span> color;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(color, <span class="number">1.0</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>同样的，我们也在片元着色器内声明了<code>color</code>变量，并且将<code>gl_FragColor</code>使用<code>color</code>进行赋值。这样，我们就得到了一个渐变色的三角形：<br>
<img src="webgl_varying_result.png" alt=""></p>
<p>可以发现，三个顶点中间像素点的颜色是均匀过渡的。这是因为 WebGL 在执行片元着色器程序的时候，顶点着色器传给片元着色器的变量，会根据片元着色器的像素坐标对变量进行<strong>线性插值</strong>。</p>
<p>详细的WebGL教程，可以查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API">MDN的官方文档</a>。</p>
<h1 id="参考-v6"><a class="header-anchor" href="#参考-v6"></a>参考</h1>
<p><a href="https://time.geekbang.org/column/intro/100053801?tab=catalog">极客时间 - 跟月影学可视化</a><br>
<a href="https://github.com/lesnitsky/webgl-month">Github - lesnitsky/webgl-month</a><br>
<a href="https://xie.infoq.cn/article/511aa64f69530ed3061829351">入门 WebGL，看这一篇就够了</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>可视化</tag>
      </tags>
  </entry>
</search>
